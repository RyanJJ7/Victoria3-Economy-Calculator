#include "ProductionMethods.h"
#include "Buildings.h"
#include "Locations.h"
#include <iostream>
#include <iomanip>

const int GSIZE = 52;
const int BSIZE = 63;
const int SSIZE = 1337;

void reset();
void initialize(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float&, float&, float&, int&, float&, int[], bool[][2]);
void vanilla(goodsType[], productionMethodsType&, buildingsType[], string[], bool, bool);
void setMilitaryConsumption(goodsType[], productionMethodsType&, int, float, int, string);
void setInputGood(goodsType[], productionMethodsType&, int, float, int, string);
void setOutputGood(goodsType[], productionMethodsType&, int, float, int, string);
float trunc1D(float);
float trunc2D(float);
void menu(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float&, float&, float&, int&, float&, int[], bool[][2]);
void infamyMenu(float&);
void nationalMenu(goodsType[], float&, int[], bool[][2]);
void nationalMenu(goodsType[], int&, float&, int[], bool[][2]);
float economyOfScale();
void armyMobilization(bool[][2]);
int citizenshipLaw();
void nationalMarket(goodsType[]);
void nationalMarket(goodsType[], float);
void balance(goodsType[], int);
void balance(goodsType[], float, int);
void production(goodsType);
void production(goodsType[], float, int);
void goodData(goodsType);
void productionProfit(goodsType, float);
void productionProfit(goodsType, float, float);
void stateMenu(goodsType[], buildingsType[], float&, float&);
void stateMenu(goodsType[], buildingsType[], float&, float&, float);
void stateData(goodsType[], buildingsType[], float&, float&, string);
void selectBuilding(buildingsType[]);
void stateBuildingData(buildingsType[], int);
void localMarket(goodsType[], float);
void localMarket(goodsType[], float, float, float);
void localBalance(goodsType[], float, int);
void localBalance(goodsType[], float, float, float, int);
void production(goodsType, float);
void production(goodsType[], float, float, float, int);
void goodData(goodsType, float);
void productionProfit(goodsType, float, float, float);
void productionProfit(goodsType, float, float, float, float);
void buildings(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2]);
void buildings(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2]);
float profit(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int);
float profit(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int);
float profitImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int);
float profitImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int);
float productivity(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int);
float productivity(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int);
float productivityImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int);
float productivityImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int);
void sectors(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int);
void sectors(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int);
void sectorsImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int);
void sectorsImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int);
float profit(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int, int);
float profit(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int, int);
float profitImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int, int);
float profitImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int, int);
float productivity(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int, int);
float productivity(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int, int);
float productivityImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, bool[][2], int, int);
float productivityImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], float, float, float, bool[][2], int, int);
void construction(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int, int);
void construction(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int, int);
void constructionImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int, int);
void constructionImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int, int);
void state(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int, int);
void state(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int, int);
void stateImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int, int);
void stateImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int, int);
void stateEoSOverride(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int, int);
void stateEoSOverride(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int, int);
void stateEoSOverrideImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, int[], bool[][2], int, int);
void stateEoSOverrideImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float, float, float, float, int[], bool[][2], int, int);
int armyUnitType();
int navyUnitType();
void employment(string[], int[], int[], int[], int[], int[]);
void profitability(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float[], float[], float[], float[], float[][6], float, int, int, int[], int[], int[][2], int[][2], int[][2], int[][2], int[][2], float[], int, int);
void profitability(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float[], float[], float[], float[], float[], float[], float[][6], float, int, int, int[], int[], int[][2], int[][2], int[][2], int[][2], int[][2], float[], int, int);
void profitabilityImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float[], float[], float[], float[], float[][6], float, int, int, int[], int[], int[][2], int[][2], int[][2], int[][2], int[][2], float[], int, int);
void profitabilityImportsCanceled(goodsType[], productionMethodsType&, buildingsType[], locationsType[], string[], float[], float[], float[], float[], float[], float[], float[][6], float, int, int, int[], int[], int[][2], int[][2], int[][2], int[][2], int[][2], float[], int, int);
float getPurchaseWeight(goodsType[], float, int);
float getPurchaseWeight(goodsType[], float, float, int, int);
float getPurchaseWeightLocalOutput(goodsType[], float, float, int, int);
float getPurchaseWeight(goodsType[], float[], float[], float, int);
float getPurchaseWeightImportsCanceled(goodsType[], float[], float[], float, int);
float getLocalPurchaseWeight(goodsType[], float, int);
float getLocalPurchaseWeight(goodsType[], float, float, int, int);
float getLocalPurchaseWeight(goodsType[], float[], float[], float, int);
float getLocalPurchaseWeightImportsCanceled(goodsType[], float[], float[], float, int);
void save(goodsType[], buildingsType[], locationsType[], float, float, float, int, float, int[], bool[][2]);

int main()
{
	goodsType good[GSIZE];
	productionMethodsType method;
	buildingsType building[BSIZE];
	locationsType location[SSIZE];
	string profession[PSIZE];
	float inf;
	float mapi;
	float gdp;
	int states;
	float eosCap;
	int citizenship[2];
	bool mobilization[ASIZE][2];
	bool reinitialize = false;
	bool setMethods = false;
	bool testing = false;

	if (reinitialize) {
		reset();
		if (setMethods) {
			cout << "Loading...";
			vanilla(good, method, building, profession, false, setMethods);
		}
		vanilla(good, method, building, profession, true, false);
	}
	else if (setMethods) {
		cout << "Loading...";
		vanilla(good, method, building, profession, false, setMethods);
		vanilla(good, method, building, profession, true, false);
	}
	else if (testing)
		vanilla(good, method, building, profession, testing, setMethods);
	else {
		initialize(good, method, building, location, profession, inf, mapi, gdp, states, eosCap, citizenship, mobilization);
		menu(good, method, building, location, profession, inf, mapi, gdp, states, eosCap, citizenship, mobilization);
		save(good, building, location, inf, mapi, gdp, states, eosCap, citizenship, mobilization);
	}

	return 0;
}

void reset()
{
	ofstream outFile;

	outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Infamy.txt");
	outFile.close();
	outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Goods.txt");
	outFile.close();
	outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Buildings.txt");
	outFile.close();
	fs::remove_all("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\States");
	fs::create_directory("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\States");
}

void initialize(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float& inf, float& mapi, float& gdp, int& states, float& eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	float sell = 0;
	float buy = 0;
	float production = 0;
	float consumption = 0;
	float popConsumption = 0;
	float localPopConsumption = 0;
	float imports = 0;
	float throughput = 0;
	float obsession = 0;
	float taboo = 0;
	float localObsession = 0;
	float localTaboo = 0;
	float wage = 0;
	int level = 0;
	int subsidized = 0;
	int methodLevel = 0;
	ifstream inFile;
	inf = 0;
	mapi = 0.75;
	gdp = 1;
	states = 1;
	eosCap = 1.2;
	for (int i = 0; i < 2; i++) {
		citizenship[i] = 0;
		for (int j = 0; j < ASIZE; j++)
			mobilization[j][i] = 0;
	}
	
	vanilla(good, method, building, profession, false, false);
	inFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Infamy.txt");
	inFile >> inf;
	inFile.close();
	inFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Goods.txt");
	for (int i = 0; i < GSIZE; i++) {
		inFile >> sell
			   >> buy
			   >> production
			   >> consumption
			   >> popConsumption
			   >> localPopConsumption
			   >> imports
			   >> throughput
			   >> obsession
			   >> taboo
			   >> localObsession
			   >> localTaboo;
		good[i].setSellOrders(sell);
		good[i].setBuyOrders(buy);
		good[i].setProduction(production);
		good[i].setConsumption(consumption);
		good[i].setPopConsumption(popConsumption);
		good[i].setLocalPopConsumption(localPopConsumption);
		good[i].setImports(imports);
		good[i].setThroughput(throughput);
		good[i].setObsession(obsession);
		good[i].setTaboo(taboo);
		good[i].setLocalObsession(localObsession);
		good[i].setLocalTaboo(localTaboo);
	}
	inFile >> mapi
		   >> gdp
		   >> states;
	inFile.close();
	inFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Buildings.txt");
	for (int i = 1; i < BSIZE; i++) {
		for (int j = building[i - 1].getBuildingLocation(); j < building[i].getBuildingLocation(); j++) {
			inFile >> level
				   >> subsidized;
			location[j].setLevel(level);
			location[j].setSubsidized(subsidized);
			for (int k = 0; k < building[i - 1].getSize(); k++) {
				inFile >> methodLevel;
				location[j].setProductionMethodLevel(methodLevel, k);
			}
			inFile >> throughput;
			location[j].setBuildingThroughput(throughput);
		}
		for (int j = 0; j < 7; j++) {
			inFile >> throughput;
			building[i - 1].setThroughput(throughput, j);
		}
		inFile >> wage;
		building[i - 1].setBaseWage(wage);
	}
	for (int i = 0; i < ASIZE; i++) {
		for (int j = 0; j < 2; j++)
			inFile >> mobilization[i][j];
	}
	for (int i = 0; i < 2; i++)
		inFile >> citizenship[i];
	inFile >> eosCap;
	inFile.close();
}

void vanilla(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], string profession[PSIZE], bool testing, bool setMethods)
{
	int i = 0;
	good[i].setGood("Aeroplanes");
	if (!setMethods) {
		good[i].setBasePrice(80);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 13);
		good[i].setMaxSS(0.2, 13);
	}
	good[++i].setGood("Ammunition");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Artillery");
	if (!setMethods) {
		good[i].setBasePrice(70);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Automobiles");
	if (!setMethods) {
		good[i].setBasePrice(100);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1.25, 11);
		good[i].setWeight(1, 13);
		good[i].setMaxSS(0.25, 13);
	}
	good[++i].setGood("Clippers");
	if (!setMethods) {
		good[i].setBasePrice(60);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 13);
		good[i].setMaxSS(0.25, 13);
	}
	good[++i].setGood("Clothes");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(2, 2);
		good[i].setDefault(true, 3);
		good[i].setWeight(1, 3);
	}
	good[++i].setGood("Coal");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(2, 7);
		good[i].setMaxSS(0.8, 7);
	}
	good[++i].setGood("Coffee");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 9);
		good[i].setMaxSS(0.75, 9);
	}
	good[++i].setGood("Dye");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Electricity");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(3, 7);
	}
	good[++i].setGood("Engines");
	if (!setMethods) {
		good[i].setBasePrice(60);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Explosives");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Fabric");
	if (!setMethods) {
		good[i].setBasePrice(20);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 2);
		good[i].setWeight(1, 2);
		good[i].setMaxSS(0.5, 2);
		good[i].setWeight(0.25, 7);
		good[i].setMaxSS(0.25, 7);
	}
	good[++i].setGood("Fertilizer");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Fine Art");
	if (!setMethods) {
		good[i].setBasePrice(200);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(4, 13);
	}
	good[++i].setGood("Fish");
	if (!setMethods) {
		good[i].setBasePrice(20);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 0);
		good[i].setMaxSS(0.9, 0);
	}
	good[++i].setGood("Fruit");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.5, 0);
		good[i].setMaxSS(0.9, 0);
		good[i].setWeight(1, 1);
		good[i].setMinSS(0.1, 1);
		good[i].setMaxSS(0.75, 1);
	}
	good[++i].setGood("Furniture");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(2, 4);
		good[i].setDefault(true, 5);
		good[i].setWeight(1, 5);
		good[i].setMinSS(0.1, 5);
		good[i].setMaxSS(0.75, 5);
	}
	good[++i].setGood("Glass");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 5);
		good[i].setMaxSS(0.5, 5);
	}
	good[++i].setGood("Gold");
	if (!setMethods) {
		good[i].setBasePrice(100);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Grain");
	if (!setMethods) {
		good[i].setBasePrice(20);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 0);
		good[i].setWeight(1, 0);
		good[i].setMaxSS(0.9, 0);
	}
	good[++i].setGood("Groceries");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.75, 0);
		good[i].setMaxSS(0.9, 0);
		good[i].setWeight(1.5, 1);
	}
	good[++i].setGood("Hardwood");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Iron");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Ironclads");
	if (!setMethods) {
		good[i].setBasePrice(80);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Lead");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Liquor");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 8);
		good[i].setWeight(1, 8);
		good[i].setMaxSS(0.75, 8);
	}
	good[++i].setGood("Luxury Clothes");
	if (!setMethods) {
		good[i].setBasePrice(60);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 6);
		good[i].setWeight(1, 6);
		good[i].setMinSS(0.1, 6);
		good[i].setMaxSS(0.5, 6);
	}
	good[++i].setGood("Luxury Furniture");
	if (!setMethods) {
		good[i].setBasePrice(60);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 6);
		good[i].setMinSS(0.1, 6);
		good[i].setMaxSS(0.5, 6);
	}
	good[++i].setGood("Man-o-Wars");
	if (!setMethods) {
		good[i].setBasePrice(70);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Meat");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.5, 0);
		good[i].setMaxSS(0.9, 0);
		good[i].setDefault(true, 1);
		good[i].setWeight(1, 1);
		good[i].setMinSS(0.1, 1);
		good[i].setMaxSS(0.75, 1);
	}
	good[++i].setGood("Oil");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(3, 7);
	}
	good[++i].setGood("Opium");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1.5, 8);
		good[i].setMaxSS(0.75, 8);
		good[i].setWeight(0.5, 13);
		good[i].setMaxSS(0.5, 13);
	}
	good[++i].setGood("Paper");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.5, 5);
		good[i].setMaxSS(0.5, 5);
	}
	good[++i].setGood("Porcelain");
	if (!setMethods) {
		good[i].setBasePrice(70);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 6);
		good[i].setMinSS(0.1, 6);
		good[i].setMaxSS(0.5, 6);
	}
	good[++i].setGood("Radios");
	if (!setMethods) {
		good[i].setBasePrice(80);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 6);
		good[i].setMaxSS(0.5, 6);
		good[i].setWeight(1, 13);
		good[i].setMaxSS(0.2, 13);
	}
	good[++i].setGood("Rubber");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Services");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 10);
		good[i].setWeight(1, 10);
		good[i].setDefault(true, 13);
		good[i].setWeight(0.1, 13);
	}
	good[++i].setGood("Silk");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Small Arms");
	if (!setMethods) {
		good[i].setBasePrice(60);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.75, 13);
		good[i].setMaxSS(0.25, 13);
	}
	good[++i].setGood("Steamers");
	if (!setMethods) {
		good[i].setBasePrice(70);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.75, 13);
		good[i].setMaxSS(0.25, 13);
	}
	good[++i].setGood("Steel");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Sugar");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.5, 1);
		good[i].setMaxSS(0.5, 1);
	}
	good[++i].setGood("Sulfur");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Tanks");
	if (!setMethods) {
		good[i].setBasePrice(80);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Tea");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 9);
		good[i].setWeight(1, 9);
		good[i].setMaxSS(0.75, 9);
	}
	good[++i].setGood("Telephones");
	if (!setMethods) {
		good[i].setBasePrice(70);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(2, 12);
	}
	good[++i].setGood("Tobacco");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(1, 8);
		good[i].setMaxSS(0.75, 8);
	}
	good[++i].setGood("Tools");
	if (!setMethods) {
		good[i].setBasePrice(40);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
	}
	good[++i].setGood("Transportation");
	if (!setMethods) {
		good[i].setBasePrice(30);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 11);
		good[i].setWeight(1, 11);
		good[i].setMaxSS(0.75, 11);
		good[i].setDefault(true, 12);
		good[i].setWeight(1, 12);
		good[i].setMaxSS(0.75, 12);
	}
	good[++i].setGood("Wine");
	if (!setMethods) {
		good[i].setBasePrice(50);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setWeight(0.25, 8);
		good[i].setMaxSS(0.25, 8);
		good[i].setWeight(0.33, 9);
		good[i].setMaxSS(0.33, 9);
	}
	good[++i].setGood("Wood");
	if (!setMethods) {
		good[i].setBasePrice(20);
		for (int j = 0; j < NSIZE; j++) {
			good[i].setDefault(false, j);
			good[i].setWeight(0, j);
			good[i].setMinSS(0, j);
			good[i].setMaxSS(1, j);
		}
		good[i].setDefault(true, 4);
		good[i].setWeight(1, 4);
		good[i].setMaxSS(0.5, 4);
		good[i].setDefault(true, 7);
		good[i].setWeight(0.75, 7);
		good[i].setMaxSS(0.5, 7);
		if (testing) {
			system("cls");
			cout << "GSIZE: " << i + 1 << endl;
		}
	}
	i = 0;
	int j = 0;
	int k = 0;
	if (setMethods) {
		fs::remove_all("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Production Methods");
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 40, 0, "Grain");
		setOutputGood(good, method, i, 45, 0, "Groceries");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 40, 1, "Grain");
		setInputGood(good, method, i, 15, 1, "Sugar");
		setOutputGood(good, method, i, 65, 1, "Groceries");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 80, 2, "Grain");
		setInputGood(good, method, i, 30, 2, "Sugar");
		setOutputGood(good, method, i, 120, 2, "Groceries");
		method.setProfession(i, 250, 2, "Engineers");
		method.setProfession(i, 3500, 2, "Laborers");
		method.setProfession(i, 750, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setBuilding("Food Industries");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Canning");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 1, "Iron");
		setInputGood(good, method, i, -20, 1, "Grain");
		setInputGood(good, method, i, 20, 1, "Meat");
		setOutputGood(good, method, i, 30, 1, "Groceries");
		method.setProfession(i, 500, 1, "Machinists");
		setInputGood(good, method, i, 10, 2, "Iron");
		setInputGood(good, method, i, -20, 2, "Grain");
		setInputGood(good, method, i, 30, 2, "Fish");
		setOutputGood(good, method, i, 30, 2, "Groceries");
		method.setProfession(i, 500, 2, "Machinists");
		setInputGood(good, method, i, 10, 3, "Iron");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, -30, 3, "Grain");
		setInputGood(good, method, i, 30, 3, "Fish");
		setInputGood(good, method, i, 20, 3, "Meat");
		setOutputGood(good, method, i, 60, 3, "Groceries");
		method.setProfession(i, 200, 3, "Engineers");
		method.setProfession(i, 500, 3, "Machinists");
	}
	else {
		k *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Distilleries");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 25, 1, "Sugar");
		setOutputGood(good, method, i, 60, 1, "Liquor");
		setOutputGood(good, method, i, -30, 1, "Groceries");
		method.setProfession(i, 250, 1, "Machinists");
		method.setProfession(i, 100, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Glass");
		setInputGood(good, method, i, 25, 2, "Sugar");
		setOutputGood(good, method, i, 100, 2, "Liquor");
		setOutputGood(good, method, i, -40, 2, "Groceries");
		method.setProfession(i, 200, 2, "Engineers");
		method.setProfession(i, 500, 2, "Machinists");
		method.setProfession(i, 200, 2, "Shopkeepers");
	}
	else {
		k *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 1, "Tools");
		method.setProfession(i, -2500, 1, "Laborers");
	}
	else {
		k *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 40, 0, "Fabric");
		setOutputGood(good, method, i, 45, 0, "Clothes");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 40, 1, "Fabric");
		setInputGood(good, method, i, 5, 1, "Dye");
		setOutputGood(good, method, i, 60, 1, "Clothes");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 5, 2, "Tools");
		setInputGood(good, method, i, 60, 2, "Fabric");
		setInputGood(good, method, i, 10, 2, "Dye");
		setOutputGood(good, method, i, 100, 2, "Clothes");
		method.setProfession(i, 250, 2, "Engineers");
		method.setProfession(i, 3500, 2, "Laborers");
		method.setProfession(i, 750, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 10, 3, "Tools");
		setInputGood(good, method, i, 60, 3, "Fabric");
		setInputGood(good, method, i, 10, 3, "Electricity");
		setInputGood(good, method, i, 20, 3, "Dye");
		setOutputGood(good, method, i, 140, 3, "Clothes");
		method.setProfession(i, 500, 3, "Engineers");
		method.setProfession(i, 3000, 3, "Laborers");
		method.setProfession(i, 1000, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i);
		building[++j].setBuilding("Textile Mills");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
	}
	int size = method.getSize(i++);
	if (setMethods) {
		method.setProductionMethod(i, "Luxury Production");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, -15, 1, "Fabric");
		setInputGood(good, method, i, 15, 1, "Silk");
		setOutputGood(good, method, i, 30, 1, "Luxury Clothes");
		setOutputGood(good, method, i, -30, 1, "Clothes");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Rubber");
		setInputGood(good, method, i, -35, 2, "Fabric");
		setInputGood(good, method, i, 35, 2, "Silk");
		setOutputGood(good, method, i, 70, 2, "Luxury Clothes");
		setOutputGood(good, method, i, -70, 2, "Clothes");
		method.setProfession(i, 1000, 2, "Shopkeepers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Tools");
		method.setProfession(i, -1500, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Tools");
		setInputGood(good, method, i, 10, 2, "Electricity");
		method.setProfession(i, -2500, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Fabric");
		setInputGood(good, method, i, 30, 0, "Wood");
		setOutputGood(good, method, i, 45, 0, "Furniture");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 5, 1, "Tools");
		setInputGood(good, method, i, 10, 1, "Fabric");
		setInputGood(good, method, i, 30, 1, "Wood");
		setOutputGood(good, method, i, 65, 1, "Furniture");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3250, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Tools");
		setInputGood(good, method, i, 10, 2, "Fabric");
		setInputGood(good, method, i, 50, 2, "Wood");
		setOutputGood(good, method, i, 110, 2, "Furniture");
		method.setProfession(i, 750, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1250, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Furniture Manufacturies");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Luxury Production");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, -15, 1, "Wood");
		setInputGood(good, method, i, 15, 1, "Hardwood");
		setOutputGood(good, method, i, -25, 1, "Furniture");
		setOutputGood(good, method, i, 25, 1, "Luxury Furniture");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Tools");
		setInputGood(good, method, i, -25, 2, "Wood");
		setInputGood(good, method, i, 25, 2, "Hardwood");
		setOutputGood(good, method, i, -55, 2, "Furniture");
		setOutputGood(good, method, i, 55, 2, "Luxury Furniture");
		method.setProfession(i, 1000, 2, "Shopkeepers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Tools");
		setInputGood(good, method, i, 5, 1, "Coal");
		method.setProfession(i, -1500, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Tools");
		setInputGood(good, method, i, 10, 2, "Coal");
		method.setProfession(i, -2000, 2, "Laborers");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 5, 3, "Tools");
		setInputGood(good, method, i, 5, 3, "Electricity");
		method.setProfession(i, -3000, 3, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 30, 0, "Wood");
		setOutputGood(good, method, i, 30, 0, "Glass");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 20, 1, "Wood");
		setInputGood(good, method, i, 10, 1, "Lead");
		setOutputGood(good, method, i, 40, 1, "Glass");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 35, 2, "Lead");
		setOutputGood(good, method, i, 60, 2, "Glass");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 20, 3, "Oil");
		setInputGood(good, method, i, 30, 3, "Lead");
		setOutputGood(good, method, i, 100, 3, "Glass");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2500, 3, "Laborers");
		method.setProfession(i, 1250, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Glassworks");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Luxury Production");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Dye");
		setOutputGood(good, method, i, -10, 1, "Glass");
		setOutputGood(good, method, i, 10, 1, "Porcelain");
		method.setProfession(i, 250, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Dye");
		setOutputGood(good, method, i, -20, 2, "Glass");
		setOutputGood(good, method, i, 30, 2, "Porcelain");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Glassblowing");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Oil");
		setInputGood(good, method, i, 2, 1, "Tools");
		setInputGood(good, method, i, 2, 1, "Engines");
		method.setProfession(i, -2500, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 30, 0, "Wood");
		setOutputGood(good, method, i, 30, 0, "Tools");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 30, 1, "Wood");
		setInputGood(good, method, i, 20, 1, "Iron");
		setOutputGood(good, method, i, 60, 1, "Tools");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 30, 2, "Wood");
		setInputGood(good, method, i, 20, 2, "Steel");
		setOutputGood(good, method, i, 80, 2, "Tools");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3500, 2, "Laborers");
		method.setProfession(i, 500, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 10, 3, "Rubber");
		setInputGood(good, method, i, 30, 3, "Steel");
		setOutputGood(good, method, i, 110, 3, "Tools");
		method.setProfession(i, 500, 3, "Engineers");
		method.setProfession(i, 3000, 3, "Laborers");
		method.setProfession(i, 1000, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Tooling Workshops");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 1, "Coal");
		method.setProfession(i, -1500, 1, "Laborers");
		setInputGood(good, method, i, 15, 2, "Coal");
		method.setProfession(i, -2000, 2, "Laborers");
		setInputGood(good, method, i, 10, 3, "Oil");
		setInputGood(good, method, i, 5, 3, "Electricity");
		method.setProfession(i, -3000, 3, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 30, 0, "Wood");
		setOutputGood(good, method, i, 40, 0, "Paper");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 30, 1, "Wood");
		setInputGood(good, method, i, 10, 1, "Sulfur");
		setOutputGood(good, method, i, 70, 1, "Paper");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 30, 2, "Wood");
		setInputGood(good, method, i, 10, 2, "Dye");
		setInputGood(good, method, i, 10, 2, "Sulfur");
		setOutputGood(good, method, i, 100, 2, "Paper");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Paper Mills");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Tools");
		setInputGood(good, method, i, 5, 1, "Coal");
		method.setProfession(i, -1500, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Tools");
		setInputGood(good, method, i, 10, 2, "Coal");
		method.setProfession(i, -2000, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Fertilizer Production");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Iron");
		setInputGood(good, method, i, 30, 0, "Sulfur");
		setOutputGood(good, method, i, 90, 0, "Fertilizer");
		method.setProfession(i, 500, 0, "Engineers");
		method.setProfession(i, 3000, 0, "Laborers");
		method.setProfession(i, 1000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 30, 1, "Iron");
		setInputGood(good, method, i, 30, 1, "Sulfur");
		setOutputGood(good, method, i, 140, 1, "Fertilizer");
		method.setProfession(i, 1000, 1, "Engineers");
		method.setProfession(i, 2000, 1, "Laborers");
		method.setProfession(i, 1500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 20, 2, "Oil");
		setInputGood(good, method, i, 30, 2, "Iron");
		setInputGood(good, method, i, 40, 2, "Sulfur");
		setOutputGood(good, method, i, 200, 2, "Fertilizer");
		method.setProfession(i, 1500, 2, "Engineers");
		method.setProfession(i, 1000, 2, "Laborers");
		method.setProfession(i, 2000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Fertilizer Plants");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 20, 0, "Fertilizer");
		setInputGood(good, method, i, 20, 0, "Sulfur");
		setOutputGood(good, method, i, 50, 0, "Explosives");
		method.setProfession(i, 500, 0, "Engineers");
		method.setProfession(i, 3000, 0, "Laborers");
		method.setProfession(i, 1000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 30, 1, "Fertilizer");
		setInputGood(good, method, i, 10, 1, "Paper");
		setInputGood(good, method, i, 30, 1, "Sulfur");
		setOutputGood(good, method, i, 80, 1, "Explosives");
		method.setProfession(i, 1000, 1, "Engineers");
		method.setProfession(i, 2500, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 40, 2, "Fertilizer");
		setInputGood(good, method, i, 20, 2, "Paper");
		setInputGood(good, method, i, 40, 2, "Sulfur");
		setOutputGood(good, method, i, 110, 2, "Explosives");
		method.setProfession(i, 1000, 2, "Engineers");
		method.setProfession(i, 2000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 50, 3, "Fertilizer");
		setInputGood(good, method, i, 30, 3, "Paper");
		setInputGood(good, method, i, 20, 3, "Electricity");
		setInputGood(good, method, i, 40, 3, "Sulfur");
		setOutputGood(good, method, i, 150, 3, "Explosives");
		method.setProfession(i, 1500, 3, "Engineers");
		method.setProfession(i, 1000, 3, "Laborers");
		method.setProfession(i, 1000, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Explosives Factory");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Synthetic Dyes");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 30, 0, "Fertilizer");
		setInputGood(good, method, i, 20, 0, "Sulfur");
		setOutputGood(good, method, i, 80, 0, "Dye");
		method.setProfession(i, 2000, 0, "Engineers");
		method.setProfession(i, 1000, 0, "Laborers");
		method.setProfession(i, 1500, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Synthetics Plants");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Synthetic Silk");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 40, 1, "Wood");
		setOutputGood(good, method, i, -40, 1, "Dye");
		setOutputGood(good, method, i, 40, 1, "Silk");
		method.setProfession(i, 500, 1, "Engineers");
		method.setProfession(i, -1000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Steelmaking Process");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 30, 0, "Coal");
		setInputGood(good, method, i, 40, 0, "Iron");
		setOutputGood(good, method, i, 65, 0, "Steel");
		method.setProfession(i, 250, 0, "Engineers");
		method.setProfession(i, 3500, 0, "Laborers");
		method.setProfession(i, 750, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 30, 1, "Coal");
		setInputGood(good, method, i, 60, 1, "Iron");
		setOutputGood(good, method, i, 90, 1, "Steel");
		method.setProfession(i, 500, 1, "Engineers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 30, 2, "Coal");
		setInputGood(good, method, i, 90, 2, "Iron");
		setOutputGood(good, method, i, 120, 2, "Steel");
		method.setProfession(i, 750, 2, "Engineers");
		method.setProfession(i, 2500, 2, "Laborers");
		method.setProfession(i, 1250, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 30, 3, "Coal");
		setInputGood(good, method, i, 100, 3, "Iron");
		setInputGood(good, method, i, 30, 3, "Electricity");
		setOutputGood(good, method, i, 150, 3, "Steel");
		method.setProfession(i, 1000, 3, "Engineers");
		method.setProfession(i, 2000, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Steel Mills");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Tools");
		setInputGood(good, method, i, 5, 1, "Coal");
		method.setProfession(i, -1500, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Tools");
		setInputGood(good, method, i, 10, 2, "Coal");
		method.setProfession(i, -2000, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 30, 0, "Steel");
		setOutputGood(good, method, i, 40, 0, "Engines");
		method.setProfession(i, 500, 0, "Engineers");
		method.setProfession(i, 2500, 0, "Laborers");
		method.setProfession(i, 1500, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 40, 1, "Steel");
		setInputGood(good, method, i, 30, 1, "Electricity");
		setOutputGood(good, method, i, 80, 1, "Engines");
		method.setProfession(i, 1000, 1, "Engineers");
		method.setProfession(i, 2000, 1, "Laborers");
		method.setProfession(i, 1500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 50, 2, "Oil");
		setInputGood(good, method, i, 50, 2, "Steel");
		setOutputGood(good, method, i, 120, 2, "Engines");
		method.setProfession(i, 1500, 2, "Engineers");
		method.setProfession(i, 1500, 2, "Laborers");
		method.setProfession(i, 1500, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Motor Industries");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automobile Production");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 1, "Rubber");
		setInputGood(good, method, i, 10, 1, "Oil");
		setOutputGood(good, method, i, -20, 1, "Engines");
		setOutputGood(good, method, i, 30, 1, "Automobiles");
		method.setProfession(i, 500, 1, "Engineers");
		method.setProfession(i, 1000, 1, "Machinists");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Tools");
		setInputGood(good, method, i, 5, 1, "Coal");
		method.setProfession(i, -500, 1, "Laborers");
		method.setProfession(i, -500, 1, "Machinists");
		setInputGood(good, method, i, 5, 2, "Tools");
		setInputGood(good, method, i, 10, 2, "Coal");
		method.setProfession(i, -1000, 2, "Laborers");
		method.setProfession(i, -500, 2, "Machinists");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 5, 3, "Tools");
		setInputGood(good, method, i, 5, 3, "Electricity");
		method.setProfession(i, -1500, 3, "Laborers");
		method.setProfession(i, -500, 3, "Machinists");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 20, 0, "Fabric");
		setInputGood(good, method, i, 40, 0, "Wood");
		setOutputGood(good, method, i, 35, 0, "Clippers");
		method.setProfession(i, 250, 0, "Engineers");
		method.setProfession(i, 3500, 0, "Laborers");
		method.setProfession(i, 750, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 20, 1, "Fabric");
		setInputGood(good, method, i, 20, 1, "Wood");
		setInputGood(good, method, i, 5, 1, "Engines");
		setInputGood(good, method, i, 20, 1, "Hardwood");
		setOutputGood(good, method, i, 70, 1, "Clippers");
		method.setProfession(i, 500, 1, "Engineers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Coal");
		setInputGood(good, method, i, 10, 2, "Engines");
		setInputGood(good, method, i, 30, 2, "Steel");
		setOutputGood(good, method, i, 65, 2, "Steamers");
		method.setProfession(i, 1000, 2, "Engineers");
		method.setProfession(i, 2000, 2, "Laborers");
		method.setProfession(i, 1500, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 10, 3, "Engines");
		setInputGood(good, method, i, 30, 3, "Steel");
		setInputGood(good, method, i, 30, 3, "Electricity");
		setOutputGood(good, method, i, 80, 3, "Steamers");
		method.setProfession(i, 1500, 3, "Engineers");
		method.setProfession(i, 1000, 3, "Laborers");
		method.setProfession(i, 2000, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Shipyards");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 20, 0, "Fabric");
		setInputGood(good, method, i, 10, 0, "Iron");
		setInputGood(good, method, i, 20, 0, "Hardwood");
		setOutputGood(good, method, i, 35, 0, "Man-o-Wars");
		method.setProfession(i, 250, 0, "Engineers");
		method.setProfession(i, 3500, 0, "Laborers");
		method.setProfession(i, 750, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Fabric");
		setInputGood(good, method, i, 10, 1, "Iron");
		setInputGood(good, method, i, 5, 1, "Engines");
		setInputGood(good, method, i, 30, 1, "Hardwood");
		setOutputGood(good, method, i, 45, 1, "Man-o-Wars");
		method.setProfession(i, 500, 1, "Engineers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 20, 2, "Coal");
		setInputGood(good, method, i, 10, 2, "Engines");
		setInputGood(good, method, i, 40, 2, "Steel");
		setOutputGood(good, method, i, 55, 2, "Ironclads");
		method.setProfession(i, 1000, 2, "Engineers");
		method.setProfession(i, 2500, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 20, 3, "Engines");
		setInputGood(good, method, i, 40, 3, "Steel");
		setInputGood(good, method, i, 30, 3, "Electricity");
		setOutputGood(good, method, i, 70, 3, "Ironclads");
		method.setProfession(i, 1000, 3, "Engineers");
		method.setProfession(i, 2000, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Military Shipyards");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Aeroplanes");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Engines");
		setInputGood(good, method, i, 20, 0, "Hardwood");
		setInputGood(good, method, i, 20, 0, "Fabric");
		setInputGood(good, method, i, 20, 0, "Oil");
		setOutputGood(good, method, i, 50, 0, "Aeroplanes");
		method.setProfession(i, 1000, 0, "Engineers");
		method.setProfession(i, 1500, 0, "Laborers");
		method.setProfession(i, 2000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("War Machine Industries");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Tanks");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 1, "Oil");
		setInputGood(good, method, i, 10, 1, "Engines");
		setInputGood(good, method, i, 20, 1, "Steel");
		setOutputGood(good, method, i, -10, 1, "Aeroplanes");
		setOutputGood(good, method, i, 40, 1, "Tanks");
		method.setProfession(i, 500, 1, "Engineers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Telephones");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 20, 0, "Rubber");
		setInputGood(good, method, i, 10, 0, "Tools");
		setInputGood(good, method, i, 20, 0, "Iron");
		setInputGood(good, method, i, 20, 0, "Lead");
		setOutputGood(good, method, i, 60, 0, "Telephones");
		method.setProfession(i, 1000, 0, "Engineers");
		method.setProfession(i, 1500, 0, "Laborers");
		method.setProfession(i, 2000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Electrics Industries");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Radios");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 50, 1, "Electricity");
		setOutputGood(good, method, i, -20, 1, "Telephones");
		setOutputGood(good, method, i, 40, 1, "Radios");
		method.setProfession(i, 500, 1, "Engineers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Firearms Manufacturing");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Iron");
		setInputGood(good, method, i, 10, 0, "Hardwood");
		setOutputGood(good, method, i, 30, 0, "Small Arms");
		method.setProfession(i, 4000, 0, "Laborers");
		method.setProfession(i, 500, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 5, 1, "Tools");
		setInputGood(good, method, i, 10, 1, "Steel");
		setInputGood(good, method, i, 10, 1, "Hardwood");
		setOutputGood(good, method, i, 50, 1, "Small Arms");
		method.setProfession(i, 3500, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Tools");
		setInputGood(good, method, i, 20, 2, "Steel");
		setInputGood(good, method, i, 10, 2, "Hardwood");
		setOutputGood(good, method, i, 70, 2, "Small Arms");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 10, 3, "Oil");
		setInputGood(good, method, i, 20, 3, "Tools");
		setInputGood(good, method, i, 20, 3, "Steel");
		setInputGood(good, method, i, 10, 3, "Hardwood");
		setOutputGood(good, method, i, 100, 3, "Small Arms");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2500, 3, "Laborers");
		method.setProfession(i, 1250, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Arms Industries");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 15, 1, "Coal");
		method.setProfession(i, -2000, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Oil");
		setInputGood(good, method, i, 5, 2, "Electricity");
		method.setProfession(i, -2500, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Foundries");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 15, 0, "Iron");
		setInputGood(good, method, i, 10, 0, "Hardwood");
		setOutputGood(good, method, i, 25, 0, "Artillery");
		method.setProfession(i, 3500, 0, "Laborers");
		method.setProfession(i, 1000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 25, 1, "Iron");
		setInputGood(good, method, i, 15, 1, "Hardwood");
		setOutputGood(good, method, i, 45, 1, "Artillery");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3250, 1, "Laborers");
		method.setProfession(i, 1000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Tools");
		setInputGood(good, method, i, 25, 2, "Steel");
		setInputGood(good, method, i, 10, 2, "Hardwood");
		setOutputGood(good, method, i, 65, 2, "Artillery");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 2500, 2, "Laborers");
		method.setProfession(i, 1500, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 10, 3, "Oil");
		setInputGood(good, method, i, 20, 3, "Tools");
		setInputGood(good, method, i, 40, 3, "Steel");
		setOutputGood(good, method, i, 90, 3, "Artillery");
		method.setProfession(i, 1000, 3, "Engineers");
		method.setProfession(i, 2000, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Artillery Foundry");
		building[j].setConstructionCost(600);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 15, 1, "Coal");
		method.setProfession(i, -2000, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Oil");
		setInputGood(good, method, i, 5, 2, "Electricity");
		method.setProfession(i, -2500, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 20, 0, "Explosives");
		setInputGood(good, method, i, 20, 0, "Lead");
		setOutputGood(good, method, i, 50, 0, "Ammunition");
		method.setProfession(i, 500, 0, "Engineers");
		method.setProfession(i, 3000, 0, "Laborers");
		method.setProfession(i, 1000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 40, 1, "Explosives");
		setInputGood(good, method, i, 30, 1, "Lead");
		setOutputGood(good, method, i, 90, 1, "Ammunition");
		method.setProfession(i, 750, 1, "Engineers");
		method.setProfession(i, 2500, 1, "Laborers");
		method.setProfession(i, 1250, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Munition Plants");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(3);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Automation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 15, 1, "Coal");
		method.setProfession(i, -2000, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Oil");
		setInputGood(good, method, i, 5, 2, "Electricity");
		method.setProfession(i, -3000, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Amenities");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 15, 0, "Services");
		method.setProfession(i, 900, 0, "Clerks");
		method.setProfession(i, 3500, 0, "Laborers");
		method.setProfession(i, 400, 0, "Shopkeepers");
		setInputGood(good, method, i, 1, 1, "Wood");
		setInputGood(good, method, i, 1, 1, "Glass");
		setOutputGood(good, method, i, 20, 1, "Services");
		method.setProfession(i, 1400, 1, "Clerks");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 400, 1, "Shopkeepers");
		setInputGood(good, method, i, 2, 2, "Glass");
		setInputGood(good, method, i, 1, 2, "Steel");
		setOutputGood(good, method, i, 25, 2, "Services");
		method.setProfession(i, 1900, 2, "Clerks");
		method.setProfession(i, 2500, 2, "Laborers");
		method.setProfession(i, 400, 2, "Shopkeepers");
		setInputGood(good, method, i, 2, 3, "Glass");
		setInputGood(good, method, i, 2, 3, "Steel");
		setInputGood(good, method, i, 1, 3, "Electricity");
		setOutputGood(good, method, i, 30, 3, "Services");
		method.setProfession(i, 3000, 3, "Clerks");
		method.setProfession(i, 1000, 3, "Laborers");
		method.setProfession(i, 1000, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Urban Center");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Street Lighting");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 1, "Coal");
		setOutputGood(good, method, i, 5, 1, "Services");
		method.setProfession(i, 250, 1, "Laborers");
		setInputGood(good, method, i, 3, 2, "Electricity");
		setOutputGood(good, method, i, 10, 2, "Services");
		method.setProfession(i, 50, 2, "Engineers");
		method.setProfession(i, 200, 2, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Public Transport");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 2, 0, "Transportation");
		setInputGood(good, method, i, 0.5, 1, "Engines");
		setOutputGood(good, method, i, 4, 1, "Transportation");
		method.setProfession(i, 100, 1, "Engineers");
		method.setProfession(i, 200, 1, "Machinists");
		method.setProfession(i, -500, 1, "Laborers");
		setInputGood(good, method, i, 1, 2, "Automobiles");
		setOutputGood(good, method, i, 8, 2, "Transportation");
		method.setProfession(i, 200, 2, "Engineers");
		method.setProfession(i, 400, 2, "Machinists");
		method.setProfession(i, -1000, 2, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Urban Churches");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 200, 0, "Clergymen");
		method.setProfession(i, 150, 1, "Clergymen");
		method.setProfession(i, 100, 1, "Clerks");
		method.setProfession(i, 50, 2, "Bureaucrats");
		method.setProfession(i, 150, 2, "Clerks");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Paper");
		setOutputGood(good, method, i, 4, 0, "Fine Art");
		setInputGood(good, method, i, 15, 1, "Paper");
		setOutputGood(good, method, i, 5, 1, "Fine Art");
		setInputGood(good, method, i, 8, 2, "Tools");
		setInputGood(good, method, i, 15, 2, "Paper");
		setOutputGood(good, method, i, 7, 2, "Fine Art");
		setInputGood(good, method, i, 10, 3, "Tools");
		setInputGood(good, method, i, 15, 3, "Paper");
		setInputGood(good, method, i, 2, 3, "Electricity");
		setOutputGood(good, method, i, 8, 3, "Fine Art");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Arts Academy");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Patronage");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 1000, 0, "Academics");
		method.setProfession(i, 3000, 0, "Clerks");
		method.setProfession(i, 1000, 0, "Laborers");
		method.setProfession(i, 1500, 1, "Academics");
		method.setProfession(i, 2500, 1, "Clerks");
		method.setProfession(i, 1000, 1, "Laborers");
		method.setProfession(i, 2000, 2, "Academics");
		method.setProfession(i, 2000, 2, "Clerks");
		method.setProfession(i, 1000, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Grain");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Fertilizer");
		setOutputGood(good, method, i, 30, 1, "Grain");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3500, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Fertilizer");
		setOutputGood(good, method, i, 45, 2, "Grain");
		method.setProfession(i, 2000, 2, "Farmers");
		method.setProfession(i, 3000, 2, "Laborers");
		setInputGood(good, method, i, 15, 3, "Fertilizer");
		setOutputGood(good, method, i, 70, 3, "Grain");
		method.setProfession(i, 2500, 3, "Farmers");
		method.setProfession(i, 2500, 3, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Rye Farms");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secondary");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 10, 1, "Liquor");
		setOutputGood(good, method, i, -10, 1, "Grain");
		setOutputGood(good, method, i, 5, 2, "Fruit");
		setOutputGood(good, method, i, -10, 2, "Grain");
		setOutputGood(good, method, i, 5, 2, "Sugar");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Harvesting Process");
		method.setSize(i, 5);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 1, "Tools");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 2, 2, "Tools");
		setInputGood(good, method, i, 1, 2, "Coal");
		method.setProfession(i, -1500, 2, "Laborers");
		setInputGood(good, method, i, 2, 3, "Coal");
		setInputGood(good, method, i, 1, 3, "Engines");
		method.setProfession(i, -2000, 3, "Laborers");
		setInputGood(good, method, i, 2, 4, "Oil");
		setInputGood(good, method, i, 1, 4, "Engines");
		method.setProfession(i, -2500, 4, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Grain");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Fertilizer");
		setOutputGood(good, method, i, 30, 1, "Grain");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3500, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Fertilizer");
		setOutputGood(good, method, i, 45, 2, "Grain");
		method.setProfession(i, 2000, 2, "Farmers");
		method.setProfession(i, 3000, 2, "Laborers");
		setInputGood(good, method, i, 15, 3, "Fertilizer");
		setOutputGood(good, method, i, 70, 3, "Grain");
		method.setProfession(i, 2500, 3, "Farmers");
		method.setProfession(i, 2500, 3, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Wheat Farms");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secondary");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 5, 1, "Fruit");
		setOutputGood(good, method, i, -10, 1, "Grain");
		setOutputGood(good, method, i, 5, 1, "Sugar");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Harvesting Process");
		method.setSize(i, 5);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 1, "Tools");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 2, 2, "Tools");
		setInputGood(good, method, i, 1, 2, "Coal");
		method.setProfession(i, -1500, 2, "Laborers");
		setInputGood(good, method, i, 2, 3, "Coal");
		setInputGood(good, method, i, 1, 3, "Engines");
		method.setProfession(i, -2000, 3, "Laborers");
		setInputGood(good, method, i, 2, 4, "Oil");
		setInputGood(good, method, i, 1, 4, "Engines");
		method.setProfession(i, -2500, 4, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 40, 0, "Grain");
		method.setProfession(i, 2000, 0, "Farmers");
		method.setProfession(i, 8000, 0, "Laborers");
		setInputGood(good, method, i, 10, 1, "Fertilizer");
		setOutputGood(good, method, i, 60, 1, "Grain");
		method.setProfession(i, 3000, 1, "Farmers");
		method.setProfession(i, 7000, 1, "Laborers");
		setInputGood(good, method, i, 20, 2, "Fertilizer");
		setOutputGood(good, method, i, 90, 2, "Grain");
		method.setProfession(i, 4000, 2, "Farmers");
		method.setProfession(i, 6000, 2, "Laborers");
		setInputGood(good, method, i, 30, 3, "Fertilizer");
		setOutputGood(good, method, i, 140, 3, "Grain");
		method.setProfession(i, 5000, 3, "Farmers");
		method.setProfession(i, 5000, 3, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Rice Farms");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secondary");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 12, 1, "Fruit");
		setOutputGood(good, method, i, -30, 1, "Grain");
		setOutputGood(good, method, i, 18, 1, "Sugar");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Harvesting Process");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 4, 1, "Tools");
		method.setProfession(i, -2000, 1, "Laborers");
		setInputGood(good, method, i, 4, 2, "Tools");
		setInputGood(good, method, i, 2, 2, "Coal");
		method.setProfession(i, -3000, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Grain");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Fertilizer");
		setOutputGood(good, method, i, 30, 1, "Grain");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3500, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Fertilizer");
		setOutputGood(good, method, i, 45, 2, "Grain");
		method.setProfession(i, 2000, 2, "Farmers");
		method.setProfession(i, 3000, 2, "Laborers");
		setInputGood(good, method, i, 15, 3, "Fertilizer");
		setOutputGood(good, method, i, 70, 3, "Grain");
		method.setProfession(i, 2500, 3, "Farmers");
		method.setProfession(i, 2500, 3, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Maize Farms");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secondary");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 5, 1, "Fruit");
		setOutputGood(good, method, i, -10, 1, "Grain");
		setOutputGood(good, method, i, 5, 1, "Sugar");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Harvesting Process");
		method.setSize(i, 5);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 1, "Tools");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 2, 2, "Tools");
		setInputGood(good, method, i, 1, 2, "Coal");
		method.setProfession(i, -1500, 2, "Laborers");
		setInputGood(good, method, i, 2, 3, "Coal");
		setInputGood(good, method, i, 1, 3, "Engines");
		method.setProfession(i, -2000, 3, "Laborers");
		setInputGood(good, method, i, 2, 4, "Oil");
		setInputGood(good, method, i, 1, 4, "Engines");
		method.setProfession(i, -2500, 4, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Grain");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Fertilizer");
		setOutputGood(good, method, i, 30, 1, "Grain");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3500, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Fertilizer");
		setOutputGood(good, method, i, 45, 2, "Grain");
		method.setProfession(i, 2000, 2, "Farmers");
		method.setProfession(i, 3000, 2, "Laborers");
		setInputGood(good, method, i, 15, 3, "Fertilizer");
		setOutputGood(good, method, i, 70, 3, "Grain");
		method.setProfession(i, 2500, 3, "Farmers");
		method.setProfession(i, 2500, 3, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Millet Farms");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secondary");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 5, 1, "Fruit");
		setOutputGood(good, method, i, -10, 1, "Grain");
		setOutputGood(good, method, i, 5, 1, "Sugar");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Harvesting Process");
		method.setSize(i, 5);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 1, "Tools");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 2, 2, "Tools");
		setInputGood(good, method, i, 1, 2, "Coal");
		method.setProfession(i, -1500, 2, "Laborers");
		setInputGood(good, method, i, 2, 3, "Coal");
		setInputGood(good, method, i, 1, 3, "Engines");
		method.setProfession(i, -2000, 3, "Laborers");
		setInputGood(good, method, i, 2, 4, "Oil");
		setInputGood(good, method, i, 1, 4, "Engines");
		method.setProfession(i, -2500, 4, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 10, 0, "Meat");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Tools");
		setOutputGood(good, method, i, 20, 1, "Meat");
		method.setProfession(i, 1250, 1, "Farmers");
		method.setProfession(i, 3500, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		setInputGood(good, method, i, 10, 2, "Tools");
		setOutputGood(good, method, i, 30, 2, "Meat");
		method.setProfession(i, 1500, 2, "Farmers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 500, 2, "Machinists");
		setInputGood(good, method, i, 10, 3, "Tools");
		setInputGood(good, method, i, 5, 3, "Coal");
		setOutputGood(good, method, i, 45, 3, "Meat");
		method.setProfession(i, 1750, 3, "Farmers");
		method.setProfession(i, 2250, 3, "Laborers");
		method.setProfession(i, 1000, 3, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Livestock Ranches");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Wool Production");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 5, 0, "Fabric");
		setInputGood(good, method, i, 10, 1, "Grain");
		setOutputGood(good, method, i, 15, 1, "Fabric");
		setOutputGood(good, method, i, 2.5, 1, "Fertilizer");
		setInputGood(good, method, i, 20, 2, "Grain");
		setOutputGood(good, method, i, 25, 2, "Fabric");
		setOutputGood(good, method, i, 5, 2, "Fertilizer");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Fencing");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 1, "Iron");
		method.setProfession(i, -800, 1, "Laborers");
		setInputGood(good, method, i, 2, 2, "Iron");
		setInputGood(good, method, i, 2, 2, "Electricity");
		method.setProfession(i, -1400, 2, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Refrigeration");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 3, 1, "Electricity");
		method.setProfession(i, -800, 1, "Laborers");
		setInputGood(good, method, i, 2, 2, "Transportation");
		setInputGood(good, method, i, 3, 2, "Electricity");
		method.setProfession(i, -1400, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Mining Equipment");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 0, "Tools");
		setOutputGood(good, method, i, 25, 0, "Coal");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Tools");
		setOutputGood(good, method, i, 40, 1, "Coal");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3750, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 15, 2, "Tools");
		setOutputGood(good, method, i, 60, 2, "Coal");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 15, 3, "Tools");
		setOutputGood(good, method, i, 90, 3, "Coal");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2250, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Coal Mines");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Explosives");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Explosives");
		setOutputGood(good, method, i, 15, 1, "Coal");
		method.setProfession(i, 250, 1, "Engineers");
		setInputGood(good, method, i, 10, 2, "Explosives");
		setOutputGood(good, method, i, 25, 2, "Coal");
		method.setProfession(i, 250, 2, "Engineers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Steam Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 1, 1, "Engines");
		setOutputGood(good, method, i, -3, 1, "Coal");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Mining Equipment");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 0, "Tools");
		setOutputGood(good, method, i, 20, 0, "Iron");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Tools");
		setInputGood(good, method, i, 10, 1, "Coal");
		setOutputGood(good, method, i, 40, 1, "Iron");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3750, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 15, 2, "Tools");
		setInputGood(good, method, i, 15, 2, "Coal");
		setOutputGood(good, method, i, 60, 2, "Iron");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 15, 3, "Tools");
		setOutputGood(good, method, i, 70, 3, "Iron");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2250, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Iron Mines");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Explosives");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Explosives");
		setOutputGood(good, method, i, 12, 1, "Iron");
		method.setProfession(i, 250, 1, "Engineers");
		setInputGood(good, method, i, 10, 2, "Explosives");
		setOutputGood(good, method, i, 20, 2, "Iron");
		method.setProfession(i, 250, 2, "Engineers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Steam Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 4, 1, "Coal");
		setInputGood(good, method, i, 1, 1, "Engines");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Mining Equipment");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 0, "Tools");
		setOutputGood(good, method, i, 20, 0, "Lead");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Tools");
		setInputGood(good, method, i, 10, 1, "Coal");
		setOutputGood(good, method, i, 40, 1, "Lead");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3750, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 15, 2, "Tools");
		setInputGood(good, method, i, 15, 2, "Coal");
		setOutputGood(good, method, i, 60, 2, "Lead");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 15, 3, "Tools");
		setOutputGood(good, method, i, 70, 3, "Lead");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2250, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Lead Mines");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Explosives");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Explosives");
		setOutputGood(good, method, i, 12, 1, "Lead");
		method.setProfession(i, 250, 1, "Engineers");
		setInputGood(good, method, i, 10, 2, "Explosives");
		setOutputGood(good, method, i, 20, 2, "Lead");
		method.setProfession(i, 250, 2, "Engineers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Steam Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 4, 1, "Coal");
		setInputGood(good, method, i, 1, 1, "Engines");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Mining Equipment");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 0, "Tools");
		setOutputGood(good, method, i, 20, 0, "Sulfur");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Tools");
		setInputGood(good, method, i, 10, 1, "Coal");
		setOutputGood(good, method, i, 40, 1, "Sulfur");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3750, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 15, 2, "Tools");
		setInputGood(good, method, i, 15, 2, "Coal");
		setOutputGood(good, method, i, 60, 2, "Sulfur");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 15, 3, "Tools");
		setOutputGood(good, method, i, 80, 3, "Sulfur");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2250, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Sulfur Mines");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Explosives");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Explosives");
		setOutputGood(good, method, i, 10, 1, "Sulfur");
		method.setProfession(i, 250, 1, "Engineers");
		setInputGood(good, method, i, 10, 2, "Explosives");
		setOutputGood(good, method, i, 20, 2, "Sulfur");
		method.setProfession(i, 250, 2, "Engineers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Steam Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 4, 1, "Coal");
		setInputGood(good, method, i, 1, 1, "Engines");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Mining Equipment");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 0, "Tools");
		setOutputGood(good, method, i, 8, 0, "Gold");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Tools");
		setInputGood(good, method, i, 10, 1, "Coal");
		setOutputGood(good, method, i, 15, 1, "Gold");
		method.setProfession(i, 250, 1, "Engineers");
		method.setProfession(i, 3750, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 15, 2, "Tools");
		setInputGood(good, method, i, 15, 2, "Coal");
		setOutputGood(good, method, i, 25, 2, "Gold");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 15, 3, "Tools");
		setOutputGood(good, method, i, 30, 3, "Gold");
		method.setProfession(i, 750, 3, "Engineers");
		method.setProfession(i, 2250, 3, "Laborers");
		method.setProfession(i, 1500, 3, "Machinists");
		method.setProfession(i, 500, 3, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Gold Mines");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Explosives");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Explosives");
		setOutputGood(good, method, i, 5, 1, "Gold");
		method.setProfession(i, 250, 1, "Engineers");
		setInputGood(good, method, i, 10, 2, "Explosives");
		setOutputGood(good, method, i, 5, 2, "Gold");
		method.setProfession(i, 250, 2, "Engineers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Steam Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 4, 1, "Coal");
		setInputGood(good, method, i, 1, 1, "Engines");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 10, 0, "Gold");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Gold Fields");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Coffee");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 40, 1, "Coffee");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Coffee Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 40, 0, "Fabric");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 100, 1, "Fabric");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Cotton Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 25, 0, "Dye");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 50, 1, "Dye");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Dye Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Opium");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 50, 1, "Opium");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Opium Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Tea");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 40, 1, "Tea");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Tea Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 25, 0, "Tobacco");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 50, 1, "Tobacco");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Tobacco Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 30, 0, "Sugar");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 60, 1, "Sugar");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Sugar Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 30, 0, "Fruit");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 60, 1, "Fruit");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Banana Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Silk");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 40, 1, "Silk");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Silk Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 20, 0, "Wine");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 40, 1, "Wine");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Vineyard");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 30, 0, "Wood");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 5, 1, "Tools");
		setOutputGood(good, method, i, 60, 1, "Wood");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 10, 2, "Tools");
		setInputGood(good, method, i, 5, 2, "Electricity");
		setOutputGood(good, method, i, 100, 2, "Wood");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Logging Camps");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Hardwood Production");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, -25, 1, "Wood");
		setOutputGood(good, method, i, 10, 1, "Hardwood");
		setOutputGood(good, method, i, -40, 2, "Wood");
		setOutputGood(good, method, i, 20, 2, "Hardwood");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Special Equipment");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 4, 1, "Coal");
		setInputGood(good, method, i, 1, 1, "Engines");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 4, 2, "Oil");
		setInputGood(good, method, i, 1, 2, "Engines");
		method.setProfession(i, 250, 2, "Engineers");
		method.setProfession(i, -1500, 2, "Laborers");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Transportation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 8, 2, "Transportation");
		method.setProfession(i, -1500, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 30, 0, "Rubber");
		method.setProfession(i, 1000, 0, "Farmers");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 60, 1, "Rubber");
		method.setProfession(i, 1500, 1, "Farmers");
		method.setProfession(i, 3000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Rubber Plantations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Train Automation");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 25, 0, "Fish");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 5, 1, "Clippers");
		setOutputGood(good, method, i, 50, 1, "Fish");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 15, 2, "Coal");
		setInputGood(good, method, i, 5, 2, "Steamers");
		setOutputGood(good, method, i, 100, 2, "Fish");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Fishing Wharves");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Refrigeration");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Electricity");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Transportation");
		setInputGood(good, method, i, 5, 2, "Electricity");
		method.setProfession(i, -2000, 2, "Laborers");
		setInputGood(good, method, i, 7, 3, "Transportation");
		setInputGood(good, method, i, 7, 3, "Electricity");
		method.setProfession(i, -3000, 3, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 10, 0, "Oil");
		setOutputGood(good, method, i, 5, 0, "Meat");
		method.setProfession(i, 4500, 0, "Laborers");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 5, 1, "Clippers");
		setOutputGood(good, method, i, 20, 1, "Oil");
		setOutputGood(good, method, i, 10, 1, "Meat");
		method.setProfession(i, 4000, 1, "Laborers");
		method.setProfession(i, 500, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
		setInputGood(good, method, i, 20, 2, "Coal");
		setInputGood(good, method, i, 5, 2, "Steamers");
		setOutputGood(good, method, i, 40, 2, "Oil");
		setOutputGood(good, method, i, 20, 2, "Meat");
		method.setProfession(i, 500, 2, "Engineers");
		method.setProfession(i, 3000, 2, "Laborers");
		method.setProfession(i, 1000, 2, "Machinists");
		method.setProfession(i, 500, 2, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Whaling Stations");
		building[j].setConstructionCost(200);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Refrigeration");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Electricity");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Transportation");
		setInputGood(good, method, i, 5, 2, "Electricity");
		method.setProfession(i, -2000, 2, "Laborers");
		setInputGood(good, method, i, 7, 3, "Transportation");
		setInputGood(good, method, i, 7, 3, "Electricity");
		method.setProfession(i, -3000, 3, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Coal");
		setInputGood(good, method, i, 5, 0, "Engines");
		setOutputGood(good, method, i, 60, 0, "Oil");
		method.setProfession(i, 500, 0, "Engineers");
		method.setProfession(i, 3000, 0, "Laborers");
		method.setProfession(i, 1000, 0, "Machinists");
		method.setProfession(i, 500, 0, "Shopkeepers");
		setInputGood(good, method, i, 10, 1, "Engines");
		setOutputGood(good, method, i, 100, 1, "Oil");
		method.setProfession(i, 900, 1, "Engineers");
		method.setProfession(i, 2000, 1, "Laborers");
		method.setProfession(i, 2000, 1, "Machinists");
		method.setProfession(i, 500, 1, "Shopkeepers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Oil Rigs");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Transportation");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 1, "Transportation");
		method.setProfession(i, -1000, 1, "Laborers");
		setInputGood(good, method, i, 10, 2, "Transportation");
		method.setProfession(i, -2000, 2, "Laborers");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.5, 0, "Fabric");
		setOutputGood(good, method, i, 0.5, 0, "Wood");
		setOutputGood(good, method, i, 1, 0, "Grain");
		setOutputGood(good, method, i, 0.5, 0, "Services");
		method.setProfession(i, 5000, 0, "Peasants");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Subsistence Farms");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Home Workshops");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.25, 0, "Fabric");
		setOutputGood(good, method, i, 0.25, 0, "Wood");
		setOutputGood(good, method, i, 0.5, 0, "Grain");
		setOutputGood(good, method, i, 0.25, 1, "Liquor");
		setOutputGood(good, method, i, 0.25, 1, "Clothes");
		setOutputGood(good, method, i, 0.25, 1, "Furniture");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Serfdom");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.5, 1, "Grain");
		setOutputGood(good, method, i, 0.25, 2, "Grain");
		method.setProfession(i, 100, 2, "Farmers");
		method.setProfession(i, -100, 2, "Peasants");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.5, 0, "Fabric");
		setOutputGood(good, method, i, 0.5, 0, "Wood");
		setOutputGood(good, method, i, 0.25, 0, "Grain");
		setOutputGood(good, method, i, 0.5, 0, "Fruit");
		setOutputGood(good, method, i, 0.5, 0, "Services");
		method.setProfession(i, 5000, 0, "Peasants");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Subsistence Orchards");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Home Workshops");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.25, 0, "Fabric");
		setOutputGood(good, method, i, 0.25, 0, "Wood");
		setOutputGood(good, method, i, 0.33, 0, "Fruit");
		setOutputGood(good, method, i, 0.25, 1, "Liquor");
		setOutputGood(good, method, i, 0.25, 1, "Clothes");
		setOutputGood(good, method, i, 0.25, 1, "Furniture");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Serfdom");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.33, 1, "Fruit");
		setOutputGood(good, method, i, 0.25, 2, "Grain");
		method.setProfession(i, 100, 2, "Farmers");
		method.setProfession(i, -100, 2, "Peasants");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.75, 0, "Fabric");
		setOutputGood(good, method, i, 0.25, 0, "Wood");
		setOutputGood(good, method, i, 0.25, 0, "Grain");
		setOutputGood(good, method, i, 0.5, 0, "Meat");
		setOutputGood(good, method, i, 0.5, 0, "Services");
		method.setProfession(i, 5000, 0, "Peasants");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Subsistence Pastures");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Home Workshops");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.5, 0, "Fabric");
		setOutputGood(good, method, i, 0.33, 0, "Meat");
		setOutputGood(good, method, i, 0.25, 1, "Liquor");
		setOutputGood(good, method, i, 0.25, 1, "Clothes");
		setOutputGood(good, method, i, 0.25, 1, "Furniture");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Serfdom");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.33, 1, "Meat");
		setOutputGood(good, method, i, 0.25, 2, "Grain");
		method.setProfession(i, 100, 2, "Farmers");
		method.setProfession(i, -100, 2, "Peasants");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.25, 0, "Fabric");
		setOutputGood(good, method, i, 0.25, 0, "Wood");
		setOutputGood(good, method, i, 0.5, 0, "Grain");
		setOutputGood(good, method, i, 1, 0, "Fish");
		setOutputGood(good, method, i, 0.5, 0, "Services");
		method.setProfession(i, 5000, 0, "Peasants");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Subsistence Fishing Villages");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Home Workshops");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.25, 0, "Fabric");
		setOutputGood(good, method, i, 0.25, 0, "Wood");
		setOutputGood(good, method, i, 0.5, 0, "Fish");
		setOutputGood(good, method, i, 0.25, 1, "Liquor");
		setOutputGood(good, method, i, 0.25, 1, "Clothes");
		setOutputGood(good, method, i, 0.25, 1, "Furniture");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Serfdom");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.5, 1, "Fish");
		setOutputGood(good, method, i, 0.25, 2, "Grain");
		method.setProfession(i, 100, 2, "Farmers");
		method.setProfession(i, -100, 2, "Peasants");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.75, 0, "Fabric");
		setOutputGood(good, method, i, 0.75, 0, "Wood");
		setOutputGood(good, method, i, 2, 0, "Grain");
		setOutputGood(good, method, i, 1, 0, "Services");
		method.setProfession(i, 10000, 0, "Peasants");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Subsistence Rice Paddies");
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Home Workshops");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 0.5, 0, "Fabric");
		setOutputGood(good, method, i, 0.5, 0, "Wood");
		setOutputGood(good, method, i, 1, 0, "Grain");
		setOutputGood(good, method, i, 0.5, 1, "Liquor");
		setOutputGood(good, method, i, 0.5, 1, "Clothes");
		setOutputGood(good, method, i, 0.5, 1, "Furniture");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Serfdom");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setOutputGood(good, method, i, 1, 1, "Grain");
		setOutputGood(good, method, i, 0.25, 2, "Grain");
		method.setProfession(i, 100, 2, "Farmers");
		method.setProfession(i, -100, 2, "Peasants");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Training");
		method.setSize(i, 6);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 30, 0, "Officers");
		method.setProfession(i, 970, 0, "Servicemen");
		method.setProfession(i, 50, 1, "Officers");
		method.setProfession(i, 950, 1, "Servicemen");
		method.setProfession(i, 100, 2, "Officers");
		method.setProfession(i, 900, 2, "Servicemen");
		method.setProfession(i, 150, 3, "Officers");
		method.setProfession(i, 850, 3, "Servicemen");
		method.setProfession(i, 200, 4, "Officers");
		method.setProfession(i, 800, 4, "Servicemen");
		method.setProfession(i, 250, 5, "Officers");
		method.setProfession(i, 750, 5, "Servicemen");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Barracks");
		building[j].setConstructionCost(100);
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Military Unit Type");
		method.setSize(i, 16);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setMilitaryConsumption(i, 0, l, n);
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setMilitaryConsumption(i, 0, l, n);
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setMilitaryConsumption(i, 0, l, n);
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setMilitaryConsumption(good, method, i, 1, 1, "Small Arms");
		setMilitaryConsumption(good, method, i, 1, 2, "Ammunition");
		setMilitaryConsumption(good, method, i, 2, 2, "Small Arms");
		setMilitaryConsumption(good, method, i, 2, 3, "Ammunition");
		setMilitaryConsumption(good, method, i, 3, 3, "Small Arms");
		setMilitaryConsumption(good, method, i, 3, 4, "Ammunition");
		setMilitaryConsumption(good, method, i, 3, 4, "Small Arms");
		setMilitaryConsumption(good, method, i, 1, 4, "Radios");
		setMilitaryConsumption(good, method, i, 1, 5, "Oil");
		setMilitaryConsumption(good, method, i, 3, 5, "Ammunition");
		setMilitaryConsumption(good, method, i, 3, 5, "Small Arms");
		setMilitaryConsumption(good, method, i, 1, 5, "Tanks");
		setMilitaryConsumption(good, method, i, 1, 5, "Radios");
		setMilitaryConsumption(good, method, i, 1, 6, "Artillery");
		setMilitaryConsumption(good, method, i, 2, 7, "Artillery");
		setMilitaryConsumption(good, method, i, 3, 8, "Ammunition");
		setMilitaryConsumption(good, method, i, 3, 8, "Artillery");
		setMilitaryConsumption(good, method, i, 4, 9, "Ammunition");
		setMilitaryConsumption(good, method, i, 4, 9, "Artillery");
		setMilitaryConsumption(good, method, i, 1, 9, "Radios");
		setMilitaryConsumption(good, method, i, 3, 10, "Oil");
		setMilitaryConsumption(good, method, i, 4, 10, "Ammunition");
		setMilitaryConsumption(good, method, i, 4, 10, "Artillery");
		setMilitaryConsumption(good, method, i, 3, 10, "Tanks");
		setMilitaryConsumption(good, method, i, 1, 10, "Radios");
		setMilitaryConsumption(good, method, i, 1, 11, "Grain");
		setMilitaryConsumption(good, method, i, 1, 12, "Grain");
		setMilitaryConsumption(good, method, i, 2, 12, "Small Arms");
		setMilitaryConsumption(good, method, i, 1, 13, "Grain");
		setMilitaryConsumption(good, method, i, 2, 13, "Small Arms");
		setMilitaryConsumption(good, method, i, 2, 14, "Iron");
		setMilitaryConsumption(good, method, i, 2, 14, "Grain");
		setMilitaryConsumption(good, method, i, 2, 14, "Small Arms");
		setMilitaryConsumption(good, method, i, 2, 15, "Oil");
		setMilitaryConsumption(good, method, i, 2, 15, "Ammunition");
		setMilitaryConsumption(good, method, i, 2, 15, "Artillery");
		setMilitaryConsumption(good, method, i, 2, 15, "Tanks");
		setMilitaryConsumption(good, method, i, 2, 15, "Radios");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Naval Theory");
		method.setSize(i, 5);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 100, 0, "Officers");
		method.setProfession(i, 900, 0, "Servicemen");
		method.setProfession(i, 125, 1, "Officers");
		method.setProfession(i, 875, 1, "Servicemen");
		method.setProfession(i, 150, 2, "Officers");
		method.setProfession(i, 850, 2, "Servicemen");
		method.setProfession(i, 175, 3, "Officers");
		method.setProfession(i, 825, 3, "Servicemen");
		method.setProfession(i, 200, 4, "Officers");
		method.setProfession(i, 800, 4, "Servicemen");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Naval Base");
		building[j].setConstructionCost(100);
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Military Unit Type");
		method.setSize(i, 11);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setMilitaryConsumption(i, 0, l, n);
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setMilitaryConsumption(i, 0, l, n);
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setMilitaryConsumption(i, 0, l, n);
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setMilitaryConsumption(good, method, i, 1, 0, "Man-o-Wars");
		setMilitaryConsumption(good, method, i, 1, 1, "Ammunition");
		setMilitaryConsumption(good, method, i, 1, 1, "Artillery");
		setMilitaryConsumption(good, method, i, 1, 1, "Ironclads");
		setMilitaryConsumption(good, method, i, 2, 2, "Ammunition");
		setMilitaryConsumption(good, method, i, 2, 2, "Artillery");
		setMilitaryConsumption(good, method, i, 2, 2, "Ironclads");
		setMilitaryConsumption(good, method, i, 2, 3, "Ironclads");
		setMilitaryConsumption(good, method, i, 4, 3, "Explosives");
		setMilitaryConsumption(good, method, i, 3, 4, "Ammunition");
		setMilitaryConsumption(good, method, i, 3, 4, "Artillery");
		setMilitaryConsumption(good, method, i, 3, 4, "Ironclads");
		setMilitaryConsumption(good, method, i, 1, 4, "Radios");
		setMilitaryConsumption(good, method, i, 3, 5, "Man-o-Wars");
		setMilitaryConsumption(good, method, i, 3, 6, "Ammunition");
		setMilitaryConsumption(good, method, i, 3, 6, "Artillery");
		setMilitaryConsumption(good, method, i, 3, 6, "Ironclads");
		setMilitaryConsumption(good, method, i, 6, 7, "Ammunition");
		setMilitaryConsumption(good, method, i, 6, 7, "Artillery");
		setMilitaryConsumption(good, method, i, 6, 7, "Ironclads");
		setMilitaryConsumption(good, method, i, 2, 7, "Radios");
		setMilitaryConsumption(good, method, i, 8, 8, "Ammunition");
		setMilitaryConsumption(good, method, i, 8, 8, "Artillery");
		setMilitaryConsumption(good, method, i, 8, 8, "Ironclads");
		setMilitaryConsumption(good, method, i, 3, 8, "Radios");
		setMilitaryConsumption(good, method, i, 2, 9, "Ammunition");
		setMilitaryConsumption(good, method, i, 2, 9, "Artillery");
		setMilitaryConsumption(good, method, i, 2, 9, "Ironclads");
		setMilitaryConsumption(good, method, i, 1, 9, "Radios");
		setMilitaryConsumption(good, method, i, 8, 10, "Ammunition");
		setMilitaryConsumption(good, method, i, 8, 10, "Ironclads");
		setMilitaryConsumption(good, method, i, 8, 10, "Aeroplanes");
		setMilitaryConsumption(good, method, i, 4, 10, "Radios");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 150, 0, "Bureaucrats");
		method.setProfession(i, 350, 0, "Clerks");
		method.setProfession(i, 500, 0, "Laborers");
		setInputGood(good, method, i, 5, 1, "Clippers");
		method.setProfession(i, 500, 1, "Bureaucrats");
		method.setProfession(i, 1500, 1, "Clerks");
		method.setProfession(i, 3000, 1, "Laborers");
		setInputGood(good, method, i, 5, 2, "Coal");
		setInputGood(good, method, i, 5, 2, "Steamers");
		method.setProfession(i, 500, 2, "Bureaucrats");
		method.setProfession(i, 1000, 2, "Clerks");
		method.setProfession(i, 2000, 2, "Laborers");
		method.setProfession(i, 500, 2, "Machinists");
		setInputGood(good, method, i, 5, 3, "Oil");
		setInputGood(good, method, i, 5, 3, "Steamers");
		method.setProfession(i, 500, 3, "Bureaucrats");
		method.setProfession(i, 500, 3, "Clerks");
		method.setProfession(i, 750, 3, "Laborers");
		method.setProfession(i, 250, 3, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Port");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 4000, 0, "Clerks");
		setInputGood(good, method, i, 10, 1, "Paper");
		method.setProfession(i, 4000, 1, "Clerks");
		setInputGood(good, method, i, 20, 2, "Paper");
		method.setProfession(i, 4000, 2, "Clerks");
		setInputGood(good, method, i, 5, 3, "Telephones");
		setInputGood(good, method, i, 20, 3, "Paper");
		method.setProfession(i, 2500, 3, "Bureaucrats");
		method.setProfession(i, 2500, 3, "Clerks");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Government Administration");
		building[j].setConstructionCost(100);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Professionalism");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 250, 0, "Aristocrats");
		method.setProfession(i, 250, 0, "Bureaucrats");
		method.setProfession(i, 500, 1, "Bureaucrats");
	}
	else {
		size *= method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secularism");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 250, 0, "Bureaucrats");
		method.setProfession(i, 250, 0, "Clergymen");
		method.setProfession(i, 500, 1, "Bureaucrats");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 5, 0, "Paper");
		method.setProfession(i, 1500, 0, "Clerks");
		method.setProfession(i, 1500, 0, "Laborers");
		setInputGood(good, method, i, 10, 1, "Paper");
		method.setProfession(i, 1750, 1, "Clerks");
		method.setProfession(i, 1250, 1, "Laborers");
		setInputGood(good, method, i, 15, 2, "Paper");
		method.setProfession(i, 2000, 2, "Clerks");
		method.setProfession(i, 1000, 2, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("University");
		building[j].setConstructionCost(400);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Secularism");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		method.setProfession(i, 1000, 0, "Academics");
		method.setProfession(i, 1000, 0, "Clergymen");
		method.setProfession(i, 2000, 1, "Academics");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 2, 0, "Coal");
		setInputGood(good, method, i, 5, 0, "Engines");
		setOutputGood(good, method, i, 20, 0, "Transportation");
		method.setProfession(i, 750, 0, "Clerks");
		method.setProfession(i, 3000, 0, "Laborers");
		method.setProfession(i, 1000, 0, "Machinists");
		setInputGood(good, method, i, 5, 1, "Coal");
		setInputGood(good, method, i, 5, 1, "Engines");
		setOutputGood(good, method, i, 25, 1, "Transportation");
		method.setProfession(i, 750, 1, "Clerks");
		method.setProfession(i, 2500, 1, "Laborers");
		method.setProfession(i, 1500, 1, "Machinists");
		setInputGood(good, method, i, 5, 2, "Engines");
		setInputGood(good, method, i, 10, 2, "Electricity");
		setOutputGood(good, method, i, 35, 2, "Transportation");
		method.setProfession(i, 750, 2, "Clerks");
		method.setProfession(i, 2000, 2, "Laborers");
		method.setProfession(i, 2000, 2, "Machinists");
		setInputGood(good, method, i, 8, 3, "Oil");
		setInputGood(good, method, i, 5, 3, "Engines");
		setOutputGood(good, method, i, 40, 3, "Transportation");
		method.setProfession(i, 750, 3, "Clerks");
		method.setProfession(i, 1500, 3, "Laborers");
		method.setProfession(i, 2500, 3, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Railway");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		size = method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Passenger Trains");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 8, 1, "Wood");
		setOutputGood(good, method, i, 10, 1, "Transportation");
		method.setProfession(i, 250, 1, "Clerks");
		setInputGood(good, method, i, 5, 2, "Steel");
		setOutputGood(good, method, i, 15, 2, "Transportation");
		method.setProfession(i, 500, 2, "Clerks");
	}
	else {
		k += size * method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 3);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Engines");
		setOutputGood(good, method, i, 50, 0, "Electricity");
		method.setProfession(i, 1200, 0, "Engineers");
		method.setProfession(i, 2500, 0, "Laborers");
		method.setProfession(i, 1800, 0, "Machinists");
		setInputGood(good, method, i, 30, 1, "Coal");
		setInputGood(good, method, i, 15, 1, "Engines");
		setOutputGood(good, method, i, 100, 1, "Electricity");
		method.setProfession(i, 1400, 1, "Engineers");
		method.setProfession(i, 2000, 1, "Laborers");
		method.setProfession(i, 1500, 1, "Machinists");
		setInputGood(good, method, i, 40, 2, "Oil");
		setInputGood(good, method, i, 20, 2, "Engines");
		setOutputGood(good, method, i, 150, 2, "Electricity");
		method.setProfession(i, 1400, 2, "Engineers");
		method.setProfession(i, 2000, 2, "Laborers");
		method.setProfession(i, 1500, 2, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Power Plants");
		building[j].setConstructionCost(800);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 2);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 25, 0, "Paper");
		method.setProfession(i, 1500, 0, "Bureaucrats");
		method.setProfession(i, 2500, 0, "Clerks");
		method.setProfession(i, 1000, 0, "Laborers");
		setInputGood(good, method, i, 25, 1, "Paper");
		method.setProfession(i, 1500, 1, "Bureaucrats");
		method.setProfession(i, 2500, 1, "Clerks");
		method.setProfession(i, 1000, 1, "Laborers");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Skyscraper");
		building[j].setConstructionCost(2500);
		building[j].setInfrastructureUsage(1);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 1);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 10, 0, "Tools");
		setInputGood(good, method, i, 15, 0, "Coal");
		method.setProfession(i, 500, 0, "Capitalists");
		method.setProfession(i, 2000, 0, "Clerks");
		method.setProfession(i, 2500, 0, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Canals");
		building[j].setConstructionCost(5000);
		building[j].setInfrastructureUsage(0);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i);
	}
	i++;
	if (setMethods) {
		method.setProductionMethod(i, "Base");
		method.setSize(i, 4);
		for (int l = 0; l < method.getSize(i); l++) {
			int n = 0;
			if (GSIZE > PSIZE) {
				for (;n < PSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
				}
			}
			else {
				for (;n < GSIZE; n++) {
					method.setInputGood(i, 0, l, n);
					method.setOutputGood(i, 0, l, n);
					method.setProfession(i, 0, l, n);
				}
				for (;n < PSIZE; n++)
					method.setProfession(i, 0, l, n);
			}
		}
		setInputGood(good, method, i, 25, 0, "Fabric");
		setInputGood(good, method, i, 75, 0, "Wood");
		method.setProfession(i, 500, 0, "Bureaucrats");
		method.setProfession(i, 500, 0, "Clerks");
		method.setProfession(i, 4000, 0, "Laborers");
		setInputGood(good, method, i, 10, 1, "Tools");
		setInputGood(good, method, i, 20, 1, "Fabric");
		setInputGood(good, method, i, 40, 1, "Wood");
		setInputGood(good, method, i, 50, 1, "Iron");
		method.setProfession(i, 500, 1, "Bureaucrats");
		method.setProfession(i, 500, 1, "Clerks");
		method.setProfession(i, 3750, 1, "Laborers");
		method.setProfession(i, 250, 1, "Machinists");
		setInputGood(good, method, i, 20, 2, "Tools");
		setInputGood(good, method, i, 40, 2, "Glass");
		setInputGood(good, method, i, 50, 2, "Steel");
		setInputGood(good, method, i, 10, 2, "Explosives");
		method.setProfession(i, 500, 2, "Bureaucrats");
		method.setProfession(i, 500, 2, "Clerks");
		method.setProfession(i, 3250, 2, "Laborers");
		method.setProfession(i, 750, 2, "Machinists");
		setInputGood(good, method, i, 40, 3, "Glass");
		setInputGood(good, method, i, 20, 3, "Explosives");
		setInputGood(good, method, i, 40, 3, "Electricity");
		setInputGood(good, method, i, 40, 3, "Tools");
		setInputGood(good, method, i, 50, 3, "Steel");
		method.setProfession(i, 500, 3, "Bureaucrats");
		method.setProfession(i, 500, 3, "Clerks");
		method.setProfession(i, 250, 3, "Engineers");
		method.setProfession(i, 3000, 3, "Laborers");
		method.setProfession(i, 750, 3, "Machinists");
	}
	else {
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuilding("Construction Sector");
		building[j].setConstructionCost(100);
		building[j].setInfrastructureUsage(2);
		building[j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		k += method.getSize(i++);
		building[j].setSize(i - building[j].getProductionMethod());
		building[++j].setBuildingLocation(k);
		building[j].setProductionMethod(i);
		if (testing) {
			cout << "BSIZE: " << j + 1 << endl
				 << "SSIZE: " << k << endl;
		}
		i = 0;
		profession[i++] = "Peasants";
		profession[i++] = "Laborers";
		profession[i++] = "Servicemen";
		profession[i++] = "Machinists";
		profession[i++] = "Clerks";
		profession[i++] = "Farmers";
		profession[i++] = "Shopkeepers";
		profession[i++] = "Clergymen";
		profession[i++] = "Engineers";
		profession[i++] = "Bureaucrats";
		profession[i++] = "Academics";
		profession[i++] = "Officers";
		profession[i++] = "Aristocrats";
		profession[i] = "Capitalists";
		if (testing) {
			cout << "PSIZE: " << i + 1 << endl << endl;
			system("pause");
		}
	}
}

void setMilitaryConsumption(goodsType good[GSIZE], productionMethodsType& method, int it, float consumption, int i, string name)
{
	int j = 0;

	for (;j < GSIZE && name != good[j].getGood(); j++);
	if (j < GSIZE)
		method.setMilitaryConsumption(it, consumption, i, j);
}

void setInputGood(goodsType good[GSIZE], productionMethodsType& method, int it, float input, int i, string name)
{
	int j = 0;

	for (;j < GSIZE && name != good[j].getGood(); j++);
	if (j < GSIZE)
		method.setInputGood(it, input, i, j);
}

void setOutputGood(goodsType good[GSIZE], productionMethodsType& method, int it, float output, int i, string name)
{
	int j = 0;

	for (;j < GSIZE && name != good[j].getGood(); j++);
	if (j < GSIZE)
		method.setOutputGood(it, output, i, j);
}

float trunc1D(float num)
{
	return trunc(num * 10) / 10;
}

float trunc2D(float num)
{
	return trunc(num * 100) / 100;
}

void menu(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float& inf, float& mapi, float& gdp, int& states, float& eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	bool predict = false;
	string in;
	char choice;
	bool exit = false;

	do {
		char answer = '\0';
		system("cls");

		cout << "Vicky3 Economy Calculator\n"
			 << "Predict Pop Consumption Changes: ";
		if (predict)
			cout << "yes";
		else {
			cout << "no";
		}
		cout << endl << endl
			 << "1. Toggle Pop Consumption Calculations\n"
			 << "2. Infamy Menu\n"
			 << "3. National Menu\n"
			 << "4. State Menu\n"
			 << "5. Buildings Menu\n"
			 << "6. Reset Buildings Data\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				if (predict)
					predict = false;
				else {
					predict = true;
				}
				break;
			case '2':
				infamyMenu(inf);
				break;
			case '3':
				for (int i = 0; i < GSIZE; i++) {
					good[i].setMilitaryConsumption();
					good[i].setInput(0);
					good[i].setOutput(0);

					for (int j = 0; j < BSIZE - 1; j++) {
						for (int k = building[j].getBuildingLocation(); k < building[j + 1].getBuildingLocation(); k++) {
							if (location[k].getSubsidized() > 0) {
								for (int l = 0; l < building[j].getSize(); l++) {
									good[i].setMilitaryConsumption(location[k].getSubsidized() * method.getMilitaryConsumption(good[i], building[j].getBuilding(), mobilization, l + building[j].getProductionMethod(), location[k].getProductionMethodLevel(l), i, 0) * (location[k].getBuildingThroughput() + 1));
									good[i].setInput(location[k].getSubsidized() * method.getInputGood(good[i], building[j].getBuilding(), mobilization, l + building[j].getProductionMethod(), location[k].getProductionMethodLevel(l), i, 0) * (location[k].getBuildingThroughput() + 1), 0);
								}
								good[i].setInputOutput(0);
							}
						}
					}
				}
				if (predict)
					nationalMenu(good, states, eosCap, citizenship, mobilization);
				else {
					nationalMenu(good, eosCap, citizenship, mobilization);
				}
				break;
			case '4':
				if (predict)
					stateMenu(good, building, mapi, gdp, 1 / float(states));
				else {
					stateMenu(good, building, mapi, gdp);
				}
				break;
			case '5':
				if (predict)
					buildings(good, method, building, location, profession, mapi, gdp, 1 / float(states), eosCap, citizenship, mobilization);
				else {
					buildings(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization);
				}
				break;
			case '6':
				do {
					system("cls");
					cout << "Confirm Buildings Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 1; i < BSIZE; i++) {
								for (int j = building[i - 1].getBuildingLocation(); j < building[i].getBuildingLocation(); j++) {
									location[j].setLevel(0);
									location[j].setSubsidized(0);
									for (int k = 0; k < building[i - 1].getSize(); k++)
										location[j].setProductionMethodLevel(0, k);
									location[j].setBuildingThroughput(0);
								}
							}
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			default:
				system("cls");
				cout << "Error choose 0-6\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-6\n\n";
			system("pause");
		}
	} while (!exit);
}

void infamyMenu(float& inf)
{
	string in;
	char choice;
	int iIn;
	float fIn;
	float cost;
	bool exit = false;

	do {
		system("cls");

		cout << "Infamy: " << inf << endl << endl
			 << "1. Reputable Diplomatic Play\n"
			 << "2. Infamous Diplomatic Play\n"
			 << "3. Notorious Diplomatic Play\n"
			 << "4. Two Reputable Diplomatic Plays\n"
			 << "5. Two Infamous Diplomatic Plays\n"
			 << "6. Two Notorious Diplomatic Plays\n"
			 << "7. Reputable Diplomatic Plays\n"
			 << "8. Infamous Diplomatic Plays\n"
			 << "9. Notorious Diplomatic Plays\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				system("cls");
				cout << "Enter Infamy Cost of Diplomatic Play: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					inf = 24.9 - fIn;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '2':
				system("cls");
				cout << "Enter Infamy Cost of Diplomatic Play: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					inf = 49.9 - fIn;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '3':
				system("cls");
				cout << "Enter Infamy Cost of Diplomatic Play: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					inf = 99.9 - fIn;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '4':
				system("cls");
				cout << "Enter Infamy Cost of 1st Diplomatic Play: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					cost = fIn;
					cout << "Enter Infamy Cost of 2nd Diplomatic Play: ";
					cin >> fIn;

					if (!cin) {
						cin.clear();
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (fIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cost += fIn;
						inf = 24.9 - cost;
					}
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '5':
				system("cls");
				cout << "Enter Infamy Cost of 1st Diplomatic Play: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					cost = fIn;
					cout << "Enter Infamy Cost of 2nd Diplomatic Play: ";
					cin >> fIn;

					if (!cin) {
						cin.clear();
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (fIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cost += fIn;
						inf = 49.9 - cost;
					}
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '6':
				system("cls");
				cout << "Enter Infamy Cost of 1st Diplomatic Play: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					cost = fIn;
					cout << "Enter Infamy Cost of 2nd Diplomatic Play: ";
					cin >> fIn;

					if (!cin) {
						cin.clear();
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (fIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cost += fIn;
						inf = 99.9 - cost;
					}
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '7':
				cost = 0;

				system("cls");
				cout << "Enter Number of Diplomatic Plays: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					for (int i = 1; i <= iIn && !exit; i++) {
						cout << i << ". Enter Infamy Cost of Diplomatic Play: ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (fIn < 0) {
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							cost += fIn;
						}
					}
					if (exit)
						exit = false;
					else {
						inf = 24.9 - cost;
					}
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '8':
				cost = 0;

				system("cls");
				cout << "Enter Number of Diplomatic Plays: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					for (int i = 1; i <= iIn && !exit; i++) {
						cout << i << ". Enter Infamy Cost of Diplomatic Play: ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (fIn < 0) {
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							cost += fIn;
						}
					}
					if (exit)
						exit = false;
					else {
						inf = 49.9 - cost;
					}
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '9':
				cost = 0;

				system("cls");
				cout << "Enter Number of Diplomatic Plays: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					for (int i = 1; i <= iIn && !exit; i++) {
						cout << i << ". Enter Infamy Cost of Diplomatic Play: ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (fIn < 0) {
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							cost += fIn;
						}
					}
					if (exit)
						exit = false;
					else {
						inf = 99.9 - cost;
					}
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			default:
				system("cls");
				cout << "Error choose 0-9\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-9\n\n";
			system("pause");
		}
	} while (!exit);
}

void nationalMenu(goodsType good[GSIZE], float& eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	string in;
	char choice;
	bool exit = false;

	do {
		char answer = '\0';
		system("cls");

		cout << "Maximum Economy of Scale: " << (eosCap - 1) * 100 << "%\n"
			 << "Citizenship Law: ";
		switch (citizenship[0]) {
		case 1:
			cout << "National Supremacy";
			break;
		case 2:
			cout << "Racial Segregation";
			break;
		case 3:
			cout << "Cultural Exclusion";
			break;
		case 4:
			cout << "Multiculturalism";
			break;
		default:
			cout << "Ethnostate";
		}
		cout << endl
			 << "New Citizenship Law: ";
		switch (citizenship[1]) {
		case 1:
			cout << "National Supremacy";
			break;
		case 2:
			cout << "Racial Segregation";
			break;
		case 3:
			cout << "Cultural Exclusion";
			break;
		case 4:
			cout << "Multiculturalism";
			break;
		default:
			cout << "Ethnostate";
		}
		cout << endl << endl
			 << "1. Set Maximum Economy of Scale\n"
			 << "2. Set Citizenship Law\n"
			 << "3. Set New Citizenship Law\n"
			 << "4. Set Army Mobilization\n"
			 << "5. National Market\n"
			 << "6. Reset Market Data\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				eosCap = economyOfScale();
				break;
			case '2':
				citizenship[0] = citizenshipLaw();
				citizenship[1] = citizenship[0];
				break;
			case '3':
				citizenship[1] = citizenshipLaw();
				break;
			case '4':
				armyMobilization(mobilization);
				break;
			case '5':
				nationalMarket(good);
				break;
			case '6':
				do {
					system("cls");
					cout << "Confirm Market Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 0; i < GSIZE; i++) {
								if (!good[i].localGood()) {
									good[i].setSellOrders(0);
									good[i].setBuyOrders(0);
									good[i].setPopConsumption(0);
									good[i].setImports(0);
								}
							}
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			default:
				system("cls");
				cout << "Error choose 0-6\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-6\n\n";
			system("pause");
		}
	} while (!exit);
}

void nationalMenu(goodsType good[GSIZE], int& states, float& eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	string in;
	char choice;
	int iIn;
	bool exit = false;

	do {
		char answer = '\0';
		system("cls");

		cout << "Number of Owned States: " << states << endl
			 << "Maximum Economy of Scale: " << (eosCap - 1) * 100 << "%\n"
			 << "Citizenship Law: ";
		switch (citizenship[0]) {
		case 1:
			cout << "National Supremacy";
			break;
		case 2:
			cout << "Racial Segregation";
			break;
		case 3:
			cout << "Cultural Exclusion";
			break;
		case 4:
			cout << "Multiculturalism";
			break;
		default:
			cout << "Ethnostate";
		}
		cout << endl
			 << "New Citizenship Law: ";
		switch (citizenship[1]) {
		case 1:
			cout << "National Supremacy";
			break;
		case 2:
			cout << "Racial Segregation";
			break;
		case 3:
			cout << "Cultural Exclusion";
			break;
		case 4:
			cout << "Multiculturalism";
			break;
		default:
			cout << "Ethnostate";
		}
		cout << endl << endl
			 << "1. Set Number of Owned States\n"
			 << "2. Set Maximum Economy of Scale\n"
			 << "3. Set Citizenship Law\n"
			 << "4. Set New Citizenship Law\n"
			 << "5. Set Army Mobilization\n"
			 << "6. National Market\n"
			 << "7. Reset Market Data\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				system("cls");
				cout << "Enter Number of Owned States: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					states = iIn;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '2':
				eosCap = economyOfScale();
				break;
			case '3':
				citizenship[0] = citizenshipLaw();
				citizenship[1] = citizenship[0];
				break;
			case '4':
				citizenship[1] = citizenshipLaw();
				break;
			case '5':
				armyMobilization(mobilization);
				break;
			case '6':
				nationalMarket(good, 1 / float(states));
				break;
			case '7':
				do {
					system("cls");
					cout << "Confirm Market Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 0; i < GSIZE; i++) {
								good[i].setSellOrders(0);
								good[i].setBuyOrders(0);
								good[i].setPopConsumption(0);
								good[i].setImports(0);
							}
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			default:
				system("cls");
				cout << "Error choose 0-7\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-7\n\n";
			system("pause");
		}
	} while (!exit);
}

float economyOfScale()
{
	string in;
	char choice;
	system("cls");

	cout << "1. Set Maximum Economy of Scale to 20%\n"
		 << "2. Set Maximum Economy of Scale to 30%\n"
		 << "3. Set Maximum Economy of Scale to 50%\n"
		 << "Enter your choice: ";
	getline(cin, in);
	if (in.length() == 1) {
		choice = in[0];
		switch (choice) {
		case '1':
			return 1.2;
		case '2':
			return 1.3;
		case '3':
			return 1.5;
		default:
			system("cls");
			cout << "Error choose 1-3\n\n";
			system("pause");
			return economyOfScale();
		}
	}
	else {
		system("cls");
		cout << "Error choose 1-3\n\n";
		system("pause");
		return economyOfScale();
	}
}

void armyMobilization(bool mobilization[ASIZE][2])
{
	bool currently = true;
	string in;
	char choice;
	bool exit = false;

	do {
		system("cls");
		
		if (currently) {
			cout << "Army is Mobilized: ";
			if (mobilization[0][0])
				cout << "yes";
			else {
				cout << "no";
			}
			if (mobilization[0][0]) {
				cout << endl
					 << "Army has Basic Supplies: ";
				if (mobilization[1][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Extra Supplies: ";
				if (mobilization[2][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Luxurious Supplies: ";
				if (mobilization[3][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Chocolate: ";
				if (mobilization[4][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Tobacco: ";
				if (mobilization[5][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Liquor: ";
				if (mobilization[6][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Opium: ";
				if (mobilization[7][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Truck Transport: ";
				if (mobilization[8][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Rail Transport: ";
				if (mobilization[9][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Motorized Reconnaisance: ";
				if (mobilization[10][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Balloon Reconnaisance: ";
				if (mobilization[11][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Aerial Reconnaisance: ";
				if (mobilization[12][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Machine Gunners: ";
				if (mobilization[13][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Chemical Weapons: ";
				if (mobilization[14][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Flamethrowers: ";
				if (mobilization[15][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has First Aid: ";
				if (mobilization[16][0])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army has Field Hospitals: ";
				if (mobilization[17][0])
					cout << "yes";
				else {
					cout << "no";
				}
			}
		}
		else {
			cout << "Army will be Mobilized: ";
			if (mobilization[0][1])
				cout << "yes";
			else {
				cout << "no";
			}
			if (mobilization[0][1]) {
				cout << endl
					 << "Army will have Basic Supplies: ";
				if (mobilization[1][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Extra Supplies: ";
				if (mobilization[2][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Luxurious Supplies: ";
				if (mobilization[3][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Chocolate: ";
				if (mobilization[4][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Tobacco: ";
				if (mobilization[5][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Liquor: ";
				if (mobilization[6][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Opium: ";
				if (mobilization[7][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Truck Transport: ";
				if (mobilization[8][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Rail Transport: ";
				if (mobilization[9][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Motorized Reconnaisance: ";
				if (mobilization[10][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Balloon Reconnaisance: ";
				if (mobilization[11][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Aerial Reconnaisance: ";
				if (mobilization[12][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Machine Gunners: ";
				if (mobilization[13][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Chemical Weapons: ";
				if (mobilization[14][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Flamethrowers: ";
				if (mobilization[15][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have First Aid: ";
				if (mobilization[16][1])
					cout << "yes";
				else {
					cout << "no";
				}
				cout << endl
					 << "Army will have Field Hospitals: ";
				if (mobilization[17][1])
					cout << "yes";
				else {
					cout << "no";
				}
			}
		}
		cout << endl << endl
			 << "1. Toggle Set\n"
			 << "2. Toggle Mobilization\n";
		if (currently) {
			if (mobilization[0][0]) {
				cout << "3. Toggle Basic Supplies\n"
					 << "4. Toggle Extra Supplies\n"
					 << "5. Toggle Luxurious Supplies\n"
					 << "6. Toggle Chocolate\n"
					 << "7. Toggle Tobacco\n"
					 << "8. Toggle Liquor\n"
					 << "9. Toggle Opium\n"
					 << "10. Toggle Truck Transport\n"
					 << "11. Toggle Rail Transport\n"
					 << "12. Toggle Motorized Reconnaisance\n"
					 << "13. Toggle Balloon Reconnaisance\n"
					 << "14. Toggle Aerial Reconnaisance\n"
					 << "15. Toggle Machine Gunners\n"
					 << "16. Toggle Chemical Weapons\n"
					 << "17. Toggle Flamethrowers\n"
					 << "18. Toggle First Aid\n"
					 << "19. Toggle Field Hospitals\n";
			}
		}
		else if (mobilization[0][1]) {
			cout << "3. Toggle Basic Supplies\n"
				 << "4. Toggle Extra Supplies\n"
				 << "5. Toggle Luxurious Supplies\n"
				 << "6. Toggle Chocolate\n"
				 << "7. Toggle Tobacco\n"
				 << "8. Toggle Liquor\n"
				 << "9. Toggle Opium\n"
				 << "10. Toggle Truck Transport\n"
				 << "11. Toggle Rail Transport\n"
				 << "12. Toggle Motorized Reconnaisance\n"
				 << "13. Toggle Balloon Reconnaisance\n"
				 << "14. Toggle Aerial Reconnaisance\n"
				 << "15. Toggle Machine Gunners\n"
				 << "16. Toggle Chemical Weapons\n"
				 << "17. Toggle Flamethrowers\n"
				 << "18. Toggle First Aid\n"
				 << "19. Toggle Field Hospitals\n";
		}
		cout << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (currently) {
			if (mobilization[0][0]) {
				if (in.length() == 1) {
					choice = in[0];
					switch (choice) {
					case '0':
						exit = true;
						break;
					case '1':
						currently = false;
						break;
					case '2':
						mobilization[0][0] = false;
						break;
					case '3':
						if (mobilization[1][0])
							mobilization[1][0] = false;
						else {
							mobilization[1][0] = true;
						}
						mobilization[1][1] = mobilization[1][0];
						break;
					case '4':
						if (mobilization[2][0])
							mobilization[2][0] = false;
						else {
							mobilization[2][0] = true;
						}
						mobilization[2][1] = mobilization[2][0];
						break;
					case '5':
						if (mobilization[3][0])
							mobilization[3][0] = false;
						else {
							mobilization[3][0] = true;
						}
						mobilization[3][1] = mobilization[3][0];
						break;
					case '6':
						if (mobilization[4][0])
							mobilization[4][0] = false;
						else {
							mobilization[4][0] = true;
						}
						mobilization[4][1] = mobilization[4][0];
						break;
					case '7':
						if (mobilization[5][0])
							mobilization[5][0] = false;
						else {
							mobilization[5][0] = true;
						}
						mobilization[5][1] = mobilization[5][0];
						break;
					case '8':
						if (mobilization[6][0])
							mobilization[6][0] = false;
						else {
							mobilization[6][0] = true;
						}
						mobilization[6][1] = mobilization[6][0];
						break;
					case '9':
						if (mobilization[7][0])
							mobilization[7][0] = false;
						else {
							mobilization[7][0] = true;
						}
						mobilization[7][1] = mobilization[7][0];
						break;
					default:
						system("cls");
						cout << "Error choose 0-19\n\n";
						system("pause");
					}
				}
				else if (in.length() == 2) {
					choice = in[0];
					if (choice == '1') {
						choice = in[1];
						switch (choice) {
						case '0':
							if (mobilization[8][0])
								mobilization[8][0] = false;
							else {
								mobilization[8][0] = true;
								for (int i = 0; i < 2; i++)
									mobilization[9][i] = false;
							}
							mobilization[8][1] = mobilization[8][0];
							break;
						case '1':
							if (mobilization[9][0])
								mobilization[9][0] = false;
							else {
								mobilization[9][0] = true;
								for (int i = 0; i < 2; i++)
									mobilization[8][i] = false;
							}
							mobilization[9][1] = mobilization[9][0];
							break;
						case '2':
							if (mobilization[10][0])
								mobilization[10][0] = false;
							else {
								mobilization[10][0] = true;
							}
							mobilization[10][1] = mobilization[10][0];
							break;
						case '3':
							if (mobilization[11][0])
								mobilization[11][0] = false;
							else {
								mobilization[11][0] = true;
							}
							mobilization[11][1] = mobilization[11][0];
							break;
						case '4':
							if (mobilization[12][0])
								mobilization[12][0] = false;
							else {
								mobilization[12][0] = true;
							}
							mobilization[12][1] = mobilization[12][0];
							break;
						case '5':
							if (mobilization[13][0])
								mobilization[13][0] = false;
							else {
								mobilization[13][0] = true;
							}
							mobilization[13][1] = mobilization[13][0];
							break;
						case '6':
							if (mobilization[14][0])
								mobilization[14][0] = false;
							else {
								mobilization[14][0] = true;
							}
							mobilization[14][1] = mobilization[14][0];
							break;
						case '7':
							if (mobilization[15][0])
								mobilization[15][0] = false;
							else {
								mobilization[15][0] = true;
							}
							mobilization[15][1] = mobilization[15][0];
							break;
						case '8':
							if (mobilization[16][0])
								mobilization[16][0] = false;
							else {
								mobilization[16][0] = true;
								for (int i = 0; i < 2; i++)
									mobilization[17][i] = false;
							}
							mobilization[16][1] = mobilization[16][0];
							break;
						case '9':
							if (mobilization[17][0])
								mobilization[17][0] = false;
							else {
								mobilization[17][0] = true;
								for (int i = 0; i < 2; i++)
									mobilization[16][i] = false;
							}
							mobilization[17][1] = mobilization[17][0];
							break;
						default:
							system("cls");
							cout << "Error choose 0-19\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error choose 0-19\n\n";
						system("pause");
					}
				}
				else {
					system("cls");
					cout << "Error choose 0-19\n\n";
					system("pause");
				}
			}
			else if (in.length() == 1) {
				choice = in[0];
				switch (choice) {
				case '0':
					exit = true;
					break;
				case '1':
					currently = false;
					break;
				case '2':
					mobilization[0][0] = true;
					break;
				default:
					system("cls");
					cout << "Error choose 0-2\n\n";
					system("pause");
				}
			}
			else {
				system("cls");
				cout << "Error choose 0-2\n\n";
				system("pause");
			}
		}
		else if (mobilization[0][1]) {
			if (in.length() == 1) {
				choice = in[0];
				switch (choice) {
				case '0':
					exit = true;
					break;
				case '1':
					currently = true;
					break;
				case '2':
					mobilization[0][1] = false;
					break;
				case '3':
					if (mobilization[1][1])
						mobilization[1][1] = false;
					else {
						mobilization[1][1] = true;
					}
					break;
				case '4':
					if (mobilization[2][1])
						mobilization[2][1] = false;
					else {
						mobilization[2][1] = true;
					}
					break;
				case '5':
					if (mobilization[3][1])
						mobilization[3][1] = false;
					else {
						mobilization[3][1] = true;
					}
					break;
				case '6':
					if (mobilization[4][1])
						mobilization[4][1] = false;
					else {
						mobilization[4][1] = true;
					}
					break;
				case '7':
					if (mobilization[5][1])
						mobilization[5][1] = false;
					else {
						mobilization[5][1] = true;
					}
					break;
				case '8':
					if (mobilization[6][1])
						mobilization[6][1] = false;
					else {
						mobilization[6][1] = true;
					}
					break;
				case '9':
					if (mobilization[7][1])
						mobilization[7][1] = false;
					else {
						mobilization[7][1] = true;
					}
					break;
				default:
					system("cls");
					cout << "Error choose 0-19\n\n";
					system("pause");
				}
			}
			else if (in.length() == 2) {
				choice = in[0];
				if (choice == '1') {
					choice = in[1];
					switch (choice) {
					case '0':
						if (mobilization[8][1])
							mobilization[8][1] = false;
						else {
							mobilization[8][1] = true;
							mobilization[9][1] = false;
						}
						break;
					case '1':
						if (mobilization[9][1])
							mobilization[9][1] = false;
						else {
							mobilization[9][1] = true;
							mobilization[8][1] = false;
						}
						break;
					case '2':
						if (mobilization[10][1])
							mobilization[10][1] = false;
						else {
							mobilization[10][1] = true;
						}
						break;
					case '3':
						if (mobilization[11][1])
							mobilization[11][1] = false;
						else {
							mobilization[11][1] = true;
						}
						break;
					case '4':
						if (mobilization[12][1])
							mobilization[12][1] = false;
						else {
							mobilization[12][1] = true;
						}
						break;
					case '5':
						if (mobilization[13][1])
							mobilization[13][1] = false;
						else {
							mobilization[13][1] = true;
						}
						break;
					case '6':
						if (mobilization[14][1])
							mobilization[14][1] = false;
						else {
							mobilization[14][1] = true;
						}
						break;
					case '7':
						if (mobilization[15][1])
							mobilization[15][1] = false;
						else {
							mobilization[15][1] = true;
						}
						break;
					case '8':
						if (mobilization[16][1])
							mobilization[16][1] = false;
						else {
							mobilization[16][1] = true;
							mobilization[17][1] = false;
						}
						break;
					case '9':
						if (mobilization[17][1])
							mobilization[17][1] = false;
						else {
							mobilization[17][1] = true;
							mobilization[16][1] = false;
						}
						break;
					default:
						system("cls");
						cout << "Error choose 0-19\n\n";
						system("pause");
					}
				}
				else {
					system("cls");
					cout << "Error choose 0-19\n\n";
					system("pause");
				}
			}
			else {
				system("cls");
				cout << "Error choose 0-19\n\n";
				system("pause");
			}
		}
		else if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				currently = true;
				break;
			case '2':
				mobilization[0][1] = true;
				break;
			default:
				system("cls");
				cout << "Error choose 0-2\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-2\n\n";
			system("pause");
		}
	} while (!exit);
}

int citizenshipLaw()
{
	string in;
	char choice;
	system("cls");

	cout << "1. Set Citizenship Law to Ethnostate\n"
		 << "2. Set Citizenship Law to National Supremacy\n"
		 << "3. Set Citizenship Law to Racial Segregation\n"
		 << "4. Set Citizenship Law to Cultural Exclusion\n"
		 << "5. Set Citizenship Law to Multiculturalism\n"
		 << "Enter your choice: ";
	getline(cin, in);
	if (in.length() == 1) {
		choice = in[0];
		switch (choice) {
		case '1':
			return 0;
		case '2':
			return 1;
		case '3':
			return 2;
		case '4':
			return 3;
		case '5':
			return 4;
		default:
			system("cls");
			cout << "Error choose 1-5\n\n";
			system("pause");
			return citizenshipLaw();
		}
	}
	else {
		system("cls");
		cout << "Error choose 1-5\n\n";
		system("pause");
		return citizenshipLaw();
	}
}

void nationalMarket(goodsType good[GSIZE])
{
	int it[GSIZE];
	int skip = 0;
	for (int i = 0; i < GSIZE; i++) {
		if (good[i].localGood())
			skip++;
		else {
			it[i - skip] = i;
		}
	}
	int size = GSIZE - skip;
	int sorted = 1;
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << "Market\n"
			 << " 1. Sort"
			 << "                                       2. Sort"
			 << "         3. Sort"
			 << "           4. Sort"
			 << "                       5. Sort"
			 << "            6. Sort\n"
			 << "                      Sell Orders"
			 << "  Buy Orders"
			 << "  Balance"
			 << "  Market Price"
			 << "  Population Consumption Costs"
			 << "  Subsidized Consumption Costs"
			 << "  Imports\n";
		for (int i = 0; i < size; i++) {
			int popConsumption = good[it[i]].getPopConsumption() * good[it[i]].getMarketPrice();
			int subConsumption = (good[it[i]].getInput(0) + good[it[i]].getMilitaryConsumption()) * good[it[i]].getMarketPrice();
			if (i < 3)
				cout << " ";
			cout << i + 7 << ". " << left << setw(18) << good[it[i]].getGood()
				 << left << setw(13) << trunc(good[it[i]].getSellOrders())
				 << left << setw(12) << trunc(good[it[i]].getBuyOrders());
			if (good[it[i]].getBalance() > 0)
				cout << "+" << left << setw(8);
			else {
				cout << left << setw(9);
			}
			cout << good[it[i]].getBalance()
				 << "$" << left << setw(6) << trunc(good[it[i]].getMarketPrice());
			if (good[it[i]].getMarketPricePercent() > 0)
				cout << "+" << left << setw(3);
			else {
				cout << left << setw(4);
			}
			cout << trunc(good[it[i]].getMarketPricePercent() * 100);
			if (good[it[i]].tradable())
				cout << left << setw(3);
			else {
				cout << left << setw(57);
			}
			cout << "%";
			if (good[it[i]].tradable()) {
				cout << left << setw(11) << good[it[i]].getPopConsumption()
					 << "$" << left << setw(18) << popConsumption
					 << left << setw(11) << trunc(good[it[i]].getInput(0) + good[it[i]].getMilitaryConsumption())
					 << "$" << left << setw(18) << subConsumption
					 << good[it[i]].getImports();
			}
			cout << endl;
		}
		cout << endl << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << size + 6 << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > size + 6) {
			system("cls");
			cout << "Error choose 0-" << size + 6 << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else if (choice == 1) {
			sorted = choice;
			skip = 0;
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].localGood())
					skip++;
				else {
					it[i - skip] = i;
				}
			}
		}
		else if (choice == 2) {
			int i = 0;
			for (;i < GSIZE && good[i].localGood(); i++) {}
			if (i < GSIZE) {
				it[0] = i;
				skip = ++i;
			}
			if (sorted == choice) {
				sorted = 1;
				for (;i < GSIZE; i++) {
					if (good[i].localGood())
						skip++;
					else {
						int j = i - skip;
						for (;j >= 0 && good[i].getBalance() > good[it[j]].getBalance(); j--)
							it[j + 1] = it[j];
						it[j + 1] = i;
					}
				}
			}
			else {
				sorted = choice;
				for (;i < GSIZE; i++) {
					if (good[i].localGood())
						skip++;
					else {
						int j = i - skip;
						for (;j >= 0 && good[i].getBalance() < good[it[j]].getBalance(); j--)
							it[j + 1] = it[j];
						it[j + 1] = i;
					}
				}
			}
		}
		else if (choice == 3) {
			int i = 0;
			for (;i < GSIZE && good[i].localGood(); i++) {}
			if (i < GSIZE) {
				it[0] = i;
				skip = ++i;
			}
			if (sorted == choice) {
				sorted = 1;
				for (;i < GSIZE; i++) {
					if (good[i].localGood())
						skip++;
					else {
						int j = i - skip;
						for (;j >= 0 && good[i].getMarketPricePercent() < good[it[j]].getMarketPricePercent(); j--)
							it[j + 1] = it[j];
						it[j + 1] = i;
					}
				}
			}
			else {
				sorted = choice;
				for (;i < GSIZE; i++) {
					if (good[i].localGood())
						skip++;
					else {
						int j = i - skip;
						for (;j >= 0 && good[i].getMarketPricePercent() > good[it[j]].getMarketPricePercent(); j--)
							it[j + 1] = it[j];
						it[j + 1] = i;
					}
				}
			}
		}
		else if (choice == 4) {
			sorted = choice;
			int i = 0;
			for (;i < GSIZE && good[i].localGood(); i++) {}
			if (i < GSIZE) {
				it[0] = i;
				skip = ++i;
			}
			for (;i < GSIZE; i++) {
				if (good[i].localGood())
					skip++;
				else {
					int j = i - skip;
					float key = -1;
					if (good[i].tradable())
						key = good[i].getPopConsumption() * good[i].getMarketPrice();
					float value = -1;
					if (good[it[j]].tradable())
						value = good[it[j]].getPopConsumption() * good[it[j]].getMarketPrice();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].tradable())
								value = good[it[j]].getPopConsumption() * good[it[j]].getMarketPrice();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 5) {
			sorted = choice;
			int i = 0;
			for (;i < GSIZE && good[i].localGood(); i++) {}
			if (i < GSIZE) {
				it[0] = i;
				skip = ++i;
			}
			for (;i < GSIZE; i++) {
				if (good[i].localGood())
					skip++;
				else {
					int j = i - skip;
					float key = -1;
					if (good[i].tradable())
						key = (good[i].getInput(0) + good[i].getMilitaryConsumption()) * good[i].getMarketPrice();
					float value = -1;
					if (good[it[j]].tradable())
						value = (good[it[j]].getInput(0) + good[it[j]].getMilitaryConsumption()) * good[it[j]].getMarketPrice();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].tradable())
								value = (good[it[j]].getInput(0) + good[it[j]].getMilitaryConsumption()) * good[it[j]].getMarketPrice();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 6) {
			sorted = choice;
			int i = 0;
			for (;i < GSIZE && good[i].localGood(); i++) {}
			if (i < GSIZE) {
				it[0] = i;
				skip = ++i;
			}
			for (;i < GSIZE; i++) {
				if (good[i].localGood())
					skip++;
				else {
					int j = i - skip;
					float key = -1;
					if (good[i].tradable())
						key = good[i].getImports();
					float value = -1;
					if (good[it[j]].tradable())
						value = good[it[j]].getImports();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].tradable())
								value = good[it[j]].getImports();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (good[it[choice - 7]].getGood() == "Gold") {
			system("cls");
			cout << "Enter Gold Sell Orders: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[it[choice - 7]].setSellOrders(fIn);
				sorted = 1;
				skip = 0;
				for (int i = 0; i < GSIZE; i++) {
					if (good[i].localGood())
						skip++;
					else {
						it[i - skip] = i;
					}
				}
			}
		}
		else {
			balance(good, it[choice - 7]);
			sorted = 1;
			skip = 0;
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].localGood())
					skip++;
				else {
					it[i - skip] = i;
				}
			}
		}
	} while (!exit);
}

void nationalMarket(goodsType good[GSIZE], float gdp)
{
	int it[GSIZE];
	for (int i = 0; i < GSIZE; i++)
		it[i] = i;
	int sorted = 1;
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << "Market\n"
			 << " 1. Sort"
			 << "                                       2. Sort"
			 << "         3. Sort"
			 << "           4. Sort"
			 << "                       5. Sort"
			 << "            6. Sort\n"
			 << "                      Sell Orders"
			 << "  Buy Orders"
			 << "  Balance"
			 << "  Market Price"
			 << "  Population Consumption Costs"
			 << "  Subsidized Consumption Costs"
			 << "  Imports\n";
		for (int i = 0; i < GSIZE; i++) {
			int popConsumption = good[it[i]].getPopConsumption() * good[it[i]].getMarketPrice();
			int subConsumption = (good[it[i]].getInput(0) + good[it[i]].getMilitaryConsumption()) * good[it[i]].getMarketPrice();
			if (i < 3)
				cout << " ";
			cout << i + 7 << ". " << left << setw(18) << good[it[i]].getGood()
				 << left << setw(13) << trunc(good[it[i]].getSellOrders())
				 << left << setw(12) << trunc(good[it[i]].getBuyOrders());
			if (good[it[i]].getBalance() > 0) {
				cout << "+";
				if (good[it[i]].localGood())
					cout << left << setw(76);
				else {
					cout << left << setw(8);
				}
			}
			else if (good[it[i]].localGood())
				cout << left << setw(77);
			else {
				cout << left << setw(9);
			}
			cout << good[it[i]].getBalance();
			if (!good[it[i]].localGood()) {
				cout << "$" << left << setw(6) << trunc(good[it[i]].getMarketPrice());
				if (good[it[i]].getMarketPricePercent() > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getMarketPricePercent() * 100);
				if (good[it[i]].tradable())
					cout << left << setw(3);
				else {
					cout << left << setw(57);
				}
				cout << "%";
				if (good[it[i]].tradable()) {
					cout << left << setw(11) << good[it[i]].getPopConsumption()
						 << "$" << left << setw(18) << popConsumption
						 << left << setw(11) << trunc(good[it[i]].getInput(0) + good[it[i]].getMilitaryConsumption())
						 << "$" << left << setw(18) << subConsumption
						 << good[it[i]].getImports();
				}
			}
			cout << endl;
		}
		cout << endl << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << GSIZE + 6 << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > GSIZE + 6) {
			system("cls");
			cout << "Error choose 0-" << GSIZE + 6 << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else if (choice == 1) {
			sorted = choice;
			for (int i = 0; i < GSIZE; i++)
				it[i] = i;
		}
		else if (choice == 2) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					for (;j >= 0 && good[i].getBalance() > good[it[j]].getBalance(); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					for (;j >= 0 && good[i].getBalance() < good[it[j]].getBalance(); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 3) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key = 1;
					if (!good[i].localGood())
						key = good[i].getMarketPricePercent();
					float value = 1;
					if (!good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = 1;
							else {
								value = good[it[j]].getMarketPricePercent();
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key = -1;
					if (!good[i].localGood())
						key = good[i].getMarketPricePercent();
					float value = -1;
					if (!good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = -1;
							else {
								value = good[it[j]].getMarketPricePercent();
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 4) {
			sorted = choice;
			it[0] = 0;
			for (int i = 1; i < GSIZE; i++) {
				int j = i - 1;
				float key = -1;
				if (good[i].tradable())
					key = good[i].getPopConsumption() * good[i].getMarketPrice();
				float value = -1;
				if (good[it[j]].tradable())
					value = good[it[j]].getPopConsumption() * good[it[j]].getMarketPrice();
				while (j >= 0 && key > value) {
					it[j + 1] = it[j];
					if (--j >= 0) {
						if (good[it[j]].tradable())
							value = good[it[j]].getPopConsumption() * good[it[j]].getMarketPrice();
						else {
							value = -1;
						}
					}
				}
				it[j + 1] = i;
			}
		}
		else if (choice == 5) {
			sorted = choice;
			it[0] = 0;
			for (int i = 1; i < GSIZE; i++) {
				int j = i - 1;
				float key = -1;
				if (good[i].tradable())
					key = (good[i].getInput(0) + good[i].getMilitaryConsumption()) * good[i].getMarketPrice();
				float value = -1;
				if (good[it[j]].tradable())
					value = (good[it[j]].getInput(0) + good[it[j]].getMilitaryConsumption()) * good[it[j]].getMarketPrice();
				while (j >= 0 && key > value) {
					it[j + 1] = it[j];
					if (--j >= 0) {
						if (good[it[j]].tradable())
							value = (good[it[j]].getInput(0) + good[it[j]].getMilitaryConsumption()) * good[it[j]].getMarketPrice();
						else {
							value = -1;
						}
					}
				}
				it[j + 1] = i;
			}
		}
		else if (choice == 6) {
			sorted = choice;
			it[0] = 0;
			for (int i = 1; i < GSIZE; i++) {
				int j = i - 1;
				float key = -1;
				if (good[i].tradable())
					key = good[i].getImports();
				float value = -1;
				if (good[it[j]].tradable())
					value = good[it[j]].getImports();
				while (j >= 0 && key > value) {
					it[j + 1] = it[j];
					if (--j >= 0) {
						if (good[it[j]].tradable())
							value = good[it[j]].getImports();
						else {
							value = -1;
						}
					}
				}
				it[j + 1] = i;
			}
		}
		else if (good[it[choice - 7]].getGood() == "Gold") {
			system("cls");
			cout << "Enter Gold Sell Orders: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[it[choice - 7]].setSellOrders(fIn);
				sorted = 1;
				for (int i = 0; i < GSIZE; i++)
					it[i] = i;
			}
		}
		else {
			balance(good, gdp, it[choice - 7]);
			sorted = 1;
			for (int i = 0; i < GSIZE; i++)
				it[i] = i;
		}
	} while (!exit);
}

void balance(goodsType good[GSIZE], int i)
{
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << good[i].getGood() << endl
			 << "Sell Orders: " << good[i].getSellOrders() << endl
			 << "Buy Orders: " << good[i].getBuyOrders() << endl;
		if (good[i].hasWeight())
			cout << "Pop Consumption: " << good[i].getPopConsumption() << endl;
		cout << "Imports: " << good[i].getImports() << endl
			 << "Balance: ";
		if (good[i].getBalance() > 0)
			cout << "+";
		cout << good[i].getBalance() << endl
			 << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
		if (good[i].getMarketPricePercent() > 0)
			cout << "+";
		cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n\n";
		int j = 3;
		cout << "1. Set Sell Orders\n"
			 << "2. Set Buy Orders\n";
		if (good[i].hasWeight())
			cout << j++ << ". Set Pop Consumption\n";
		cout << j++ << ". Set Imports\n"
			 << j << ". Production\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << j << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > j) {
			system("cls");
			cout << "Error choose 0-" << j << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			cout << "Enter Sell Orders: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn < good[i].getImports())
					good[i].setImports(fIn);
				good[i].setSellOrders(fIn);
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Buy Orders: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn < good[i].getPopConsumption())
					good[i].setPopConsumption(fIn);
				good[i].setBuyOrders(fIn);
			}
		}
		else if (choice == j--)
			production(good[i]);
		else if (choice == j) {
			system("cls");
			cout << "Enter Imports: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn > good[i].getSellOrders())
					good[i].setSellOrders(fIn);
				good[i].setImports(fIn);
			}
		}
		else {
			system("cls");
			cout << "Enter Pop Consumption: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn > good[i].getBuyOrders())
					good[i].setBuyOrders(fIn);
				good[i].setPopConsumption(fIn);
			}
		}
	} while (!exit);
}

void balance(goodsType good[GSIZE], float gdp, int i)
{
	int choice;
	int iIn;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << good[i].getGood() << endl
			 << "Sell Orders: " << good[i].getSellOrders() << endl
			 << "Buy Orders: " << good[i].getBuyOrders() << endl;
		if (good[i].hasWeight())
			cout << "Pop Consumption: " << good[i].getPopConsumption() << endl;
		if (good[i].tradable())
			cout << "Imports: " << good[i].getImports() << endl;
		cout << "Pop Percentage with Obsession: " << good[i].getObsession() * 100 << "%\n"
			 << "Pop Percentage with Taboo: " << good[i].getTaboo() * 100 << "%\n"
			 << "Balance: ";
		if (good[i].getBalance() > 0)
			cout << "+";
		cout << good[i].getBalance() << endl;
		if (!good[i].localGood()) {
			cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
			if (good[i].getMarketPricePercent() > 0)
				cout << "+";
			cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
		}
		int j = 3;
		cout << endl
			 << "1. Set Sell Orders\n"
			 << "2. Set Buy Orders\n";
		if (good[i].hasWeight())
			cout << j++ << ". Set Pop Consumption\n";
		if (good[i].tradable())
			cout << j++ << ". Set Imports\n";
		cout << j++ << ". Set Pop Percentage with Obsession\n";
		cout << j++ << ". Set Pop Percentage with Taboo\n"
			 << j << ". Production\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << j << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > j) {
			system("cls");
			cout << "Error choose 0-" << j << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			if (good[i].localGood()) {
				float sell = 0;

				cout << "Enter Number of States with Sell Orders: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					for (j = 1; j <= iIn && !exit; j++) {
						cout << j << ". Enter Sell Orders: ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (fIn < 0) {
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							sell += fIn;
						}
					}
					if (exit)
						exit = false;
					else if (sell >= 100)
						good[i].setSellOrders(ceil(sell));
					else if (sell >= 10)
						good[i].setSellOrders(ceil(sell * 10) / 10);
					else if (sell >= 1)
						good[i].setSellOrders(ceil(sell * 100) / 100);
					else {
						good[i].setSellOrders(round(sell * 100) / 100);
					}
				}
			}
			else {
				cout << "Enter Sell Orders: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					if (fIn < good[i].getImports())
						good[i].setImports(fIn);
					good[i].setSellOrders(fIn);
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			if (good[i].localGood()) {
				float buy = 0;

				cout << "Enter Number of States with Buy Orders: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					for (j = 1; j <= iIn && !exit; j++) {
						cout << j << ". Enter Buy Orders: ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (fIn < 0) {
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							buy += fIn;
						}
					}
					if (exit)
						exit = false;
					else {
						if (buy >= 100)
							buy = ceil(buy);
						else if (buy >= 10)
							buy = ceil(buy * 10) / 10;
						else if (buy >= 1)
							buy = ceil(buy * 100) / 100;
						else {
							buy = round(buy * 100) / 100;
						}
						if (buy < good[i].getPopConsumption())
							good[i].setPopConsumption(buy);
						good[i].setBuyOrders(buy);
					}
				}
			}
			else {
				cout << "Enter Buy Orders: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					if (fIn < good[i].getPopConsumption())
						good[i].setPopConsumption(fIn);
					good[i].setBuyOrders(fIn);
				}
			}
		}
		else if (choice == j--)
			production(good, gdp, i);
		else if (choice == j--) {
			system("cls");
			cout << "Enter Pop Percentage with Taboo (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0 || fIn > 100) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[i].setTaboo(trunc1D(fIn) / 100);
			}
		}
		else if (choice == j--) {
			system("cls");
			cout << "Enter Pop Percentage with Obsession (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0 || fIn > 100) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[i].setObsession(trunc1D(fIn) / 100);
			}
		}
		else if (choice == j && good[i].tradable()) {
			system("cls");
			cout << "Enter Imports: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn > good[i].getSellOrders())
					good[i].setSellOrders(fIn);
				good[i].setImports(fIn);
			}
		}
		else {
			system("cls");
			if (good[i].localGood()) {
				float popConsumption = 0;

				cout << "Enter Number of States with Pop Consumption: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					for (j = 1; j <= iIn && !exit; j++) {
						cout << j << ". Enter Pop Consumption: ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (fIn < 0) {
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							popConsumption += fIn;
						}
					}
					if (exit)
						exit = false;
					else {
						if (popConsumption >= 100)
							popConsumption = ceil(popConsumption);
						else if (popConsumption >= 10)
							popConsumption = ceil(popConsumption * 10) / 10;
						else if (popConsumption >= 1)
							popConsumption = ceil(popConsumption * 100) / 100;
						else {
							popConsumption = round(popConsumption * 100) / 100;
						}
						if (popConsumption > good[i].getBuyOrders())
							good[i].setBuyOrders(popConsumption);
						good[i].setPopConsumption(popConsumption);
					}
				}
			}
			else {
				cout << "Enter Pop Consumption: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					if (fIn > good[i].getBuyOrders())
						good[i].setBuyOrders(fIn);
					good[i].setPopConsumption(fIn);
				}
			}
		}
	} while (!exit);
}

void production(goodsType good)
{
	float fIn;
	system("cls");

	cout << good.getGood() << endl
		 << "Sell Orders: " << good.getSellOrders() << endl
		 << "Buy Orders: " << good.getBuyOrders() << endl
		 << "Balance: ";
	if (good.getBalance() > 0)
		cout << "+";
	cout << good.getBalance() << endl
		 << "Market Price: $" << trunc1D(good.getMarketPrice()) << " ";
	if (good.getMarketPricePercent() > 0)
		cout << "+";
	cout << trunc(good.getMarketPricePercent() * 100) << "%\n";
	if (good.getPopConsumption() != 0) {
		cout << "Pop Consumption: " << good.getPopConsumption() << endl
			 << "Pop Consumption Costs: $" << trunc2D(good.getPopConsumption() * good.getMarketPrice()) << endl;
	}
	if (good.getInput(0) + good.getMilitaryConsumption() != 0) {
		cout << "Subsidized Consumption: " << good.getInput(0) + good.getMilitaryConsumption() << endl
			 << "Subsidized Consumption Costs: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * good.getMarketPrice()) << endl;
	}
	cout << endl << "Enter Desired Sell Orders: ";
	cin >> fIn;

	if (!cin) {
		cin.clear();
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
		system("cls");
		cout << "Error invalid input\n\n";
	}
	else if (fIn < 0) {
		system("cls");
		cout << "Error invalid input\n\n";
	}
	else {
		cout << endl
			 << "New Balance: ";
		if (good.getBalance(fIn) > 0)
			cout << "+";
		cout << good.getBalance(fIn) << endl
			 << "New Market Price: $" << trunc1D(good.getMarketPrice(fIn)) << " ";
		if (good.getMarketPricePercent(fIn) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercent(fIn) * 100) << "%\n";
		if (good.getPopConsumption() != 0) {
			cout << "New Pop Consumption Costs: $" << trunc2D(good.getPopConsumption() * good.getMarketPrice(fIn)) << endl
				 << "Pop Consumption Profit: $" << trunc2D(good.getPopConsumption() * (good.getMarketPrice() - good.getMarketPrice(fIn))) << endl;
		}
		if (good.getInput(0) + good.getMilitaryConsumption() != 0) {
			cout << "New Subsidized Consumption Costs: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * good.getMarketPrice(fIn)) << endl
				 << "Subsidized Consumption Profit: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * (good.getMarketPrice() - good.getMarketPrice(fIn))) << endl;
		}
		cout << endl;
	}
	system("pause");
}

void production(goodsType good[GSIZE], float gdp, int i)
{
	float fIn;
	system("cls");

	goodData(good[i]);
	cout << "Enter Desired Sell Orders: ";
	cin >> fIn;

	if (!cin) {
		cin.clear();
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
		system("cls");
		cout << "Error invalid input\n\n";
		system("pause");
	}
	else if (fIn < 0) {
		system("cls");
		cout << "Error invalid input\n\n";
		system("pause");
	}
	else {
		int g[GSIZE];
		int choice;
		bool exit = false;
		float purchaseWeight[GSIZE];
		for (int j = 0; j < GSIZE; j++)
			purchaseWeight[j] = getPurchaseWeight(good, fIn, gdp, i, j);

		do {
			int k = 0;
			system("cls");

			for (int j = 0; j < GSIZE; j++) {
				if (good[j].getPopConsumptionChange(purchaseWeight[j]) != 0 && i != j) {
					g[k++] = j;
					cout << k << ". " << good[j].getGood() << endl;
				}
			}
			if (k > 0) {
				cout << ++k << ". " << good[i].getGood() << endl
					 << "0. Exit\n\n"
					 << "Enter your choice: ";
				cin >> choice;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error choose 0-" << k << endl << endl;
					system("pause");
				}
				else if (choice < 0 || choice > k) {
					system("cls");
					cout << "Error choose 0-" << k << endl << endl;
					system("pause");
				}
				else if (choice == 0)
					exit = true;
				else if (choice == k) {
					system("cls");
					goodData(good[i]);
					productionProfit(good[i], fIn, purchaseWeight[i]);
				}
				else {
					system("cls");
					goodData(good[g[choice - 1]]);
					productionProfit(good[g[choice - 1]], purchaseWeight[g[choice - 1]]);
				}
			}
			else {
				exit = true;
				goodData(good[i]);
				productionProfit(good[i], fIn, purchaseWeight[i]);
			}
		} while (!exit);
	}
}

void goodData(goodsType good)
{
	cout << good.getGood() << endl
		 << "Sell Orders: " << good.getSellOrders() << endl
		 << "Buy Orders: " << good.getBuyOrders() << endl
		 << "Balance: ";
	if (good.getBalance() > 0)
		cout << "+";
	cout << good.getBalance() << endl;
	if (!good.localGood()) {
		cout << "Market Price: $" << trunc1D(good.getMarketPrice()) << " ";
		if (good.getMarketPricePercent() > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercent() * 100) << "%\n";
	}
	if (good.hasWeight())
		cout << "Pop Consumption: " << good.getPopConsumption() << endl;
	if (!good.localGood()) {
		if (good.hasWeight())
			cout << "Pop Consumption Costs: $" << trunc2D(good.getPopConsumption() * good.getMarketPrice()) << endl;
		if (good.getInput(0) + good.getMilitaryConsumption() != 0) {
			cout << "Subsidized Consumption: " << good.getInput(0) + good.getMilitaryConsumption() << endl
				 << "Subsidized Consumption Costs: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * good.getMarketPrice()) << endl;
		}
	}
	cout << endl;
}

void productionProfit(goodsType good, float purchaseWeight)
{
	cout << "New Balance: ";
	if (good.getBalancePrediction(purchaseWeight) > 0)
		cout << "+";
	cout << good.getBalancePrediction(purchaseWeight) << endl;
	if (!good.localGood()) {
		cout << "New Market Price: $" << trunc1D(good.getMarketPricePrediction(purchaseWeight)) << " ";
		if (good.getMarketPricePercentPrediction(purchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercentPrediction(purchaseWeight) * 100) << "%\n";
	}
	if (good.hasWeight())
		cout << "New Pop Consumption: " << good.getPopConsumption(purchaseWeight) << endl;
	if (!good.localGood()) {
		if (good.hasWeight()) {
			cout << "New Pop Consumption Costs: $" << trunc2D(good.getPopConsumption(purchaseWeight) * good.getMarketPricePrediction(purchaseWeight)) << endl
				 << "Pop Consumption Profit: $" << trunc2D(good.getPopConsumption() * good.getMarketPrice() - good.getPopConsumption(purchaseWeight) * good.getMarketPricePrediction(purchaseWeight)) << endl;
		}
		if (good.getInput(0) + good.getMilitaryConsumption() != 0) {
			cout << "New Subsidized Consumption Costs: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * good.getMarketPricePrediction(purchaseWeight)) << endl
				 << "Subsidized Consumption Profit: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * (good.getMarketPrice() - good.getMarketPricePrediction(purchaseWeight))) << endl;
		}
	}
	cout << endl;
	system("pause");
}

void productionProfit(goodsType good, float output, float purchaseWeight)
{
	cout << "New Balance: ";
	if (good.getBalancePrediction(output, purchaseWeight) > 0)
		cout << "+";
	cout << good.getBalancePrediction(output, purchaseWeight) << endl;
	if (!good.localGood()) {
		cout << "New Market Price: $" << trunc1D(good.getMarketPricePrediction(output, purchaseWeight)) << " ";
		if (good.getMarketPricePercentPrediction(output, purchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercentPrediction(output, purchaseWeight) * 100) << "%\n";
	}
	if (good.hasWeight())
		cout << "New Pop Consumption: " << good.getPopConsumption(purchaseWeight) << endl;
	if (!good.localGood()) {
		if (good.hasWeight()) {
			cout << "New Pop Consumption Costs: $" << trunc2D(good.getPopConsumption(purchaseWeight) * good.getMarketPricePrediction(output, purchaseWeight)) << endl
				 << "Pop Consumption Profit: $" << trunc2D(good.getPopConsumption() * good.getMarketPrice() - good.getPopConsumption(purchaseWeight) * good.getMarketPricePrediction(output, purchaseWeight)) << endl;
		}
		if (good.getInput(0) + good.getMilitaryConsumption() != 0) {
			cout << "New Subsidized Consumption Costs: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * good.getMarketPricePrediction(output, purchaseWeight)) << endl
				 << "Subsidized Consumption Profit: $" << trunc2D((good.getInput(0) + good.getMilitaryConsumption()) * (good.getMarketPrice() - good.getMarketPricePrediction(output, purchaseWeight))) << endl;
		}
	}
	cout << endl;
	system("pause");
}

void stateMenu(goodsType good[GSIZE], buildingsType building[BSIZE], float& mapi, float& gdp)
{
	string in;
	char choice;
	float fIn;
	bool exit = false;

	do {
		char answer = '\0';
		system("cls");

		cout << "Market Access Price Impact: " << mapi * 100 << "%\n\n"
			 << "1. Save or Load State\n"
			 << "2. Set Market Access Price Impact\n"
			 << "3. Building Selection\n"
			 << "4. Local Market\n"
			 << "5. Reset Local Market Data\n"
			 << "6. Reset State Data\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				system("cls");
				cout << "Enter State: ";
				getline(cin, in);
				stateData(good, building, mapi, gdp, in);
				break;
			case '2':
				system("cls");
				cout << "Enter Market Access Price Impact (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0 || fIn > 100) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					mapi = trunc(fIn) / 100;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '3':
				selectBuilding(building);
				break;
			case '4':
				localMarket(good, mapi);
				break;
			case '5':
				do {
					system("cls");
					cout << "Confirm Local Market Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 0; i < GSIZE; i++) {
								good[i].setProduction(0);
								good[i].setConsumption(0);
							}
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			case '6':
				do {
					system("cls");
					cout << "Confirm State Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 0; i < GSIZE; i++) {
								good[i].setProduction(0);
								good[i].setConsumption(0);
								good[i].setThroughput(0);
							}
							for (int i = 0; i < BSIZE - 1; i++) {
								for (int j = 0; j < 7; j++)
									building[i].setThroughput(0, j);
								building[i].setBaseWage(0);
							}
							mapi = 0.75;
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			default:
				system("cls");
				cout << "Error choose 0-6\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-6\n\n";
			system("pause");
		}
	} while (!exit);
}

void stateMenu(goodsType good[GSIZE], buildingsType building[BSIZE], float& mapi, float& gdp, float averageGdp)
{
	string in;
	char choice;
	float fIn;
	bool exit = false;

	do {
		char answer = '\0';
		system("cls");

		cout << "Market Access Price Impact: " << mapi * 100 << "%\n"
			 << "State Percentage of Market GDP: " << gdp * 100 << "%\n\n"
			 << "1. Save or Load State\n"
			 << "2. Set Market Access Price Impact\n"
			 << "3. Set State Percentage of Market GDP\n"
			 << "4. Building Selection\n"
			 << "5. Local Market\n"
			 << "6. Reset Local Market Data\n"
			 << "7. Reset State Data\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				system("cls");
				cout << "Enter State: ";
				getline(cin, in);
				stateData(good, building, mapi, gdp, in);
				break;
			case '2':
				system("cls");
				cout << "Enter Market Access Price Impact (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0 || fIn > 100) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					mapi = trunc(fIn) / 100;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '3':
				system("cls");
				cout << "Enter State Percentage of Market GDP (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0 || fIn > 100) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					gdp = trunc1D(fIn) / 100;
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '4':
				selectBuilding(building);
				break;
			case '5':
				localMarket(good, mapi, gdp, averageGdp);
				break;
			case '6':
				do {
					system("cls");
					cout << "Confirm Local Market Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 0; i < GSIZE; i++) {
								good[i].setProduction(0);
								good[i].setConsumption(0);
								good[i].setLocalPopConsumption(0);
							}
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			case '7':
				do {
					system("cls");
					cout << "Confirm State Data Reset (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							for (int i = 0; i < GSIZE; i++) {
								good[i].setProduction(0);
								good[i].setConsumption(0);
								good[i].setLocalPopConsumption(0);
								good[i].setThroughput(0);
								good[i].setLocalObsession(0);
								good[i].setLocalTaboo(0);
							}
							for (int i = 0; i < BSIZE - 1; i++) {
								for (int j = 0; j < 7; j++)
									building[i].setThroughput(0, j);
								building[i].setBaseWage(0);
							}
							mapi = 0.75;
							gdp = 1;
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			default:
				system("cls");
				cout << "Error choose 0-7\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-7\n\n";
			system("pause");
		}
	} while (!exit);
}

void stateData(goodsType good[GSIZE], buildingsType building[BSIZE], float& mapi, float& gdp, string state)
{
	float production = 0;
	float consumption = 0;
	float popConsumption = 0;
	float throughput = 0;
	float obsession = 0;
	float taboo = 0;
	float wage = 0;
	string in;
	char choice;
	char answer = '\0';
	bool exit = false;
	ifstream inFile;
	ofstream outFile;

	do {
		system("cls");

		cout << state << endl << endl
			 << "1. Save State\n"
			 << "2. Load State\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				exit = true;
				do {
					system("cls");
					cout << "Confirm Save State Data to " + state + " (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\States\\" + state + ".txt");
							for (int i = 0; i < GSIZE; i++) {
								outFile << good[i].getProduction() << endl
										<< good[i].getConsumption() << endl
										<< good[i].getLocalPopConsumption() << endl
										<< good[i].getThroughput() << endl
										<< good[i].getLocalObsession() << endl
										<< good[i].getLocalTaboo() << endl;
							}
							for (int i = 0; i < BSIZE - 1; i++) {
								for (int j = 0; j < 7; j++)
									outFile << building[i].getThroughput(j) << endl;
								outFile << building[i].getBaseWage() << endl;
							}
							outFile << mapi << endl
									<< gdp;
							outFile.close();
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			case '2':
				exit = true;
				do {
					system("cls");
					cout << "Confirm Loading " + state + " (y/n): ";
					getline(cin, in);
					if (in.length() == 1) {
						answer = in[0];

						if (toupper(answer) == 'Y') {
							inFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\States\\" + state + ".txt");
							for (int i = 0; i < GSIZE; i++) {
								inFile >> production
									   >> consumption
									   >> popConsumption
									   >> throughput
									   >> obsession
									   >> taboo;
								good[i].setProduction(production);
								good[i].setConsumption(consumption);
								good[i].setLocalPopConsumption(popConsumption);
								good[i].setThroughput(throughput);
								good[i].setLocalObsession(obsession);
								good[i].setLocalTaboo(taboo);
							}
							for (int i = 0; i < BSIZE - 1; i++) {
								for (int j = 0; j < 7; j++) {
									inFile >> throughput;
									building[i].setThroughput(throughput, j);
								}
								inFile >> wage;
								building[i].setBaseWage(wage);
							}
							inFile >> mapi
								   >> gdp;
							inFile.close();
						}
						else if (toupper(answer) != 'N') {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
					}
					else {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
				} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
				break;
			default:
				system("cls");
				cout << "Error choose 0-2\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-2\n\n";
			system("pause");
		}
	} while (!exit);
}

void selectBuilding(buildingsType building[BSIZE])
{
	int choice;
	bool exit = false;

	do {
		system("cls");

		cout << "Buildings\n\n";
		for (int i = 0; i < BSIZE - 1; i++) {
			if (i < 9)
				cout << " ";
			cout << i + 1 << ". " << building[i].getBuilding() << endl;
		}
		cout << endl << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << BSIZE - 1 << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > BSIZE - 1) {
			system("cls");
			cout << "Error choose 0-" << BSIZE - 1 << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else {
			stateBuildingData(building, choice - 1);
		}
	} while (!exit);
}

void stateBuildingData(buildingsType building[BSIZE], int it)
{
	bool eosOverride = false;
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << building[it].getBuilding() << " Throughput overrides Economy of Scale: ";
		if (eosOverride)
			cout << "yes";
		else {
			cout << "no";
		}
		cout << endl
			 << building[it].getBuilding() << " Throughput after One Construction: " << trunc1D(building[it].getThroughput(0) * 100) << "%\n"
			 << building[it].getBuilding() << " Throughput: ";
		if (eosOverride)
			cout << trunc1D(building[it].getThroughput(1) * 100);
		else {
			cout << trunc1D(building[it].getThroughput(3) * 100);
			if (building[it].buildable() && !building[it].autoSubsidized()) {
				cout << "%\n"
					 << building[it].getBuilding() << " Company Throughput: " << trunc1D(building[it].getThroughput(5) * 100);
			}
		}
		cout << "%\n"
			 << building[it].getBuilding() << " New Throughput: ";
		if (eosOverride)
			cout << trunc1D(building[it].getThroughput(2) * 100);
		else {
			cout << trunc1D(building[it].getThroughput(4) * 100);
			if (building[it].buildable() && !building[it].autoSubsidized()) {
				cout << "%\n"
					 << building[it].getBuilding() << " New Company Throughput: " << trunc1D(building[it].getThroughput(6) * 100);
			}
		}
		int i = 4;
		cout << "%\n"
			 << "Base Wage: $" << building[it].getBaseWage() << endl << endl
			 << "1. Toggle Economy of Scale Override\n"
			 << "2. Set " << building[it].getBuilding() << " Throughput after One Construction\n"
			 << "3. Set " << building[it].getBuilding() << " Throughput\n";
		if (!eosOverride && building[it].buildable() && !building[it].autoSubsidized())
			cout << i++ << ". Set " << building[it].getBuilding() << " Company Throughput\n";
		cout << i++ << ". Set " << building[it].getBuilding() << " New Throughput\n";
		if (!eosOverride && building[it].buildable() && !building[it].autoSubsidized())
			cout << i++ << ". Set " << building[it].getBuilding() << " New Company Throughput\n";
		cout << i << ". Set Base Wage\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			if (eosOverride)
				eosOverride = false;
			else {
				eosOverride = true;
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter " << building[it].getBuilding() << " Throughput after One Construction (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				building[it].setThroughput(fIn / 100, 0);
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter " << building[it].getBuilding() << " Throughput (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (eosOverride) {
				building[it].setThroughput(fIn / 100, 1);
				building[it].setThroughput(building[it].getThroughput(1), 2);
			}
			else {
				building[it].setThroughput(fIn / 100, 3);
				building[it].setThroughput(building[it].getThroughput(3), 4);
			}
		}
		else if (choice == i) {
			system("cls");
			cout << "Enter Base Wage: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				building[it].setBaseWage(fIn);
			}
		}
		else if (!eosOverride && building[it].buildable() && !building[it].autoSubsidized()) {
			if (choice == --i) {
				system("cls");
				cout << "Enter " << building[it].getBuilding() << " New Company Throughput (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					building[it].setThroughput(fIn / 100, 6);
				}
			}
			else if (choice == --i) {
				system("cls");
				cout << "Enter " << building[it].getBuilding() << " New Throughput (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (eosOverride)
					building[it].setThroughput(fIn / 100, 2);
				else {
					building[it].setThroughput(fIn / 100, 4);
				}
			}
			else {
				system("cls");
				cout << "Enter " << building[it].getBuilding() << " Company Throughput (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					building[it].setThroughput(fIn / 100, 5);
					building[it].setThroughput(building[it].getThroughput(5), 6);
				}
			}
		}
		else {
			system("cls");
			cout << "Enter " << building[it].getBuilding() << " New Throughput (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (eosOverride)
				building[it].setThroughput(fIn / 100, 2);
			else {
				building[it].setThroughput(fIn / 100, 4);
			}
		}
	} while (!exit);
}

void localMarket(goodsType good[GSIZE], float mapi)
{
	int it[GSIZE];
	for (int i = 0; i < GSIZE; i++)
		it[i] = i;
	int sorted = 1;
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << "Local Market\n"
			 << " 1. Sort"
			 << "                                                2. Sort"
			 << "           3. Sort"
			 << "          4. Sort"
			 << "   5. Sort\n"
			 << "                         Production"
			 << "     Consumption"
			 << "     Balance"
			 << "     Local Price"
			 << "     Market Price"
			 << "     Value\n";
		for (int i = 0; i < GSIZE; i++) {
			if (i < 4)
				cout << " ";
			cout << i + 6 << ". " << left << setw(21) << good[it[i]].getGood()
				 << left << setw(15) << trunc(good[it[i]].getProduction())
				 << left << setw(16) << trunc(good[it[i]].getConsumption());
			if (good[it[i]].getStateBalance() > 0)
				cout << "+" << left << setw(11);
			else {
				cout << left << setw(12);
			}
			cout << good[it[i]].getStateBalance()
				 << "$" << left << setw(5);
			if (good[it[i]].localGood()) {
				cout << trunc(good[it[i]].getMarketPrice());
				if (good[it[i]].getMarketPricePercent() > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getMarketPricePercent() * 100);
			}
			else {
				cout << trunc(good[it[i]].getLocalPrice(mapi));
				if (good[it[i]].getLocalPricePercent(mapi) > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getLocalPricePercent(mapi) * 100)
					 << left << setw(6) << "%"
					 << "$" << left << setw(6) << trunc(good[it[i]].getMarketPrice());
				if (good[it[i]].getMarketPricePercent() > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getMarketPricePercent() * 100)
					 << left << setw(6) << "%";
				if (good[it[i]].getLocalPricePercent(0) > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getLocalPricePercent(0) * 100);
			}
			cout << "%\n";
		}
		cout << endl << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << GSIZE + 5 << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > GSIZE + 5) {
			system("cls");
			cout << "Error choose 0-" << GSIZE + 5 << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else if (choice == 1) {
			sorted = choice;
			for (int i = 0; i < GSIZE; i++)
				it[i] = i;
		}
		else if (choice == 2) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					for (;j >= 0 && good[i].getStateBalance() > good[it[j]].getStateBalance(); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					for (;j >= 0 && good[i].getStateBalance() < good[it[j]].getStateBalance(); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 3) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(mapi);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(mapi);
					}
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(mapi);
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(mapi);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(mapi);
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(mapi);
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 4) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key = 1;
					if (!good[i].localGood())
						key = good[i].getMarketPricePercent();
					float value = 1;
					if (!good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = 1;
							else {
								value = good[it[j]].getMarketPricePercent();
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key = -1;
					if (!good[i].localGood())
						key = good[i].getMarketPricePercent();
					float value = -1;
					if (!good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = -1;
							else {
								value = good[it[j]].getMarketPricePercent();
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 5) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(0);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(0);
					}
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(0);
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(0);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(0);
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(0);
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (good[it[choice - 6]].getGood() == "Gold") {
			system("cls");
			cout << "Enter Local Gold Production: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0 || fIn > good[it[choice - 6]].getSellOrders()) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[it[choice - 6]].setProduction(fIn);
				sorted = 1;
				for (int i = 0; i < GSIZE; i++)
					it[i] = i;
			}
		}
		else {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			localBalance(good, mapi, it[choice - 6]);
			sorted = 1;
			for (int i = 0; i < GSIZE; i++)
				it[i] = i;
		}
	} while (!exit);
}

void localMarket(goodsType good[GSIZE], float mapi, float gdp, float averageGdp)
{
	int it[GSIZE];
	for (int i = 0; i < GSIZE; i++)
		it[i] = i;
	int sorted = 1;
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << "Local Market\n"
			 << " 1. Sort"
			 << "                                                2. Sort"
			 << "           3. Sort"
			 << "          4. Sort"
			 << "   5. Sort\n"
			 << "                         Production"
			 << "     Consumption"
			 << "     Balance"
			 << "     Local Price"
			 << "     Market Price"
			 << "     Value\n";
		for (int i = 0; i < GSIZE; i++) {
			if (i < 4)
				cout << " ";
			cout << i + 6 << ". " << left << setw(21) << good[it[i]].getGood()
				 << left << setw(15) << trunc(good[it[i]].getProduction())
				 << left << setw(16) << trunc(good[it[i]].getConsumption());
			if (good[it[i]].getStateBalance() > 0)
				cout << "+" << left << setw(11);
			else {
				cout << left << setw(12);
			}
			cout << good[it[i]].getStateBalance()
				 << "$" << left << setw(5);
			if (good[it[i]].localGood()) {
				cout << trunc(good[it[i]].getMarketPrice());
				if (good[it[i]].getMarketPricePercent() > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getMarketPricePercent() * 100);
			}
			else {
				cout << trunc(good[it[i]].getLocalPrice(mapi));
				if (good[it[i]].getLocalPricePercent(mapi) > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getLocalPricePercent(mapi) * 100)
					 << left << setw(6) << "%"
					 << "$" << left << setw(6) << trunc(good[it[i]].getMarketPrice());
				if (good[it[i]].getMarketPricePercent() > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getMarketPricePercent() * 100)
					 << left << setw(6) << "%";
				if (good[it[i]].getLocalPricePercent(0) > 0)
					cout << "+" << left << setw(3);
				else {
					cout << left << setw(4);
				}
				cout << trunc(good[it[i]].getLocalPricePercent(0) * 100);
			}
			cout << "%\n";
		}
		cout << endl << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << GSIZE + 5 << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > GSIZE + 5) {
			system("cls");
			cout << "Error choose 0-" << GSIZE + 5 << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else if (choice == 1) {
			sorted = choice;
			for (int i = 0; i < GSIZE; i++)
				it[i] = i;
		}
		else if (choice == 2) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					for (;j >= 0 && good[i].getStateBalance() > good[it[j]].getStateBalance(); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					for (;j >= 0 && good[i].getStateBalance() < good[it[j]].getStateBalance(); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 3) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(mapi);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(mapi);
					}
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(mapi);
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(mapi);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(mapi);
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(mapi);
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 4) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key = 1;
					if (!good[i].localGood())
						key = good[i].getMarketPricePercent();
					float value = 1;
					if (!good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = 1;
							else {
								value = good[it[j]].getMarketPricePercent();
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key = -1;
					if (!good[i].localGood())
						key = good[i].getMarketPricePercent();
					float value = -1;
					if (!good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = -1;
							else {
								value = good[it[j]].getMarketPricePercent();
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (choice == 5) {
			it[0] = 0;
			if (sorted == choice) {
				sorted = 1;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(0);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(0);
					}
					while (j >= 0 && key < value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(0);
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sorted = choice;
				for (int i = 1; i < GSIZE; i++) {
					int j = i - 1;
					float key;
					if (good[i].localGood())
						key = good[i].getMarketPricePercent();
					else {
						key = good[i].getLocalPricePercent(0);
					}
					float value;
					if (good[it[j]].localGood())
						value = good[it[j]].getMarketPricePercent();
					else {
						value = good[it[j]].getLocalPricePercent(0);
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (good[it[j]].localGood())
								value = good[it[j]].getMarketPricePercent();
							else {
								value = good[it[j]].getLocalPricePercent(0);
							}
						}
					}
					it[j + 1] = i;
				}
			}
		}
		else if (good[it[choice - 6]].getGood() == "Gold") {
			system("cls");
			cout << "Enter Local Gold Production: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0 || fIn > good[it[choice - 6]].getSellOrders()) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[it[choice - 6]].setProduction(fIn);
				sorted = 1;
				for (int i = 0; i < GSIZE; i++)
					it[i] = i;
			}
		}
		else {
			localBalance(good, mapi, gdp, averageGdp, it[choice - 6]);
			sorted = 1;
			for (int i = 0; i < GSIZE; i++)
				it[i] = i;
		}
	} while (!exit);
}

void localBalance(goodsType good[GSIZE], float mapi, int i)
{
	string in;
	char choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << good[i].getGood() << endl
			 << "Production: " << good[i].getProduction() << endl
			 << "Consumption: " << good[i].getConsumption() << endl
			 << "Output Bonus: " << trunc1D(good[i].getThroughput() * 100) << "%\n"
			 << "Balance: ";
		if (good[i].getStateBalance() > 0)
			cout << "+";
		cout << good[i].getStateBalance() << endl;
		if (good[i].localGood())
			cout << "Local Price: $";
		else {
			cout << "Local Value: ";
			if (good[i].getLocalPricePercent(0) > 0)
				cout << "+";
			cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n"
				 << "Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
			if (good[i].getLocalPricePercent(mapi) > 0)
				cout << "+";
			cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%\n"
				 << "Market Price: $";
		}
		cout << trunc1D(good[i].getMarketPrice()) << " ";
		if (good[i].getMarketPricePercent() > 0)
			cout << "+";
		cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n\n"
			 << "1. Set Local Production\n"
			 << "2. Set Local Consumption\n"
			 << "3. Set " << good[i].getGood() << " Output Bonus\n"
			 << "4. Production\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		getline(cin, in);
		if (in.length() == 1) {
			choice = in[0];
			switch (choice) {
			case '0':
				exit = true;
				break;
			case '1':
				system("cls");
				cout << "Enter Local Production: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					good[i].setProduction(fIn);
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '2':
				system("cls");
				cout << "Enter Local Consumption: ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (fIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					if (fIn < good[i].getLocalPopConsumption())
						good[i].setLocalPopConsumption(fIn);
					good[i].setConsumption(fIn);
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '3':
				system("cls");
				cout << "Enter " << good[i].getGood() << " Output Bonus (%): ";
				cin >> fIn;

				if (!cin) {
					cin.clear();
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					good[i].setThroughput(fIn / 100);
				}
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				break;
			case '4':
				production(good[i], mapi);
				break;
			default:
				system("cls");
				cout << "Error choose 0-4\n\n";
				system("pause");
			}
		}
		else {
			system("cls");
			cout << "Error choose 0-4\n\n";
			system("pause");
		}
	} while (!exit);
}

void localBalance(goodsType good[GSIZE], float mapi, float gdp, float averageGdp, int i)
{
	int choice;
	float fIn;
	bool exit = false;

	do {
		system("cls");

		cout << good[i].getGood() << endl
			 << "Production: " << good[i].getProduction() << endl
			 << "Consumption: " << good[i].getConsumption() << endl;
		if (good[i].hasWeight())
			cout << "Pop Consumption: " << good[i].getLocalPopConsumption() << endl;
		cout << "Output Bonus: " << trunc1D(good[i].getThroughput() * 100) << "%\n"
			 << "Pop Percentage with Obsession: " << good[i].getLocalObsession() * 100 << "%\n"
			 << "Pop Percentage with Taboo: " << good[i].getLocalTaboo() * 100 << "%\n"
			 << "Balance: ";
		if (good[i].getStateBalance() > 0)
			cout << "+";
		cout << good[i].getStateBalance() << endl;
		if (good[i].localGood())
			cout << "Local Price: $";
		else {
			cout << "Local Value: ";
			if (good[i].getLocalPricePercent(0) > 0)
				cout << "+";
			cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n"
				 << "Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
			if (good[i].getLocalPricePercent(mapi) > 0)
				cout << "+";
			cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%\n"
				 << "Market Price: $";
		}
		cout << trunc1D(good[i].getMarketPrice()) << " ";
		if (good[i].getMarketPricePercent() > 0)
			cout << "+";
		cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n\n";
		int j = 3;
		cout << "1. Set Local Production\n"
			 << "2. Set Local Consumption\n";
		if (good[i].hasWeight())
			cout << j++ << ". Set Pop Consumption\n";
		cout << j++ << ". Set " << good[i].getGood() << " Output Bonus\n";
		cout << j++ << ". Set Pop Percentage with Obsession\n";
		cout << j++ << ". Set Pop Percentage with Taboo\n"
			 << j << ". Production\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << j << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > j) {
			system("cls");
			cout << "Error choose 0-" << j << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			cout << "Enter Local Production: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[i].setProduction(fIn);
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Local Consumption: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn < good[i].getLocalPopConsumption())
					good[i].setLocalPopConsumption(fIn);
				good[i].setConsumption(fIn);
			}
		}
		else if (choice == j--)
			production(good, mapi, gdp, averageGdp, i);
		else if (choice == j--) {
			system("cls");
			cout << "Enter Pop Percentage with Taboo (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0 || fIn > 100) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[i].setLocalTaboo(trunc1D(fIn) / 100);
			}
		}
		else if (choice == j--) {
			system("cls");
			cout << "Enter Pop Percentage with Obsession (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0 || fIn > 100) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[i].setLocalObsession(trunc1D(fIn) / 100);
			}
		}
		else if (choice == j) {
			system("cls");
			cout << "Enter " << good[i].getGood() << " Output Bonus (%): ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				good[i].setThroughput(fIn / 100);
			}
		}
		else {
			system("cls");
			cout << "Enter Pop Consumption: ";
			cin >> fIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (fIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (fIn > good[i].getConsumption())
					good[i].setConsumption(fIn);
				good[i].setLocalPopConsumption(fIn);
			}
		}
	} while (!exit);
}

void production(goodsType good, float mapi)
{
	float fIn;
	system("cls");

	cout << good.getGood() << endl
		 << "Production: " << good.getProduction() << endl
		 << "Consumption: " << good.getConsumption() << endl
		 << "Balance: ";
	if (good.getStateBalance() > 0)
		cout << "+";
	cout << good.getStateBalance() << endl;
	if (good.localGood())
		cout << "Local Price: $";
	else {
		cout << "Local Value: ";
		if (good.getLocalPricePercent(0) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercent(0) * 100) << "%\n"
			 << "Local Price: $" << trunc1D(good.getLocalPrice(mapi)) << " ";
		if (good.getLocalPricePercent(mapi) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercent(mapi) * 100) << "%\n"
			 << "Market Price: $";
	}
	cout << trunc1D(good.getMarketPrice()) << " ";
	if (good.getMarketPricePercent() > 0)
		cout << "+";
	cout << trunc(good.getMarketPricePercent() * 100) << "%\n\n"
		 << "Enter Desired Local Production: ";
	cin >> fIn;

	if (!cin) {
		cin.clear();
		system("cls");
		cout << "Error invalid input\n\n";
	}
	else if (fIn < 0) {
		system("cls");
		cout << "Error invalid input\n\n";
	}
	else {
		cout << endl
			 << "New Balance: ";
		if (good.getStateBalance(fIn) > 0)
			cout << "+";
		cout << good.getStateBalance(fIn) << endl;
		if (good.localGood())
			cout << "New Local Price: $";
		else {
			cout << "New Local Value: ";
			if (good.getLocalPricePercent(0, fIn) > 0)
				cout << "+";
			cout << trunc(good.getLocalPricePercent(0, fIn) * 100) << "%\n"
				 << "New Local Price: $" << trunc1D(good.getLocalPrice(mapi, fIn)) << " ";
			if (good.getLocalPricePercent(mapi, fIn) > 0)
				cout << "+";
			cout << trunc(good.getLocalPricePercent(mapi, fIn) * 100) << "%\n"
				 << "New Market Price: $";
			fIn += good.getSellOrders() - good.getProduction();
		}
		cout << trunc1D(good.getMarketPrice(fIn)) << " ";
		if (good.getMarketPricePercent(fIn) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercent(fIn) * 100) << "%\n\n";
	}
	cin.ignore(numeric_limits<streamsize>::max(), '\n');
	system("pause");
}

void production(goodsType good[GSIZE], float mapi, float gdp, float averageGdp, int i)
{
	float fIn;
	system("cls");

	goodData(good[i], mapi);
	cout << "Enter Desired Local Production: ";
	cin >> fIn;

	if (!cin) {
		cin.clear();
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
		system("cls");
		cout << "Error invalid input\n\n";
		system("pause");
	}
	else if (fIn < 0) {
		system("cls");
		cout << "Error invalid input\n\n";
		system("pause");
	}
	else {
		int g[GSIZE];
		int choice;
		bool exit = false;
		float purchaseWeight[GSIZE];
		float localPurchaseWeight[GSIZE];
		for (int j = 0; j < GSIZE; j++) {
			purchaseWeight[j] = getPurchaseWeightLocalOutput(good, fIn, averageGdp, i, j);
			localPurchaseWeight[j] = getLocalPurchaseWeight(good, fIn, gdp, i, j);
		}
		do {
			int k = 0;
			system("cls");

			for (int j = 0; j < GSIZE; j++) {
				if (i != j) {
					if (good[j].localGood()) {
						if (good[j].getLocalPopConsumptionChange(localPurchaseWeight[j]) != 0) {
							g[k++] = j;
							cout << k << ". " << good[j].getGood() << endl;
						}
					}
					else if (good[j].getPopConsumptionChange(purchaseWeight[j]) != 0) {
						g[k++] = j;
						cout << k << ". " << good[j].getGood() << endl;
					}
				}
			}
			if (k > 0) {
				cout << ++k << ". " << good[i].getGood() << endl
					 << "0. Exit\n\n"
					 << "Enter your choice: ";
				cin >> choice;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error choose 0-" << k << endl << endl;
					system("pause");
				}
				else if (choice < 0 || choice > k) {
					system("cls");
					cout << "Error choose 0-" << k << endl << endl;
					system("pause");
				}
				else if (choice == 0)
					exit = true;
				else if (choice == k) {
					system("cls");
					goodData(good[i], mapi);
					productionProfit(good[i], mapi, fIn, purchaseWeight[i], localPurchaseWeight[i]);
				}
				else {
					system("cls");
					goodData(good[g[choice - 1]], mapi);
					productionProfit(good[g[choice - 1]], mapi, purchaseWeight[g[choice - 1]], localPurchaseWeight[g[choice - 1]]);
				}
			}
			else {
				exit = true;
				goodData(good[i], mapi);
				productionProfit(good[i], mapi, fIn, purchaseWeight[i], localPurchaseWeight[i]);
			}
		} while (!exit);
	}
}

void goodData(goodsType good, float mapi)
{
	cout << good.getGood() << endl
		 << "Production: " << good.getProduction() << endl
		 << "Consumption: " << good.getConsumption() << endl
		 << "Balance: ";
	if (good.getStateBalance() > 0)
		cout << "+";
	cout << good.getStateBalance() << endl;
	if (good.localGood())
		cout << "Local Price: $";
	else {
		cout << "Local Value: ";
		if (good.getLocalPricePercent(0) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercent(0) * 100) << "%\n"
			 << "Local Price: $" << trunc1D(good.getLocalPrice(mapi)) << " ";
		if (good.getLocalPricePercent(mapi) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercent(mapi) * 100) << "%\n"
			 << "Market Price: $";
	}
	cout << trunc1D(good.getMarketPrice()) << " ";
	if (good.getMarketPricePercent() > 0)
		cout << "+";
	cout << trunc(good.getMarketPricePercent() * 100) << "%\n";
	if (good.hasWeight())
		cout << "Pop Consumption: " << good.getLocalPopConsumption() << endl;
	cout << endl;
}

void productionProfit(goodsType good, float mapi, float purchaseWeight, float localPurchaseWeight)
{
	cout << "New Balance: ";
	if (good.getStateBalancePrediction(localPurchaseWeight) > 0)
		cout << "+";
	cout << good.getStateBalancePrediction(localPurchaseWeight) << endl;
	if (good.localGood()) {
		cout << "New Local Price: $" << trunc1D(good.getMarketPricePrediction(localPurchaseWeight)) << " ";
		if (good.getMarketPricePercentPrediction(localPurchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercentPrediction(localPurchaseWeight) * 100);
	}
	else {
		cout << "New Local Value: ";
		if (good.getLocalPricePercentPrediction(0, purchaseWeight, localPurchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercentPrediction(0, purchaseWeight, localPurchaseWeight) * 100) << "%\n"
			 << "New Local Price: $" << trunc1D(good.getLocalPricePrediction(mapi, purchaseWeight, localPurchaseWeight)) << " ";
		if (good.getLocalPricePercentPrediction(mapi, purchaseWeight, localPurchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercentPrediction(mapi, purchaseWeight, localPurchaseWeight) * 100) << "%\n"
			 << "New Market Price: $" << trunc1D(good.getMarketPricePrediction(purchaseWeight)) << " ";
		if (good.getMarketPricePercentPrediction(purchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercentPrediction(purchaseWeight) * 100);
	}
	cout << "%\n";
	if (good.hasWeight())
		cout << "New Pop Consumption: " << good.getLocalPopConsumption(localPurchaseWeight) << endl;
	cout << endl;
	system("pause");
}

void productionProfit(goodsType good, float mapi, float output, float purchaseWeight, float localPurchaseWeight)
{
	cout << "New Balance: ";
	if (good.getStateBalancePrediction(output, localPurchaseWeight) > 0)
		cout << "+";
	cout << good.getStateBalancePrediction(output, localPurchaseWeight) << endl;
	if (good.localGood()) {
		cout << "New Local Price: $" << trunc1D(good.getMarketPricePrediction(output, localPurchaseWeight)) << " ";
		if (good.getMarketPricePercentPrediction(output, localPurchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercentPrediction(output, localPurchaseWeight) * 100);
	}
	else {
		cout << "New Local Value: ";
		if (good.getLocalPricePercentPrediction(0, output, purchaseWeight, localPurchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercentPrediction(0, output, purchaseWeight, localPurchaseWeight) * 100) << "%\n"
			 << "New Local Price: $" << trunc1D(good.getLocalPricePrediction(mapi, output, purchaseWeight, localPurchaseWeight)) << " ";
		if (good.getLocalPricePercentPrediction(mapi, output, purchaseWeight, localPurchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getLocalPricePercentPrediction(mapi, output, purchaseWeight, localPurchaseWeight) * 100) << "%\n";
		output += good.getSellOrders() - good.getProduction();
		cout << "New Market Price: $" << trunc1D(good.getMarketPricePrediction(output, purchaseWeight)) << " ";
		if (good.getMarketPricePercentPrediction(output, purchaseWeight) > 0)
			cout << "+";
		cout << trunc(good.getMarketPricePercentPrediction(output, purchaseWeight) * 100);
	}
	cout << "%\n";
	if (good.hasWeight())
		cout << "New Pop Consumption: " << good.getLocalPopConsumption(localPurchaseWeight) << endl;
	cout << endl;
	system("pause");
}

void buildings(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	bool cancel = false;
	int it[BSIZE - 1];
	for (int i = 0; i < BSIZE - 1; i++)
		it[i] = i;
	int choice;
	bool exit = false;

	do {
		system("cls");

		cout << "Buildings\n"
			 << " 1. Toggle Imports: ";
		if (cancel) {
			cout << "yes\n"
				 << " 2. Sort"
				 << "                           3. Sort"
				 << "         4. Sort"
				 << "               5. Sort"
				 << "                6. Sort\n"
				 << "                                   Profit"
				 << "          Productivity"
				 << "          Profitability"
				 << "          Productivity/Construction\n";
			for (int i = 0; i < BSIZE - 1; i++) {
				if (i < 3)
					cout << " ";
				cout << i + 7 << ". " << left << setw(31) << building[it[i]].getBuilding()
					 << "$" << left << setw(15) << trunc2D(profitImportsCanceled(good, method, building, location, mapi, mobilization, it[i]))
					 << "$";
				if (building[it[i]].buildable())
					cout << left << setw(21);
				cout << trunc2D(productivityImportsCanceled(good, method, building, location, mapi, mobilization, it[i]));
				if (building[it[i]].buildable()) {
					if (profitImportsCanceled(good, method, building, location, mapi, mobilization, it[i]) < 0)
						cout << left << setw(23) << "$0";
					else {
						cout << "$" << left << setw(22) << trunc2D(20 * profitImportsCanceled(good, method, building, location, mapi, mobilization, it[i]) / building[it[i]].getConstructionCost());
					}
					cout << "$" << trunc2D(500 * productivityImportsCanceled(good, method, building, location, mapi, mobilization, it[i]) / building[it[i]].getConstructionCost());
				}
				cout << endl;
			}
			cout << endl << "Enter your choice (0 to quit): ";
			cin >> choice;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice < 0 || choice > BSIZE + 5) {
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice == 0) {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				exit = true;
			}
			else if (choice == 1) {
				if (cancel)
					cancel = false;
				else {
					cancel = true;
				}
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 2) {
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 3) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && profitImportsCanceled(good, method, building, location, mapi, mobilization, i) > profitImportsCanceled(good, method, building, location, mapi, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && productivityImportsCanceled(good, method, building, location, mapi, mobilization, i) > productivityImportsCanceled(good, method, building, location, mapi, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = 0;
					if (building[i].buildable()) {
						if (profitImportsCanceled(good, method, building, location, mapi, mobilization, i) > 0)
							key = profitImportsCanceled(good, method, building, location, mapi, mobilization, i) / building[i].getConstructionCost();
					}
					else {
						key = -1;
					}
					float value = 0;
					if (building[it[j]].buildable()) {
						if (profitImportsCanceled(good, method, building, location, mapi, mobilization, it[j]) > 0)
							value = profitImportsCanceled(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
					}
					else {
						value = -1;
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable()) {
								if (profitImportsCanceled(good, method, building, location, mapi, mobilization, it[j]) > 0)
									value = profitImportsCanceled(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
								else {
									value = 0;
								}
							}
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else if (choice == 6) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = -1;
					if (building[i].buildable())
						key = productivityImportsCanceled(good, method, building, location, mapi, mobilization, i) / building[i].getConstructionCost();
					float value = -1;
					if (building[it[j]].buildable())
						value = productivityImportsCanceled(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable())
								value = productivityImportsCanceled(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sectorsImportsCanceled(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, it[choice - 7]);
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
		}
		else {
			cout << "no\n"
				 << " 2. Sort"
				 << "                           3. Sort"
				 << "         4. Sort"
				 << "               5. Sort"
				 << "                6. Sort\n"
				 << "                                   Profit"
				 << "          Productivity"
				 << "          Profitability"
				 << "          Productivity/Construction\n";
			for (int i = 0; i < BSIZE - 1; i++) {
				if (i < 3)
					cout << " ";
				cout << i + 7 << ". " << left << setw(31) << building[it[i]].getBuilding()
					 << "$" << left << setw(15) << trunc2D(profit(good, method, building, location, mapi, mobilization, it[i]))
					 << "$";
				if (building[it[i]].buildable())
					cout << left << setw(21);
				cout << trunc2D(productivity(good, method, building, location, mapi, mobilization, it[i]));
				if (building[it[i]].buildable()) {
					if (profit(good, method, building, location, mapi, mobilization, it[i]) < 0)
						cout << left << setw(23) << "$0";
					else {
						cout << "$" << left << setw(22) << trunc2D(20 * profit(good, method, building, location, mapi, mobilization, it[i]) / building[it[i]].getConstructionCost());
					}
					cout << "$" << trunc2D(500 * productivity(good, method, building, location, mapi, mobilization, it[i]) / building[it[i]].getConstructionCost());
				}
				cout << endl;
			}
			cout << endl << "Enter your choice (0 to quit): ";
			cin >> choice;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice < 0 || choice > BSIZE + 5) {
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice == 0) {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				exit = true;
			}
			else if (choice == 1) {
				if (cancel)
					cancel = false;
				else {
					cancel = true;
				}
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 2) {
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 3) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && profit(good, method, building, location, mapi, mobilization, i) > profit(good, method, building, location, mapi, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && productivity(good, method, building, location, mapi, mobilization, i) > productivity(good, method, building, location, mapi, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = 0;
					if (building[i].buildable()) {
						if (profit(good, method, building, location, mapi, mobilization, i) > 0)
							key = profit(good, method, building, location, mapi, mobilization, i) / building[i].getConstructionCost();
					}
					else {
						key = -1;
					}
					float value = 0;
					if (building[it[j]].buildable()) {
						if (profit(good, method, building, location, mapi, mobilization, it[j]) > 0)
							value = profit(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
					}
					else {
						value = -1;
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable()) {
								if (profit(good, method, building, location, mapi, mobilization, it[j]) > 0)
									value = profit(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
								else {
									value = 0;
								}
							}
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else if (choice == 6) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = -1;
					if (building[i].buildable())
						key = productivity(good, method, building, location, mapi, mobilization, i) / building[i].getConstructionCost();
					float value = -1;
					if (building[it[j]].buildable())
						value = productivity(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable())
								value = productivity(good, method, building, location, mapi, mobilization, it[j]) / building[it[j]].getConstructionCost();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sectors(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, it[choice - 7]);
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
		}
	} while (!exit);
}

void buildings(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	bool cancel = false;
	int it[BSIZE - 1];
	for (int i = 0; i < BSIZE - 1; i++)
		it[i] = i;
	int choice;
	bool exit = false;

	do {
		system("cls");

		cout << "Buildings\n"
			 << " 1. Toggle Imports: ";
		if (cancel) {
			cout << "yes\n"
				 << " 2. Sort"
				 << "                           3. Sort"
				 << "         4. Sort"
				 << "               5. Sort"
				 << "                6. Sort\n"
				 << "                                   Profit"
				 << "          Productivity"
				 << "          Profitability"
				 << "          Productivity/Construction\n";
			for (int i = 0; i < BSIZE - 1; i++) {
				if (i < 3)
					cout << " ";
				cout << i + 7 << ". " << left << setw(31) << building[it[i]].getBuilding()
					 << "$" << left << setw(15) << trunc2D(profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]))
					 << "$";
				if (building[it[i]].buildable())
					cout << left << setw(21);
				cout << trunc2D(productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]));
				if (building[it[i]].buildable()) {
					if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]) < 0)
						cout << left << setw(23) << "$0";
					else {
						cout << "$" << left << setw(22) << trunc2D(20 * profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]) / building[it[i]].getConstructionCost());
					}
					cout << "$" << trunc2D(500 * productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]) / building[it[i]].getConstructionCost());
				}
				cout << endl;
			}
			cout << endl << "Enter your choice (0 to quit): ";
			cin >> choice;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice < 0 || choice > BSIZE + 5) {
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice == 0) {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				exit = true;
			}
			else if (choice == 1) {
				if (cancel)
					cancel = false;
				else {
					cancel = true;
				}
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 2) {
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 3) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) > profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) > productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = 0;
					if (building[i].buildable()) {
						if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) > 0)
							key = profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) / building[i].getConstructionCost();
					}
					else {
						key = -1;
					}
					float value = 0;
					if (building[it[j]].buildable()) {
						if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) > 0)
							value = profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
					}
					else {
						value = -1;
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable()) {
								if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) > 0)
									value = profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
								else {
									value = 0;
								}
							}
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else if (choice == 6) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = -1;
					if (building[i].buildable())
						key = productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) / building[i].getConstructionCost();
					float value = -1;
					if (building[it[j]].buildable())
						value = productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable())
								value = productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sectorsImportsCanceled(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, it[choice - 7]);
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
		}
		else {
			cout << "no\n"
				 << " 2. Sort"
				 << "                           3. Sort"
				 << "         4. Sort"
				 << "               5. Sort"
				 << "                6. Sort\n"
				 << "                                   Profit"
				 << "          Productivity"
				 << "          Profitability"
				 << "          Productivity/Construction\n";
			for (int i = 0; i < BSIZE - 1; i++) {
				if (i < 3)
					cout << " ";
				cout << i + 7 << ". " << left << setw(31) << building[it[i]].getBuilding()
					 << "$" << left << setw(15) << trunc2D(profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]))
					 << "$";
				if (building[it[i]].buildable())
					cout << left << setw(21);
				cout << trunc2D(productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]));
				if (building[it[i]].buildable()) {
					if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]) < 0)
						cout << left << setw(23) << "$0";
					else {
						cout << "$" << left << setw(22) << trunc2D(20 * profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]) / building[it[i]].getConstructionCost());
					}
					cout << "$" << trunc2D(500 * productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[i]) / building[it[i]].getConstructionCost());
				}
				cout << endl;
			}
			cout << endl << "Enter your choice (0 to quit): ";
			cin >> choice;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice < 0 || choice > BSIZE + 5) {
				system("cls");
				cout << "Error choose 0-" << BSIZE + 5 << endl << endl;
				system("pause");
			}
			else if (choice == 0) {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				exit = true;
			}
			else if (choice == 1) {
				if (cancel)
					cancel = false;
				else {
					cancel = true;
				}
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 2) {
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
			else if (choice == 3) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) > profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					for (;j >= 0 && productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) > productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]); j--)
						it[j + 1] = it[j];
					it[j + 1] = i;
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = 0;
					if (building[i].buildable()) {
						if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) > 0)
							key = profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) / building[i].getConstructionCost();
					}
					else {
						key = -1;
					}
					float value = 0;
					if (building[it[j]].buildable()) {
						if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) > 0)
							value = profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
					}
					else {
						value = -1;
					}
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable()) {
								if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) > 0)
									value = profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
								else {
									value = 0;
								}
							}
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else if (choice == 6) {
				system("cls");
				cout << "Loading...";
				it[0] = 0;
				for (int i = 1; i < BSIZE - 1; i++) {
					int j = i - 1;
					float key = -1;
					if (building[i].buildable())
						key = productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, i) / building[i].getConstructionCost();
					float value = -1;
					if (building[it[j]].buildable())
						value = productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
					while (j >= 0 && key > value) {
						it[j + 1] = it[j];
						if (--j >= 0) {
							if (building[it[j]].buildable())
								value = productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it[j]) / building[it[j]].getConstructionCost();
							else {
								value = -1;
							}
						}
					}
					it[j + 1] = i;
				}
			}
			else {
				sectors(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, it[choice - 7]);
				for (int i = 0; i < BSIZE - 1; i++)
					it[i] = i;
			}
		}
	} while (!exit);
}

float profit(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);

		if (good[i].localGood()) {
			cost += good[i].getInput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
		}
		else {
			cost += good[i].getInput(0) * good[i].getLocalPrice(mapi, good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getLocalPrice(mapi, good[i].getInput(0), good[i].getOutput(0));
		}
	}
	float profit = income - cost;

	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);

			if (good[j].localGood()) {
				cost += good[j].getInput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
			}
			else {
				cost += good[j].getInput(0) * good[j].getLocalPrice(mapi, good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getLocalPrice(mapi, good[j].getInput(0), good[j].getOutput(0));
			}
		}
		if (income - cost > profit)
			profit = income - cost;
	}

	return profit;
}

float profit(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;
	float input[GSIZE];
	float output[GSIZE];

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);
		input[i] = good[i].getInput(0);
		output[i] = good[i].getOutput(0);
	}
	for (int i = 0; i < GSIZE; i++) {
		float purchaseWeight = getPurchaseWeight(good, input, output, averageGdp, i);
		float localPurchaseWeight = getLocalPurchaseWeight(good, input, output, gdp, i);

		if (good[i].localGood()) {
			cost += input[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
			income += output[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
		}
		else {
			cost += input[i] * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
			income += output[i] * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
		}
	}
	float profit = income - cost;

	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);
			input[j] = good[j].getInput(0);
			output[j] = good[j].getOutput(0);
		}
		for (int j = 0; j < GSIZE; j++) {
			float purchaseWeight = getPurchaseWeight(good, input, output, averageGdp, j);
			float localPurchaseWeight = getLocalPurchaseWeight(good, input, output, gdp, j);

			if (good[j].localGood()) {
				cost += input[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
				income += output[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
			}
			else {
				cost += input[j] * good[j].getLocalPricePrediction(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
				income += output[j] * good[j].getLocalPricePrediction(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
			}
		}
		if (income - cost > profit)
			profit = income - cost;
	}

	return profit;
}

float profitImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);

		if (good[i].localGood()) {
			cost += good[i].getInput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
		}
		else {
			cost += good[i].getInput(0) * good[i].getLocalPriceImportsCanceled(mapi, good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getLocalPriceImportsCanceled(mapi, good[i].getInput(0), good[i].getOutput(0));
		}
	}
	float profit = income - cost;

	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);

			if (good[j].localGood()) {
				cost += good[j].getInput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
			}
			else {
				cost += good[j].getInput(0) * good[j].getLocalPriceImportsCanceled(mapi, good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getLocalPriceImportsCanceled(mapi, good[j].getInput(0), good[j].getOutput(0));
			}
		}
		if (income - cost > profit)
			profit = income - cost;
	}

	return profit;
}

float profitImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;
	float input[GSIZE];
	float output[GSIZE];

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);
		input[i] = good[i].getInput(0);
		output[i] = good[i].getOutput(0);
	}
	for (int i = 0; i < GSIZE; i++) {
		float purchaseWeight = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
		float localPurchaseWeight = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

		if (good[i].localGood()) {
			cost += input[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
			income += output[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
		}
		else {
			cost += input[i] * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
			income += output[i] * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
		}
	}
	float profit = income - cost;

	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);
			input[j] = good[j].getInput(0);
			output[j] = good[j].getOutput(0);
		}
		for (int j = 0; j < GSIZE; j++) {
			float purchaseWeight = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, j);
			float localPurchaseWeight = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, j);

			if (good[j].localGood()) {
				cost += input[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
				income += output[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
			}
			else {
				cost += input[j] * good[j].getLocalPricePredictionImportsCanceled(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
				income += output[j] * good[j].getLocalPricePredictionImportsCanceled(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
			}
		}
		if (income - cost > profit)
			profit = income - cost;
	}

	return profit;
}

float productivity(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;
	int workers = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);

		if (good[i].localGood()) {
			cost += good[i].getInput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
		}
		else {
			cost += good[i].getInput(0) * good[i].getLocalPrice(mapi, good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getLocalPrice(mapi, good[i].getInput(0), good[i].getOutput(0));
		}
	}
	float profit = income - cost;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[it].getSize(); j++)
			profession += method.getProfession(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);

			if (good[j].localGood()) {
				cost += good[j].getInput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
			}
			else {
				cost += good[j].getInput(0) * good[j].getLocalPrice(mapi, good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getLocalPrice(mapi, good[j].getInput(0), good[j].getOutput(0));
			}
		}
		if (income - cost > profit) {
			profit = income - cost;
			workers = 0;

			for (int j = 0; j < PSIZE; j++) {
				int profession = 0;

				for (int k = 0; k < building[it].getSize(); k++)
					profession += method.getProfession(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j);
				if (profession < 0)
					profession = 0;
				workers += profession;
			}
		}
	}
	if (profit < 0 || workers == 0)
		return 0;
	return 52 * profit / workers;
}

float productivity(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;
	float input[GSIZE];
	float output[GSIZE];
	int workers = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);
		input[i] = good[i].getInput(0);
		output[i] = good[i].getOutput(0);
	}
	for (int i = 0; i < GSIZE; i++) {
		float purchaseWeight = getPurchaseWeight(good, input, output, averageGdp, i);
		float localPurchaseWeight = getLocalPurchaseWeight(good, input, output, gdp, i);

		if (good[i].localGood()) {
			cost += input[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
			income += output[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
		}
		else {
			cost += input[i] * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
			income += output[i] * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
		}
	}
	float profit = income - cost;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[it].getSize(); j++)
			profession += method.getProfession(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);
			input[j] = good[j].getInput(0);
			output[j] = good[j].getOutput(0);
		}
		for (int j = 0; j < GSIZE; j++) {
			float purchaseWeight = getPurchaseWeight(good, input, output, averageGdp, j);
			float localPurchaseWeight = getLocalPurchaseWeight(good, input, output, gdp, j);

			if (good[j].localGood()) {
				cost += input[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
				income += output[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
			}
			else {
				cost += input[j] * good[j].getLocalPricePrediction(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
				income += output[j] * good[j].getLocalPricePrediction(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
			}
		}
		if (income - cost > profit) {
			profit = income - cost;
			workers = 0;

			for (int j = 0; j < PSIZE; j++) {
				int profession = 0;

				for (int k = 0; k < building[it].getSize(); k++)
					profession += method.getProfession(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j);
				if (profession < 0)
					profession = 0;
				workers += profession;
			}
		}
	}
	if (profit < 0 || workers == 0)
		return 0;
	return 52 * profit / workers;
}

float productivityImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;
	int workers = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);

		if (good[i].localGood()) {
			cost += good[i].getInput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
		}
		else {
			cost += good[i].getInput(0) * good[i].getLocalPriceImportsCanceled(mapi, good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getLocalPriceImportsCanceled(mapi, good[i].getInput(0), good[i].getOutput(0));
		}
	}
	float profit = income - cost;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[it].getSize(); j++)
			profession += method.getProfession(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);

			if (good[j].localGood()) {
				cost += good[j].getInput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getMarketPrice(good[j].getInput(0), good[j].getOutput(0));
			}
			else {
				cost += good[j].getInput(0) * good[j].getLocalPriceImportsCanceled(mapi, good[j].getInput(0), good[j].getOutput(0));
				income += good[j].getOutput(0) * good[j].getLocalPriceImportsCanceled(mapi, good[j].getInput(0), good[j].getOutput(0));
			}
		}
		if (income - cost > profit) {
			profit = income - cost;
			workers = 0;

			for (int j = 0; j < PSIZE; j++) {
				int profession = 0;

				for (int k = 0; k < building[it].getSize(); k++)
					profession += method.getProfession(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j);
				if (profession < 0)
					profession = 0;
				workers += profession;
			}
		}
	}
	if (profit < 0 || workers == 0)
		return 0;
	return 52 * profit / workers;
}

float productivityImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int it)
{
	float cost = 0;
	float income = 0;
	float input[GSIZE];
	float output[GSIZE];
	int workers = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[it].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[it].getBuilding(), mobilization, j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i, 0) * (building[it].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i) * (building[it].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);
		input[i] = good[i].getInput(0);
		output[i] = good[i].getOutput(0);
	}
	for (int i = 0; i < GSIZE; i++) {
		float purchaseWeight = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
		float localPurchaseWeight = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

		if (good[i].localGood()) {
			cost += input[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
			income += output[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
		}
		else {
			cost += input[i] * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
			income += output[i] * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
		}
	}
	float profit = income - cost;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[it].getSize(); j++)
			profession += method.getProfession(j + building[it].getProductionMethod(), location[building[it].getBuildingLocation()].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	for (int i = building[it].getBuildingLocation() + 1; i < building[it + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
		cost = 0;
		income = 0;

		for (int j = 0; j < GSIZE; j++) {
			good[j].setInput(0);
			good[j].setOutput(0);

			for (int k = 0; k < building[it].getSize(); k++) {
				good[j].setInput(method.getInputGood(good[j], building[it].getBuilding(), mobilization, k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j, 0) * (building[it].getThroughput(0) + 1), 0);
				good[j].setOutput(method.getOutputGood(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j) * (building[it].getThroughput(0) + good[j].getThroughput() + 1), 0);
			}
			good[j].setInputOutput(0);
			input[j] = good[j].getInput(0);
			output[j] = good[j].getOutput(0);
		}
		for (int j = 0; j < GSIZE; j++) {
			float purchaseWeight = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, j);
			float localPurchaseWeight = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, j);

			if (good[j].localGood()) {
				cost += input[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
				income += output[j] * good[j].getMarketPricePrediction(input[j], output[j], localPurchaseWeight);
			}
			else {
				cost += input[j] * good[j].getLocalPricePredictionImportsCanceled(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
				income += output[j] * good[j].getLocalPricePredictionImportsCanceled(mapi, input[j], output[j], purchaseWeight, localPurchaseWeight);
			}
		}
		if (income - cost > profit) {
			profit = income - cost;
			workers = 0;

			for (int j = 0; j < PSIZE; j++) {
				int profession = 0;

				for (int k = 0; k < building[it].getSize(); k++)
					profession += method.getProfession(k + building[it].getProductionMethod(), location[i].getProductionMethodLevel(k), j);
				if (profession < 0)
					profession = 0;
				workers += profession;
			}
		}
	}
	if (profit < 0 || workers == 0)
		return 0;
	return 52 * profit / workers;
}

void sectors(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int it)
{
	int choice;
	bool exit = false;

	do {
		int i = 0;
		system("cls");

		cout << building[it].getBuilding() << endl << endl
			 << ++i << ". Level: " << location[building[it].getBuildingLocation()].getLevel() << endl;
		for (int j = 0; j < building[it].getSize(); j++) {
			if (method.getSize(j + building[it].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(j + building[it].getProductionMethod());
				if (method.getProductionMethod(j + building[it].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[it].getBuilding() == "Barracks")
						cout << location[building[it].getBuildingLocation()].getArmyUnitType(j);
					else {
						cout << location[building[it].getBuildingLocation()].getNavyUnitType(j);
					}
				}
				else {
					cout << " Level: " << location[building[it].getBuildingLocation()].getProductionMethodLevel(j) + 1;
				}
				cout << endl;
			}
		}
		cout << "Profit: $" << trunc2D(profit(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation())) << endl
			 << "Productivity: $" << trunc2D(productivity(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation())) << endl;
		if (building[it].buildable()) {
			cout << "Profitability: $";
			if (profit(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation()) < 0)
				cout << "0";
			else {
				cout << trunc2D(20 * profit(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost());
			}
			cout << endl
				 << "Productivity/Construction: $" << trunc2D(500 * productivity(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost()) << endl;
		}
		cout << endl;
		for (int j = building[it].getBuildingLocation() + 1; j < building[it + 1].getBuildingLocation() && location[j - 1].getLevel() > 0; j++) {
			cout << ++i << ". Level: " << location[j].getLevel() << endl;
			for (int k = 0; k < building[it].getSize(); k++) {
				if (method.getSize(k + building[it].getProductionMethod()) > 1) {
					cout << method.getProductionMethod(k + building[it].getProductionMethod());
					if (method.getProductionMethod(k + building[it].getProductionMethod()) == "Military Unit Type") {
						cout << ": ";
						if (building[it].getBuilding() == "Barracks")
							cout << location[j].getArmyUnitType(k);
						else {
							cout << location[j].getNavyUnitType(k);
						}
					}
					else {
						cout << " Level: " << location[j].getProductionMethodLevel(k) + 1;
					}
					cout << endl;
				}
			}
			cout << "Profit: $" << trunc2D(profit(good, method, building, location, mapi, mobilization, it, j)) << endl
				 << "Productivity: $" << trunc2D(productivity(good, method, building, location, mapi, mobilization, it, j)) << endl;
			if (building[it].buildable()) {
				cout << "Profitability: $";
				if (profit(good, method, building, location, mapi, mobilization, it, j) < 0)
					cout << "0";
				else {
					cout << trunc2D(20 * profit(good, method, building, location, mapi, mobilization, it, j) / building[it].getConstructionCost());
				}
				cout << endl
					 << "Productivity/Construction: $" << trunc2D(500 * productivity(good, method, building, location, mapi, mobilization, it, j) / building[it].getConstructionCost()) << endl;
			}
			cout << endl;
		}
		cout << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else {
			construction(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, it, choice + building[it].getBuildingLocation() - 1);
		}
	} while (!exit);
}

void sectors(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int it)
{
	int choice;
	bool exit = false;

	do {
		int i = 0;
		system("cls");

		cout << building[it].getBuilding() << endl << endl
			 << ++i << ". Level: " << location[building[it].getBuildingLocation()].getLevel() << endl;
		for (int j = 0; j < building[it].getSize(); j++) {
			if (method.getSize(j + building[it].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(j + building[it].getProductionMethod());
				if (method.getProductionMethod(j + building[it].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[it].getBuilding() == "Barracks")
						cout << location[building[it].getBuildingLocation()].getArmyUnitType(j);
					else {
						cout << location[building[it].getBuildingLocation()].getNavyUnitType(j);
					}
				}
				else {
					cout << " Level: " << location[building[it].getBuildingLocation()].getProductionMethodLevel(j) + 1;
				}
				cout << endl;
			}
		}
		cout << "Profit: $" << trunc2D(profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation())) << endl
			 << "Productivity: $" << trunc2D(productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation())) << endl;
		if (building[it].buildable()) {
			cout << "Profitability: $";
			if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation()) < 0)
				cout << "0";
			else {
				cout << trunc2D(20 * profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost());
			}
			cout << endl
				 << "Productivity/Construction: $" << trunc2D(500 * productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost()) << endl;
		}
		cout << endl;
		for (int j = building[it].getBuildingLocation() + 1; j < building[it + 1].getBuildingLocation() && location[j - 1].getLevel() > 0; j++) {
			cout << ++i << ". Level: " << location[j].getLevel() << endl;
			for (int k = 0; k < building[it].getSize(); k++) {
				if (method.getSize(k + building[it].getProductionMethod()) > 1) {
					cout << method.getProductionMethod(k + building[it].getProductionMethod());
					if (method.getProductionMethod(k + building[it].getProductionMethod()) == "Military Unit Type") {
						cout << ": ";
						if (building[it].getBuilding() == "Barracks")
							cout << location[j].getArmyUnitType(k);
						else {
							cout << location[j].getNavyUnitType(k);
						}
					}
					else {
						cout << " Level: " << location[j].getProductionMethodLevel(k) + 1;
					}
					cout << endl;
				}
			}
			cout << "Profit: $" << trunc2D(profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j)) << endl
				 << "Productivity: $" << trunc2D(productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j)) << endl;
			if (building[it].buildable()) {
				cout << "Profitability: $";
				if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j) < 0)
					cout << "0";
				else {
					cout << trunc2D(20 * profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j) / building[it].getConstructionCost());
				}
				cout << endl
					 << "Productivity/Construction: $" << trunc2D(500 * productivity(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j) / building[it].getConstructionCost()) << endl;
			}
			cout << endl;
		}
		cout << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else {
			construction(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, it, choice + building[it].getBuildingLocation() - 1);
		}
	} while (!exit);
}

void sectorsImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int it)
{
	int choice;
	bool exit = false;

	do {
		int i = 0;
		system("cls");

		cout << building[it].getBuilding() << endl << endl
			 << ++i << ". Level: " << location[building[it].getBuildingLocation()].getLevel() << endl;
		for (int j = 0; j < building[it].getSize(); j++) {
			if (method.getSize(j + building[it].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(j + building[it].getProductionMethod());
				if (method.getProductionMethod(j + building[it].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[it].getBuilding() == "Barracks")
						cout << location[building[it].getBuildingLocation()].getArmyUnitType(j);
					else {
						cout << location[building[it].getBuildingLocation()].getNavyUnitType(j);
					}
				}
				else {
					cout << " Level: " << location[building[it].getBuildingLocation()].getProductionMethodLevel(j) + 1;
				}
				cout << endl;
			}
		}
		cout << "Profit: $" << trunc2D(profitImportsCanceled(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation())) << endl
			 << "Productivity: $" << trunc2D(productivityImportsCanceled(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation())) << endl;
		if (building[it].buildable()) {
			cout << "Profitability: $";
			if (profitImportsCanceled(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation()) < 0)
				cout << "0";
			else {
				cout << trunc2D(20 * profitImportsCanceled(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost());
			}
			cout << endl
				 << "Productivity/Construction: $" << trunc2D(500 * productivityImportsCanceled(good, method, building, location, mapi, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost()) << endl;
		}
		cout << endl;
		for (int j = building[it].getBuildingLocation() + 1; j < building[it + 1].getBuildingLocation() && location[j - 1].getLevel() > 0; j++) {
			cout << ++i << ". Level: " << location[j].getLevel() << endl;
			for (int k = 0; k < building[it].getSize(); k++) {
				if (method.getSize(k + building[it].getProductionMethod()) > 1) {
					cout << method.getProductionMethod(k + building[it].getProductionMethod());
					if (method.getProductionMethod(k + building[it].getProductionMethod()) == "Military Unit Type") {
						cout << ": ";
						if (building[it].getBuilding() == "Barracks")
							cout << location[j].getArmyUnitType(k);
						else {
							cout << location[j].getNavyUnitType(k);
						}
					}
					else {
						cout << " Level: " << location[j].getProductionMethodLevel(k) + 1;
					}
					cout << endl;
				}
			}
			cout << "Profit: $" << trunc2D(profitImportsCanceled(good, method, building, location, mapi, mobilization, it, j)) << endl
				 << "Productivity: $" << trunc2D(productivityImportsCanceled(good, method, building, location, mapi, mobilization, it, j)) << endl;
			if (building[it].buildable()) {
				cout << "Profitability: $";
				if (profitImportsCanceled(good, method, building, location, mapi, mobilization, it, j) < 0)
					cout << "0";
				else {
					cout << trunc2D(20 * profitImportsCanceled(good, method, building, location, mapi, mobilization, it, j) / building[it].getConstructionCost());
				}
				cout << endl
					 << "Productivity/Construction: $" << trunc2D(500 * productivityImportsCanceled(good, method, building, location, mapi, mobilization, it, j) / building[it].getConstructionCost()) << endl;
			}
			cout << endl;
		}
		cout << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else {
			constructionImportsCanceled(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, it, choice + building[it].getBuildingLocation() - 1);
		}
	} while (!exit);
}

void sectorsImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int it)
{
	int choice;
	bool exit = false;

	do {
		int i = 0;
		system("cls");

		cout << building[it].getBuilding() << endl << endl
			 << ++i << ". Level: " << location[building[it].getBuildingLocation()].getLevel() << endl;
		for (int j = 0; j < building[it].getSize(); j++) {
			if (method.getSize(j + building[it].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(j + building[it].getProductionMethod());
				if (method.getProductionMethod(j + building[it].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[it].getBuilding() == "Barracks")
						cout << location[building[it].getBuildingLocation()].getArmyUnitType(j);
					else {
						cout << location[building[it].getBuildingLocation()].getNavyUnitType(j);
					}
				}
				else {
					cout << " Level: " << location[building[it].getBuildingLocation()].getProductionMethodLevel(j) + 1;
				}
				cout << endl;
			}
		}
		cout << "Profit: $" << trunc2D(profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation())) << endl
			 << "Productivity: $" << trunc2D(productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation())) << endl;
		if (building[it].buildable()) {
			cout << "Profitability: $";
			if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation()) < 0)
				cout << "0";
			else {
				cout << trunc2D(20 * profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost());
			}
			cout << endl
				 << "Productivity/Construction: $" << trunc2D(500 * productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, building[it].getBuildingLocation()) / building[it].getConstructionCost()) << endl;
		}
		cout << endl;
		for (int j = building[it].getBuildingLocation() + 1; j < building[it + 1].getBuildingLocation() && location[j - 1].getLevel() > 0; j++) {
			cout << ++i << ". Level: " << location[j].getLevel() << endl;
			for (int k = 0; k < building[it].getSize(); k++) {
				if (method.getSize(k + building[it].getProductionMethod()) > 1) {
					cout << method.getProductionMethod(k + building[it].getProductionMethod());
					if (method.getProductionMethod(k + building[it].getProductionMethod()) == "Military Unit Type") {
						cout << ": ";
						if (building[it].getBuilding() == "Barracks")
							cout << location[j].getArmyUnitType(k);
						else {
							cout << location[j].getNavyUnitType(k);
						}
					}
					else {
						cout << " Level: " << location[j].getProductionMethodLevel(k) + 1;
					}
					cout << endl;
				}
			}
			cout << "Profit: $" << trunc2D(profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j)) << endl
				 << "Productivity: $" << trunc2D(productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j)) << endl;
			if (building[it].buildable()) {
				cout << "Profitability: $";
				if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j) < 0)
					cout << "0";
				else {
					cout << trunc2D(20 * profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j) / building[it].getConstructionCost());
				}
				cout << endl
					 << "Productivity/Construction: $" << trunc2D(500 * productivityImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, it, j) / building[it].getConstructionCost()) << endl;
			}
			cout << endl;
		}
		cout << "Enter your choice (0 to quit): ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			exit = true;
		}
		else {
			constructionImportsCanceled(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, it, choice + building[it].getBuildingLocation() - 1);
		}
	} while (!exit);
}

float profit(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	float cost = 0;
	float income = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);

		if (good[i].localGood()) {
			cost += good[i].getInput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
		}
		else {
			cost += good[i].getInput(0) * good[i].getLocalPrice(mapi, good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getLocalPrice(mapi, good[i].getInput(0), good[i].getOutput(0));
		}
	}

	return income - cost;
}

float profit(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	float cost = 0;
	float income = 0;
	float input[GSIZE];
	float output[GSIZE];

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);
		input[i] = good[i].getInput(0);
		output[i] = good[i].getOutput(0);
	}
	for (int i = 0; i < GSIZE; i++) {
		float purchaseWeight = getPurchaseWeight(good, input, output, averageGdp, i);
		float localPurchaseWeight = getLocalPurchaseWeight(good, input, output, gdp, i);

		if (good[i].localGood()) {
			cost += input[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
			income += output[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
		}
		else {
			cost += input[i] * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
			income += output[i] * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
		}
	}

	return income - cost;
}

float profitImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	float cost = 0;
	float income = 0;

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);

		if (good[i].localGood()) {
			cost += good[i].getInput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getMarketPrice(good[i].getInput(0), good[i].getOutput(0));
		}
		else {
			cost += good[i].getInput(0) * good[i].getLocalPriceImportsCanceled(mapi, good[i].getInput(0), good[i].getOutput(0));
			income += good[i].getOutput(0) * good[i].getLocalPriceImportsCanceled(mapi, good[i].getInput(0), good[i].getOutput(0));
		}
	}

	return income - cost;
}

float profitImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	float cost = 0;
	float income = 0;
	float input[GSIZE];
	float output[GSIZE];

	for (int i = 0; i < GSIZE; i++) {
		good[i].setInput(0);
		good[i].setOutput(0);

		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(0) + 1), 0);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(0) + good[i].getThroughput() + 1), 0);
		}
		good[i].setInputOutput(0);
		input[i] = good[i].getInput(0);
		output[i] = good[i].getOutput(0);
	}
	for (int i = 0; i < GSIZE; i++) {
		float purchaseWeight = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
		float localPurchaseWeight = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

		if (good[i].localGood()) {
			cost += input[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
			income += output[i] * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight);
		}
		else {
			cost += input[i] * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
			income += output[i] * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight, localPurchaseWeight);
		}
	}

	return income - cost;
}

float productivity(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int workers = 0;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[bIt].getSize(); j++)
			profession += method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	if (profit(good, method, building, location, mapi, mobilization, bIt, lIt) < 0 || workers == 0)
		return 0;
	return 52 * profit(good, method, building, location, mapi, mobilization, bIt, lIt) / workers;
}

float productivity(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int workers = 0;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[bIt].getSize(); j++)
			profession += method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	if (profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, bIt, lIt) < 0 || workers == 0)
		return 0;
	return 52 * profit(good, method, building, location, mapi, gdp, averageGdp, mobilization, bIt, lIt) / workers;
}

float productivityImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int workers = 0;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[bIt].getSize(); j++)
			profession += method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	if (profitImportsCanceled(good, method, building, location, mapi, mobilization, bIt, lIt) < 0 || workers == 0)
		return 0;
	return 52 * profitImportsCanceled(good, method, building, location, mapi, mobilization, bIt, lIt) / workers;
}

float productivityImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], float mapi, float gdp, float averageGdp, bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int workers = 0;

	for (int i = 0; i < PSIZE; i++) {
		int profession = 0;

		for (int j = 0; j < building[bIt].getSize(); j++)
			profession += method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
		if (profession < 0)
			profession = 0;
		workers += profession;
	}
	if (profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, bIt, lIt) < 0 || workers == 0)
		return 0;
	return 52 * profitImportsCanceled(good, method, building, location, mapi, gdp, averageGdp, mobilization, bIt, lIt) / workers;
}

void construction(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	bool eosOverride = false;
	int choice;
	int iIn;
	float fIn;
	bool duplicate = false;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << " Throughput: " << trunc1D(location[lIt].getBuildingThroughput() * 100) << "%\n"
			 << "Throughput overrides Economy of Scale: ";
		if (eosOverride)
			cout << "yes";
		else {
			cout << "no";
		}
		cout << endl << endl
			 << "Level: " << location[lIt].getLevel() << endl;
		if (!building[bIt].autoSubsidized())
			cout << "Subsidized Level: " << location[lIt].getSubsidized() << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		int i = 2;
		cout << endl
			 << "1. Set Level\n";
		if (!building[bIt].autoSubsidized())
			cout << i++ << ". Set Subsidized Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set " << building[bIt].getBuilding() << " Throughput\n";
		cout << i++ << ". Toggle Economy of Scale Override\n"
			 << i << ". State View\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
		}
		else if (choice == i--) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
			if (eosOverride)
				stateEoSOverride(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, bIt, lIt);
			else {
				state(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, bIt, lIt);
			}
		}
		else if (choice == i--) {
			if (eosOverride)
				eosOverride = false;
			else {
				eosOverride = true;
			}
		}
		else if (choice == i) {
			float throughput = 0;

			system("cls");
			cout << building[bIt].getBuilding() << " Level: " << location[lIt].getLevel() << endl << endl;
			for (int j = 0, i = 1; j < location[lIt].getLevel() && !exit; i++) {
				cout << i << ". Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn > 0) {
					j += iIn;

					if (j > location[lIt].getLevel()) {
						exit = true;
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cout << j << ". Enter " << building[bIt].getBuilding() << " Throughput (%): ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							throughput += fIn * iIn;
						}
					}
				}
			}
			if (exit)
				exit = false;
			else if (location[lIt].getLevel() == 0)
				location[lIt].setBuildingThroughput(throughput);
			else {
				location[lIt].setBuildingThroughput(throughput / location[lIt].getLevel() / 100);
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (building[bIt].autoSubsidized()) {
					if (!building[bIt].subsistence())
						location[lIt].setSubsidized(iIn);
				}
				else {
					if (iIn < location[lIt].getSubsidized())
						location[lIt].setSubsidized(iIn);
				}
				location[lIt].setLevel(iIn);
			}
		}
		else if (building[bIt].autoSubsidized()) {
			if (method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				if (building[bIt].getBuilding() == "Barracks")
					iIn = armyUnitType();
				else {
					iIn = navyUnitType();
				}
				location[lIt].setProductionMethodLevel(iIn, pm[choice - 2]);
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 2] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 2]);
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Subsidized Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (iIn > location[lIt].getLevel())
					location[lIt].setLevel(iIn);
				location[lIt].setSubsidized(iIn);
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 3] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 3] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 3]);
			}
		}
	} while (!exit);
}

void construction(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	bool eosOverride = false;
	int choice;
	int iIn;
	float fIn;
	bool duplicate = false;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << " Throughput: " << trunc1D(location[lIt].getBuildingThroughput() * 100) << "%\n"
			 << "Throughput overrides Economy of Scale: ";
		if (eosOverride)
			cout << "yes";
		else {
			cout << "no";
		}
		cout << endl << endl
			 << "Level: " << location[lIt].getLevel() << endl;
		if (!building[bIt].autoSubsidized())
			cout << "Subsidized Level: " << location[lIt].getSubsidized() << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		int i = 2;
		cout << endl
			 << "1. Set Level\n";
		if (!building[bIt].autoSubsidized())
			cout << i++ << ". Set Subsidized Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set " << building[bIt].getBuilding() << " Throughput\n";
		cout << i++ << ". Toggle Economy of Scale Override\n"
			 << i << ". State View\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
		}
		else if (choice == i--) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
			if (eosOverride)
				stateEoSOverride(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, bIt, lIt);
			else {
				state(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, bIt, lIt);
			}
		}
		else if (choice == i--) {
			if (eosOverride)
				eosOverride = false;
			else {
				eosOverride = true;
			}
		}
		else if (choice == i) {
			float throughput = 0;

			system("cls");
			cout << building[bIt].getBuilding() << " Level: " << location[lIt].getLevel() << endl << endl;
			for (int j = 0, i = 1; j < location[lIt].getLevel() && !exit; i++) {
				cout << i << ". Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn > 0) {
					j += iIn;

					if (j > location[lIt].getLevel()) {
						exit = true;
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cout << j << ". Enter " << building[bIt].getBuilding() << " Throughput (%): ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							throughput += fIn * iIn;
						}
					}
				}
			}
			if (exit)
				exit = false;
			else if (location[lIt].getLevel() == 0)
				location[lIt].setBuildingThroughput(throughput);
			else {
				location[lIt].setBuildingThroughput(throughput / location[lIt].getLevel() / 100);
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (building[bIt].autoSubsidized()) {
					if (!building[bIt].subsistence())
						location[lIt].setSubsidized(iIn);
				}
				else {
					if (iIn < location[lIt].getSubsidized())
						location[lIt].setSubsidized(iIn);
				}
				location[lIt].setLevel(iIn);
			}
		}
		else if (building[bIt].autoSubsidized()) {
			if (method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				if (building[bIt].getBuilding() == "Barracks")
					iIn = armyUnitType();
				else {
					iIn = navyUnitType();
				}
				location[lIt].setProductionMethodLevel(iIn, pm[choice - 2]);
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 2] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 2]);
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Subsidized Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (iIn > location[lIt].getLevel())
					location[lIt].setLevel(iIn);
				location[lIt].setSubsidized(iIn);
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 3] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 3] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 3]);
			}
		}
	} while (!exit);
}

void constructionImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	bool eosOverride = false;
	int choice;
	int iIn;
	float fIn;
	bool duplicate = false;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << " Throughput: " << trunc1D(location[lIt].getBuildingThroughput() * 100) << "%\n"
			 << "Throughput overrides Economy of Scale: ";
		if (eosOverride)
			cout << "yes";
		else {
			cout << "no";
		}
		cout << endl << endl
			 << "Level: " << location[lIt].getLevel() << endl;
		if (!building[bIt].autoSubsidized())
			cout << "Subsidized Level: " << location[lIt].getSubsidized() << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		int i = 2;
		cout << endl
			 << "1. Set Level\n";
		if (!building[bIt].autoSubsidized())
			cout << i++ << ". Set Subsidized Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set " << building[bIt].getBuilding() << " Throughput\n";
		cout << i++ << ". Toggle Economy of Scale Override\n"
			 << i << ". State View\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
		}
		else if (choice == i--) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
			if (eosOverride)
				stateEoSOverrideImportsCanceled(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, bIt, lIt);
			else {
				stateImportsCanceled(good, method, building, location, profession, mapi, eosCap, citizenship, mobilization, bIt, lIt);
			}
		}
		else if (choice == i--) {
			if (eosOverride)
				eosOverride = false;
			else {
				eosOverride = true;
			}
		}
		else if (choice == i) {
			float throughput = 0;

			system("cls");
			cout << building[bIt].getBuilding() << " Level: " << location[lIt].getLevel() << endl << endl;
			for (int j = 0, i = 1; j < location[lIt].getLevel() && !exit; i++) {
				cout << i << ". Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn > 0) {
					j += iIn;

					if (j > location[lIt].getLevel()) {
						exit = true;
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cout << j << ". Enter " << building[bIt].getBuilding() << " Throughput (%): ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							throughput += fIn * iIn;
						}
					}
				}
			}
			if (exit)
				exit = false;
			else if (location[lIt].getLevel() == 0)
				location[lIt].setBuildingThroughput(throughput);
			else {
				location[lIt].setBuildingThroughput(throughput / location[lIt].getLevel() / 100);
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (building[bIt].autoSubsidized()) {
					if (!building[bIt].subsistence())
						location[lIt].setSubsidized(iIn);
				}
				else {
					if (iIn < location[lIt].getSubsidized())
						location[lIt].setSubsidized(iIn);
				}
				location[lIt].setLevel(iIn);
			}
		}
		else if (building[bIt].autoSubsidized()) {
			if (method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				if (building[bIt].getBuilding() == "Barracks")
					iIn = armyUnitType();
				else {
					iIn = navyUnitType();
				}
				location[lIt].setProductionMethodLevel(iIn, pm[choice - 2]);
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 2] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 2]);
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Subsidized Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (iIn > location[lIt].getLevel())
					location[lIt].setLevel(iIn);
				location[lIt].setSubsidized(iIn);
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 3] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 3] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 3]);
			}
		}
	} while (!exit);
}

void constructionImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	bool eosOverride = false;
	int choice;
	int iIn;
	float fIn;
	bool duplicate = false;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << " Throughput: " << trunc1D(location[lIt].getBuildingThroughput() * 100) << "%\n"
			 << "Throughput overrides Economy of Scale: ";
		if (eosOverride)
			cout << "yes";
		else {
			cout << "no";
		}
		cout << endl << endl
			 << "Level: " << location[lIt].getLevel() << endl;
		if (!building[bIt].autoSubsidized())
			cout << "Subsidized Level: " << location[lIt].getSubsidized() << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		int i = 2;
		cout << endl
			 << "1. Set Level\n";
		if (!building[bIt].autoSubsidized())
			cout << i++ << ". Set Subsidized Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set " << building[bIt].getBuilding() << " Throughput\n";
		cout << i++ << ". Toggle Economy of Scale Override\n"
			 << i << ". State View\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
		}
		else if (choice == i--) {
			exit = true;
			i = lIt;

			for (lIt = building[bIt].getBuildingLocation(); lIt < i && !duplicate; lIt++) {
				duplicate = true;

				for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
					if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
						duplicate = false;
			}
			if (duplicate) {
				lIt--;
				location[lIt].setLevel(location[lIt].getLevel() + location[i].getLevel());
				location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

				for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
					location[i].setLevel(location[i + 1].getLevel());
					location[i].setSubsidized(location[i + 1].getSubsidized());

					for (int j = 0; j < building[bIt].getSize(); j++)
						location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
					location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
				}
			}
			else {
				for (i++; i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0 && !duplicate; i++) {
					duplicate = true;

					for (int j = 0; j < building[bIt].getSize() && duplicate; j++)
						if (location[lIt].getProductionMethodLevel(j) != location[i].getProductionMethodLevel(j))
							duplicate = false;
				}
				if (duplicate) {
					location[lIt].setLevel(location[lIt].getLevel() + location[--i].getLevel());
					location[lIt].setSubsidized(location[lIt].getSubsidized() + location[i].getSubsidized());

					for (;i < building[bIt + 1].getBuildingLocation() && location[i].getLevel() > 0; i++) {
						location[i].setLevel(location[i + 1].getLevel());
						location[i].setSubsidized(location[i + 1].getSubsidized());

						for (int j = 0; j < building[bIt].getSize(); j++)
							location[i].setProductionMethodLevel(location[i + 1].getProductionMethodLevel(j), j);
						location[i].setBuildingThroughput(location[i + 1].getBuildingThroughput());
					}
				}
			}
			if (eosOverride)
				stateEoSOverrideImportsCanceled(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, bIt, lIt);
			else {
				stateImportsCanceled(good, method, building, location, profession, mapi, gdp, averageGdp, eosCap, citizenship, mobilization, bIt, lIt);
			}
		}
		else if (choice == i--) {
			if (eosOverride)
				eosOverride = false;
			else {
				eosOverride = true;
			}
		}
		else if (choice == i) {
			float throughput = 0;

			system("cls");
			cout << building[bIt].getBuilding() << " Level: " << location[lIt].getLevel() << endl << endl;
			for (int j = 0, i = 1; j < location[lIt].getLevel() && !exit; i++) {
				cout << i << ". Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					exit = true;
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn > 0) {
					j += iIn;

					if (j > location[lIt].getLevel()) {
						exit = true;
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						cout << j << ". Enter " << building[bIt].getBuilding() << " Throughput (%): ";
						cin >> fIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							exit = true;
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							throughput += fIn * iIn;
						}
					}
				}
			}
			if (exit)
				exit = false;
			else if (location[lIt].getLevel() == 0)
				location[lIt].setBuildingThroughput(throughput);
			else {
				location[lIt].setBuildingThroughput(throughput / location[lIt].getLevel() / 100);
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (building[bIt].autoSubsidized()) {
					if (!building[bIt].subsistence())
						location[lIt].setSubsidized(iIn);
				}
				else {
					if (iIn < location[lIt].getSubsidized())
						location[lIt].setSubsidized(iIn);
				}
				location[lIt].setLevel(iIn);
			}
		}
		else if (building[bIt].autoSubsidized()) {
			if (method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				if (building[bIt].getBuilding() == "Barracks")
					iIn = armyUnitType();
				else {
					iIn = navyUnitType();
				}
				location[lIt].setProductionMethodLevel(iIn, pm[choice - 2]);
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 2] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 2] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 2]);
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Subsidized Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				if (iIn > location[lIt].getLevel())
					location[lIt].setLevel(iIn);
				location[lIt].setSubsidized(iIn);
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 3] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 3] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				location[lIt].setProductionMethodLevel(iIn - 1, pm[choice - 3]);
			}
		}
	} while (!exit);
}

void state(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[7] = { location[lIt].getLevel(), 0, 0, 0, 1, 0, 0 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	float throughput[2];
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	if (building[bIt].hasEOS() || building[bIt].buildable() && !building[bIt].autoSubsidized()) {
		throughput[1] = (float(level[0]) + 1) / 100 + 1;
		if (throughput[1] > eosCap)
			throughput[1] = eosCap;
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
			if (good[i].localGood()) {
				cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
			}
			else {
				cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
			}
		}
	}
	else {
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
			if (good[i].localGood()) {
				cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
			}
			else {
				cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
			}
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[2] << endl;
			if (building[bIt].getThroughput(5) != 0)
				cout << "Company Owned Level: " << level[3] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[4] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[5] << endl;
			if (building[bIt].getThroughput(6) != 0)
				cout << "Company Owned Level: " << level[6] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[4] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[4] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[4] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[4] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 3;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set Nationalized Level\n";
			if (building[bIt].getThroughput(5) != 0)
				cout << i++ << ". Set Company Owned Level\n";
		}
		cout << i++ << ". Set New Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set New Nationalized Level\n";
			if (building[bIt].getThroughput(6) != 0)
				cout << i++ << ". Set New Company Owned Level\n";
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitability(good, method, building, location, profession, input, output, cost, income, profit, mapi, level[1], level[4], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);
			
			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			if (choice == 1) {
				system("cls");
				cout << "Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[0] = iIn;

					if (iIn < level[1]) {
						level[1] = iIn;

						if (iIn < level[2])
							level[2] = iIn;
					}
					if (iIn < level[3])
						level[3] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < 2; i++)
						workers[i] = 0;
					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;

						for (int j = 0; j < 2; j++) {
							accepted[i][j] = 0;
							citizen[i][j] = 0;
							prejudice[i][j] = 0;
							erasure[i][j] = 0;
							hostile[i][j] = 0;
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						for (int j = 0; j < 2; j++) {
							if (accepted[i][j] < 0)
								accepted[i][j] = 0;
							workers[j] += accepted[i][j];
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 2) {
				system("cls");
				cout << "Enter Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[1] = iIn;
					workers[0] = 0;

					if (iIn > level[0]) {
						level[0] = iIn;
						workers[1] = 0;

						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							baseAccepted[i] = 0;
							baseCitizen[i] = 0;
							basePrejudice[i] = 0;
							baseErasure[i] = 0;
							baseHostile[i] = 0;
							accepted[i][1] = 0;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;

							for (int j = 0; j < building[bIt].getSize(); j++) {
								baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
								accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							}
							if (baseAccepted[i] < 0)
								baseAccepted[i] = 0;
							if (accepted[i][1] < 0)
								accepted[i][1] = 0;
							workers[1] += accepted[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					else if (iIn < level[2])
						level[2] = iIn;
					else if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][0] = profession;
							citizen[i][0] = 0;
							prejudice[i][0] = 0;
							erasure[i][0] = 0;
							hostile[i][0] = 0;
						}
						else {
							accepted[i][0] = float(profession) / employees * baseAccepted[i];
							citizen[i][0] = float(profession) / employees * baseCitizen[i];
							prejudice[i][0] = float(profession) / employees * basePrejudice[i];
							erasure[i][0] = float(profession) / employees * baseErasure[i];
							hostile[i][0] = float(profession) / employees * baseHostile[i];
						}
						workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
					}
					wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 3) {
				system("cls");
				cout << "Enter Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[2] = iIn;

					if (iIn > level[1]) {
						level[1] = iIn;
						workers[0] = 0;

						if (iIn > level[0]) {
							level[0] = iIn;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								baseAccepted[i] = 0;
								baseCitizen[i] = 0;
								basePrejudice[i] = 0;
								baseErasure[i] = 0;
								baseHostile[i] = 0;
								accepted[i][1] = 0;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;

								for (int j = 0; j < building[bIt].getSize(); j++) {
									baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
									accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								}
								if (baseAccepted[i] < 0)
									baseAccepted[i] = 0;
								if (accepted[i][1] < 0)
									accepted[i][1] = 0;
								workers[1] += accepted[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][0] = profession;
								citizen[i][0] = 0;
								prejudice[i][0] = 0;
								erasure[i][0] = 0;
								hostile[i][0] = 0;
							}
							else {
								accepted[i][0] = float(profession) / employees * baseAccepted[i];
								citizen[i][0] = float(profession) / employees * baseCitizen[i];
								prejudice[i][0] = float(profession) / employees * basePrejudice[i];
								erasure[i][0] = float(profession) / employees * baseErasure[i];
								hostile[i][0] = float(profession) / employees * baseHostile[i];
							}
							workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
						}
						wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

					if (throughput[0] > eosCap)
						throughput[0] = eosCap;
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					for (i = 0; i < 2; i++) {
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (building[bIt].getThroughput(5) != 0) {
				if (choice == 4) {
					system("cls");
					cout << "Enter Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0])
							iIn = level[0];
						level[3] = iIn;

						if (level[0] != 0) {
							throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

							if (throughput[0] > eosCap)
								throughput[0] = eosCap;
							throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);

							for (i = 0; i < 2; i++) {
								cost[i] = 0;
								income[i] = 0;
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(0);
								good[i].setOutput(0);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
									good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
								}
								good[i].setInputOutput(0);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);

								if (good[i].localGood()) {
									cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
									income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
									cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
								}
								else {
									cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
									income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
									cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								}
							}
							for (i = 0; i < 2; i++) {
								profit[i][0] = income[i] - cost[i];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[i][1] = income[i] - cost[i] * 0.9;
									profit[i][2] = income[i] - cost[i] * 0.75;
									profit[i][3] = income[i] - cost[i] * 0.65;
									profit[i][4] = income[i] - cost[i] * 0.5;
									profit[i][5] = income[i] - cost[i] * 0.25;
								}
							}
						}
					}
				}
				else if (choice == 5) {
					system("cls");
					cout << "Enter New Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[4] = iIn;
						workers[1] = 0;
						
						if (iIn < level[5])
							level[5] = iIn;
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (choice == 6) {
					system("cls");
					cout << "Enter New Nationalized Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[5] = iIn;

						if (iIn > level[4]) {
							level[4] = iIn;
							workers[1] = 0;
							
							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (building[bIt].getThroughput(6) != 0) {
					if (choice == 7) {
						system("cls");
						cout << "Enter New Company Owned Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 0) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							if (iIn > level[0] + level[4] - level[1])
								iIn = level[0] + level[4] - level[1];
							level[6] = iIn;
							
							if (level[0] + level[4] != level[1]) {
								throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

								if (throughput[1] > eosCap)
									throughput[1] = eosCap;
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
								cost[1] = 0;
								income[1] = 0;

								for (i = 0; i < GSIZE; i++) {
									good[i].setInput(1);
									good[i].setOutput(1);

									for (int j = 0; j < building[bIt].getSize(); j++) {
										good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
										good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
									}
									good[i].setInputOutput(1);
									input[i] = good[i].getInput(1) - good[i].getInput(0);
									output[i] = good[i].getOutput(1) - good[i].getOutput(0);

									if (good[i].localGood()) {
										cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
										income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
									}
									else {
										cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
										income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
									}
								}
								profit[1][0] = income[1] - cost[1];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[1][1] = income[1] - cost[1] * 0.9;
									profit[1][2] = income[1] - cost[1] * 0.75;
									profit[1][3] = income[1] - cost[1] * 0.65;
									profit[1][4] = income[1] - cost[1] * 0.5;
									profit[1][5] = income[1] - cost[1] * 0.25;
								}
							}
						}
					}
					else {
						system("cls");
						cout << "Enter " << method.getProductionMethod(pm[choice - 8] + building[bIt].getProductionMethod()) << " Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 1 || iIn > method.getSize(pm[choice - 8] + building[bIt].getProductionMethod())) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							methodLevel[pm[choice - 8]] = iIn - 1;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
							cost[1] = 0;
							income[1] = 0;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							if (level[0] + level[4] != level[1])
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							else {
								throughput[1] += building[bIt].getThroughput(6);
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Enter New Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[4] = iIn;
					workers[1] = 0;

					if (iIn < level[5])
						level[5] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Enter New Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[5] = iIn;

					if (iIn > level[4]) {
						level[4] = iIn;
						workers[1] = 0;
						
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (building[bIt].getThroughput(6) != 0) {
				if (choice == 6) {
					system("cls");
					cout << "Enter New Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0] + level[4] - level[1])
							iIn = level[0] + level[4] - level[1];
						level[6] = iIn;
						
						if (level[0] + level[4] != level[1]) {
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							cost[1] = 0;
							income[1] = 0;

							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 6] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 6] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					methodLevel[pm[choice - 6]] = iIn - 1;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				if (iIn < level[1])
					level[1] = iIn;
				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				if (iIn > level[0]) {
					level[0] = iIn;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;
						accepted[i][1] = 0;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;

						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						if (accepted[i][1] < 0)
							accepted[i][1] = 0;
						workers[1] += accepted[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				}
				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(3) + 1), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(3) + good[i].getThroughput() + 1), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[4] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			if (building[bIt].hasEOS()) {
				throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

				if (throughput[1] > eosCap)
					throughput[1] = eosCap;
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
					}
				}
			}
			else {
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
					}
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						}
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void state(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[7] = { location[lIt].getLevel(), 0, 0, 0, 1, 0, 0 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	float throughput[2];
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float purchaseWeight[GSIZE];
	float localPurchaseWeight[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	if (building[bIt].hasEOS() || building[bIt].buildable() && !building[bIt].autoSubsidized()) {
		throughput[1] = (float(level[0]) + 1) / 100 + 1;
		if (throughput[1] > eosCap)
			throughput[1] = eosCap;
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
		}
	}
	else {
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
		}
	}
	for (int i = 0; i < GSIZE; i++) {
		purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
		localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);
		if (good[i].localGood()) {
			cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
		}
		else {
			cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[2] << endl;
			if (building[bIt].getThroughput(5) != 0)
				cout << "Company Owned Level: " << level[3] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[4] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[5] << endl;
			if (building[bIt].getThroughput(6) != 0)
				cout << "Company Owned Level: " << level[6] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[4] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[4] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[4] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[4] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 3;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set Nationalized Level\n";
			if (building[bIt].getThroughput(5) != 0)
				cout << i++ << ". Set Company Owned Level\n";
		}
		cout << i++ << ". Set New Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set New Nationalized Level\n";
			if (building[bIt].getThroughput(6) != 0)
				cout << i++ << ". Set New Company Owned Level\n";
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitability(good, method, building, location, profession, input, output, purchaseWeight, localPurchaseWeight, cost, income, profit, mapi, level[1], level[4], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			if (choice == 1) {
				system("cls");
				cout << "Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[0] = iIn;

					if (iIn < level[1]) {
						level[1] = iIn;

						if (iIn < level[2])
							level[2] = iIn;
					}
					if (iIn < level[3])
						level[3] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < 2; i++)
						workers[i] = 0;
					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;

						for (int j = 0; j < 2; j++) {
							accepted[i][j] = 0;
							citizen[i][j] = 0;
							prejudice[i][j] = 0;
							erasure[i][j] = 0;
							hostile[i][j] = 0;
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						for (int j = 0; j < 2; j++) {
							if (accepted[i][j] < 0)
								accepted[i][j] = 0;
							workers[j] += accepted[i][j];
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 2) {
				system("cls");
				cout << "Enter Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[1] = iIn;
					workers[0] = 0;

					if (iIn > level[0]) {
						level[0] = iIn;
						workers[1] = 0;

						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							baseAccepted[i] = 0;
							baseCitizen[i] = 0;
							basePrejudice[i] = 0;
							baseErasure[i] = 0;
							baseHostile[i] = 0;
							accepted[i][1] = 0;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;

							for (int j = 0; j < building[bIt].getSize(); j++) {
								baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
								accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							}
							if (baseAccepted[i] < 0)
								baseAccepted[i] = 0;
							if (accepted[i][1] < 0)
								accepted[i][1] = 0;
							workers[1] += accepted[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					else if (iIn < level[2])
						level[2] = iIn;
					else if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][0] = profession;
							citizen[i][0] = 0;
							prejudice[i][0] = 0;
							erasure[i][0] = 0;
							hostile[i][0] = 0;
						}
						else {
							accepted[i][0] = float(profession) / employees * baseAccepted[i];
							citizen[i][0] = float(profession) / employees * baseCitizen[i];
							prejudice[i][0] = float(profession) / employees * basePrejudice[i];
							erasure[i][0] = float(profession) / employees * baseErasure[i];
							hostile[i][0] = float(profession) / employees * baseHostile[i];
						}
						workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
					}
					wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 3) {
				system("cls");
				cout << "Enter Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[2] = iIn;

					if (iIn > level[1]) {
						level[1] = iIn;
						workers[0] = 0;

						if (iIn > level[0]) {
							level[0] = iIn;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								baseAccepted[i] = 0;
								baseCitizen[i] = 0;
								basePrejudice[i] = 0;
								baseErasure[i] = 0;
								baseHostile[i] = 0;
								accepted[i][1] = 0;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;

								for (int j = 0; j < building[bIt].getSize(); j++) {
									baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
									accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								}
								if (baseAccepted[i] < 0)
									baseAccepted[i] = 0;
								if (accepted[i][1] < 0)
									accepted[i][1] = 0;
								workers[1] += accepted[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][0] = profession;
								citizen[i][0] = 0;
								prejudice[i][0] = 0;
								erasure[i][0] = 0;
								hostile[i][0] = 0;
							}
							else {
								accepted[i][0] = float(profession) / employees * baseAccepted[i];
								citizen[i][0] = float(profession) / employees * baseCitizen[i];
								prejudice[i][0] = float(profession) / employees * basePrejudice[i];
								erasure[i][0] = float(profession) / employees * baseErasure[i];
								hostile[i][0] = float(profession) / employees * baseHostile[i];
							}
							workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
						}
						wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

					if (throughput[0] > eosCap)
						throughput[0] = eosCap;
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					for (i = 0; i < 2; i++) {
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (building[bIt].getThroughput(5) != 0) {
				if (choice == 4) {
					system("cls");
					cout << "Enter Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0])
							iIn = level[0];
						level[3] = iIn;

						if (level[0] != 0) {
							throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

							if (throughput[0] > eosCap)
								throughput[0] = eosCap;
							throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);

							for (i = 0; i < 2; i++) {
								cost[i] = 0;
								income[i] = 0;
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(0);
								good[i].setOutput(0);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
									good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
								}
								good[i].setInputOutput(0);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);
							}
							for (i = 0; i < GSIZE; i++) {
								purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
								localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

								if (good[i].localGood()) {
									cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
									income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
									cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								}
								else {
									cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
									income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
									cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								}
							}
							for (i = 0; i < 2; i++) {
								profit[i][0] = income[i] - cost[i];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[i][1] = income[i] - cost[i] * 0.9;
									profit[i][2] = income[i] - cost[i] * 0.75;
									profit[i][3] = income[i] - cost[i] * 0.65;
									profit[i][4] = income[i] - cost[i] * 0.5;
									profit[i][5] = income[i] - cost[i] * 0.25;
								}
							}
						}
					}
				}
				else if (choice == 5) {
					system("cls");
					cout << "Enter New Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[4] = iIn;
						workers[1] = 0;

						if (iIn < level[5])
							level[5] = iIn;
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (choice == 6) {
					system("cls");
					cout << "Enter New Nationalized Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[5] = iIn;

						if (iIn > level[4]) {
							level[4] = iIn;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (building[bIt].getThroughput(6) != 0) {
					if (choice == 7) {
						system("cls");
						cout << "Enter New Company Owned Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 0) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							if (iIn > level[0] + level[4] - level[1])
								iIn = level[0] + level[4] - level[1];
							level[6] = iIn;

							if (level[0] + level[4] != level[1]) {
								throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

								if (throughput[1] > eosCap)
									throughput[1] = eosCap;
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
								cost[1] = 0;
								income[1] = 0;

								for (i = 0; i < GSIZE; i++) {
									good[i].setInput(1);
									good[i].setOutput(1);

									for (int j = 0; j < building[bIt].getSize(); j++) {
										good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
										good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
									}
									good[i].setInputOutput(1);
									input[i] = good[i].getInput(1) - good[i].getInput(0);
									output[i] = good[i].getOutput(1) - good[i].getOutput(0);
								}
								for (i = 0; i < GSIZE; i++) {
									purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
									localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

									if (good[i].localGood()) {
										cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
										income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									}
									else {
										cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
										income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									}
								}
								profit[1][0] = income[1] - cost[1];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[1][1] = income[1] - cost[1] * 0.9;
									profit[1][2] = income[1] - cost[1] * 0.75;
									profit[1][3] = income[1] - cost[1] * 0.65;
									profit[1][4] = income[1] - cost[1] * 0.5;
									profit[1][5] = income[1] - cost[1] * 0.25;
								}
							}
						}
					}
					else {
						system("cls");
						cout << "Enter " << method.getProductionMethod(pm[choice - 8] + building[bIt].getProductionMethod()) << " Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 1 || iIn > method.getSize(pm[choice - 8] + building[bIt].getProductionMethod())) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							methodLevel[pm[choice - 8]] = iIn - 1;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
							cost[1] = 0;
							income[1] = 0;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							if (level[0] + level[4] != level[1])
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							else {
								throughput[1] += building[bIt].getThroughput(6);
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);
							}
							for (i = 0; i < GSIZE; i++) {
								purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
								localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Enter New Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[4] = iIn;
					workers[1] = 0;

					if (iIn < level[5])
						level[5] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Enter New Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[5] = iIn;

					if (iIn > level[4]) {
						level[4] = iIn;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (building[bIt].getThroughput(6) != 0) {
				if (choice == 6) {
					system("cls");
					cout << "Enter New Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0] + level[4] - level[1])
							iIn = level[0] + level[4] - level[1];
						level[6] = iIn;

						if (level[0] + level[4] != level[1]) {
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							cost[1] = 0;
							income[1] = 0;

							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);
							}
							for (i = 0; i < GSIZE; i++) {
								purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
								localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 6] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 6] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					methodLevel[pm[choice - 6]] = iIn - 1;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				if (iIn < level[1])
					level[1] = iIn;
				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				if (iIn > level[0]) {
					level[0] = iIn;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;
						accepted[i][1] = 0;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;

						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						if (accepted[i][1] < 0)
							accepted[i][1] = 0;
						workers[1] += accepted[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				}
				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(3) + 1), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(3) + good[i].getThroughput() + 1), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
						income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
						income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[4] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			if (building[bIt].hasEOS()) {
				throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

				if (throughput[1] > eosCap)
					throughput[1] = eosCap;
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
			}
			else {
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
			}
			for (i = 0; i < GSIZE; i++) {
				purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
				localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

				if (good[i].localGood()) {
					cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
				}
				else {
					cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void stateImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[7] = { location[lIt].getLevel(), 0, 0, 0, 1, 0, 0 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	float throughput[2];
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	if (building[bIt].hasEOS() || building[bIt].buildable() && !building[bIt].autoSubsidized()) {
		throughput[1] = (float(level[0]) + 1) / 100 + 1;
		if (throughput[1] > eosCap)
			throughput[1] = eosCap;
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
			if (good[i].localGood()) {
				cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
			}
			else {
				cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
			}
		}
	}
	else {
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
			if (good[i].localGood()) {
				cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
			}
			else {
				cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
				income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
			}
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[2] << endl;
			if (building[bIt].getThroughput(5) != 0)
				cout << "Company Owned Level: " << level[3] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[4] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[5] << endl;
			if (building[bIt].getThroughput(6) != 0)
				cout << "Company Owned Level: " << level[6] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[4] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[4] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports())) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports())) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[4] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[4] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 3;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set Nationalized Level\n";
			if (building[bIt].getThroughput(5) != 0)
				cout << i++ << ". Set Company Owned Level\n";
		}
		cout << i++ << ". Set New Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set New Nationalized Level\n";
			if (building[bIt].getThroughput(6) != 0)
				cout << i++ << ". Set New Company Owned Level\n";
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitabilityImportsCanceled(good, method, building, location, profession, input, output, cost, income, profit, mapi, level[1], level[4], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			if (choice == 1) {
				system("cls");
				cout << "Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[0] = iIn;

					if (iIn < level[1]) {
						level[1] = iIn;

						if (iIn < level[2])
							level[2] = iIn;
					}
					if (iIn < level[3])
						level[3] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < 2; i++)
						workers[i] = 0;
					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;

						for (int j = 0; j < 2; j++) {
							accepted[i][j] = 0;
							citizen[i][j] = 0;
							prejudice[i][j] = 0;
							erasure[i][j] = 0;
							hostile[i][j] = 0;
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						for (int j = 0; j < 2; j++) {
							if (accepted[i][j] < 0)
								accepted[i][j] = 0;
							workers[j] += accepted[i][j];
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 2) {
				system("cls");
				cout << "Enter Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[1] = iIn;
					workers[0] = 0;

					if (iIn > level[0]) {
						level[0] = iIn;
						workers[1] = 0;

						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							baseAccepted[i] = 0;
							baseCitizen[i] = 0;
							basePrejudice[i] = 0;
							baseErasure[i] = 0;
							baseHostile[i] = 0;
							accepted[i][1] = 0;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;

							for (int j = 0; j < building[bIt].getSize(); j++) {
								baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
								accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							}
							if (baseAccepted[i] < 0)
								baseAccepted[i] = 0;
							if (accepted[i][1] < 0)
								accepted[i][1] = 0;
							workers[1] += accepted[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					else if (iIn < level[2])
						level[2] = iIn;
					else if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][0] = profession;
							citizen[i][0] = 0;
							prejudice[i][0] = 0;
							erasure[i][0] = 0;
							hostile[i][0] = 0;
						}
						else {
							accepted[i][0] = float(profession) / employees * baseAccepted[i];
							citizen[i][0] = float(profession) / employees * baseCitizen[i];
							prejudice[i][0] = float(profession) / employees * basePrejudice[i];
							erasure[i][0] = float(profession) / employees * baseErasure[i];
							hostile[i][0] = float(profession) / employees * baseHostile[i];
						}
						workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
					}
					wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 3) {
				system("cls");
				cout << "Enter Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[2] = iIn;

					if (iIn > level[1]) {
						level[1] = iIn;
						workers[0] = 0;

						if (iIn > level[0]) {
							level[0] = iIn;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								baseAccepted[i] = 0;
								baseCitizen[i] = 0;
								basePrejudice[i] = 0;
								baseErasure[i] = 0;
								baseHostile[i] = 0;
								accepted[i][1] = 0;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;

								for (int j = 0; j < building[bIt].getSize(); j++) {
									baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
									accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								}
								if (baseAccepted[i] < 0)
									baseAccepted[i] = 0;
								if (accepted[i][1] < 0)
									accepted[i][1] = 0;
								workers[1] += accepted[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][0] = profession;
								citizen[i][0] = 0;
								prejudice[i][0] = 0;
								erasure[i][0] = 0;
								hostile[i][0] = 0;
							}
							else {
								accepted[i][0] = float(profession) / employees * baseAccepted[i];
								citizen[i][0] = float(profession) / employees * baseCitizen[i];
								prejudice[i][0] = float(profession) / employees * basePrejudice[i];
								erasure[i][0] = float(profession) / employees * baseErasure[i];
								hostile[i][0] = float(profession) / employees * baseHostile[i];
							}
							workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
						}
						wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

					if (throughput[0] > eosCap)
						throughput[0] = eosCap;
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					for (i = 0; i < 2; i++) {
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (building[bIt].getThroughput(5) != 0) {
				if (choice == 4) {
					system("cls");
					cout << "Enter Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0])
							iIn = level[0];
						level[3] = iIn;

						if (level[0] != 0) {
							throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

							if (throughput[0] > eosCap)
								throughput[0] = eosCap;
							throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);

							for (i = 0; i < 2; i++) {
								cost[i] = 0;
								income[i] = 0;
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(0);
								good[i].setOutput(0);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
									good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
								}
								good[i].setInputOutput(0);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);

								if (good[i].localGood()) {
									cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
									income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
									cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
								}
								else {
									cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
									income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
									cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								}
							}
							for (i = 0; i < 2; i++) {
								profit[i][0] = income[i] - cost[i];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[i][1] = income[i] - cost[i] * 0.9;
									profit[i][2] = income[i] - cost[i] * 0.75;
									profit[i][3] = income[i] - cost[i] * 0.65;
									profit[i][4] = income[i] - cost[i] * 0.5;
									profit[i][5] = income[i] - cost[i] * 0.25;
								}
							}
						}
					}
				}
				else if (choice == 5) {
					system("cls");
					cout << "Enter New Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[4] = iIn;
						workers[1] = 0;

						if (iIn < level[5])
							level[5] = iIn;
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (choice == 6) {
					system("cls");
					cout << "Enter New Nationalized Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[5] = iIn;

						if (iIn > level[4]) {
							level[4] = iIn;
							workers[1] = 0;
							
							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (building[bIt].getThroughput(6) != 0) {
					if (choice == 7) {
						system("cls");
						cout << "Enter New Company Owned Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 0) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							if (iIn > level[0] + level[4] - level[1])
								iIn = level[0] + level[4] - level[1];
							level[6] = iIn;

							if (level[0] + level[4] != level[1]) {
								throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

								if (throughput[1] > eosCap)
									throughput[1] = eosCap;
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
								cost[1] = 0;
								income[1] = 0;

								for (i = 0; i < GSIZE; i++) {
									good[i].setInput(1);
									good[i].setOutput(1);

									for (int j = 0; j < building[bIt].getSize(); j++) {
										good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
										good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
									}
									good[i].setInputOutput(1);
									input[i] = good[i].getInput(1) - good[i].getInput(0);
									output[i] = good[i].getOutput(1) - good[i].getOutput(0);

									if (good[i].localGood()) {
										cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
										income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
									}
									else {
										cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
										income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
									}
								}
								profit[1][0] = income[1] - cost[1];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[1][1] = income[1] - cost[1] * 0.9;
									profit[1][2] = income[1] - cost[1] * 0.75;
									profit[1][3] = income[1] - cost[1] * 0.65;
									profit[1][4] = income[1] - cost[1] * 0.5;
									profit[1][5] = income[1] - cost[1] * 0.25;
								}
							}
						}
					}
					else {
						system("cls");
						cout << "Enter " << method.getProductionMethod(pm[choice - 8] + building[bIt].getProductionMethod()) << " Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 1 || iIn > method.getSize(pm[choice - 8] + building[bIt].getProductionMethod())) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							methodLevel[pm[choice - 8]] = iIn - 1;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
							cost[1] = 0;
							income[1] = 0;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							if (level[0] + level[4] != level[1])
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							else {
								throughput[1] += building[bIt].getThroughput(6);
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Enter New Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[4] = iIn;
					workers[1] = 0;

					if (iIn < level[5])
						level[5] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Enter New Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[5] = iIn;

					if (iIn > level[4]) {
						level[4] = iIn;
						workers[1] = 0;
						
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (building[bIt].getThroughput(6) != 0) {
				if (choice == 6) {
					system("cls");
					cout << "Enter New Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0] + level[4] - level[1])
							iIn = level[0] + level[4] - level[1];
						level[6] = iIn;

						if (level[0] + level[4] != level[1]) {
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							cost[1] = 0;
							income[1] = 0;

							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 6] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 6] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					methodLevel[pm[choice - 6]] = iIn - 1;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				if (iIn < level[1])
					level[1] = iIn;
				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				if (iIn > level[0]) {
					level[0] = iIn;
					workers[1] = 0;
					
					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;
						accepted[i][1] = 0;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;

						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						if (accepted[i][1] < 0)
							accepted[i][1] = 0;
						workers[1] += accepted[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				}
				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(3) + 1), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(3) + good[i].getThroughput() + 1), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[4] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			if (building[bIt].hasEOS()) {
				throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

				if (throughput[1] > eosCap)
					throughput[1] = eosCap;
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
					}
				}
			}
			else {
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
					}
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						}
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void stateImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[7] = { location[lIt].getLevel(), 0, 0, 0, 1, 0, 0 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	float throughput[2];
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float purchaseWeight[GSIZE];
	float localPurchaseWeight[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	if (building[bIt].hasEOS() || building[bIt].buildable() && !building[bIt].autoSubsidized()) {
		throughput[1] = (float(level[0]) + 1) / 100 + 1;
		if (throughput[1] > eosCap)
			throughput[1] = eosCap;
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
		}
	}
	else {
		for (int i = 0; i < GSIZE; i++) {
			for (int j = 0; j < 2; j++) {
				good[i].setInput(j);
				good[i].setOutput(j);
			}
			for (int j = 0; j < building[bIt].getSize(); j++) {
				good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
				good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
			}
			good[i].setInputOutput(1);
			input[i] = good[i].getInput(1);
			output[i] = good[i].getOutput(1);
		}
	}
	for (int i = 0; i < GSIZE; i++) {
		purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
		localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);
		if (good[i].localGood()) {
			cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
		}
		else {
			cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[2] << endl;
			if (building[bIt].getThroughput(5) != 0)
				cout << "Company Owned Level: " << level[3] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[4] << endl;
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << "Nationalized Level: " << level[5] << endl;
			if (building[bIt].getThroughput(6) != 0)
				cout << "Company Owned Level: " << level[6] << endl;
		}
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[4] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[4] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[4] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[4] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[4] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 3;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set Nationalized Level\n";
			if (building[bIt].getThroughput(5) != 0)
				cout << i++ << ". Set Company Owned Level\n";
		}
		cout << i++ << ". Set New Level\n";
		if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			cout << i++ << ". Set New Nationalized Level\n";
			if (building[bIt].getThroughput(6) != 0)
				cout << i++ << ". Set New Company Owned Level\n";
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitabilityImportsCanceled(good, method, building, location, profession, input, output, purchaseWeight, localPurchaseWeight, cost, income, profit, mapi, level[1], level[4], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (building[bIt].buildable() && !building[bIt].autoSubsidized()) {
			if (choice == 1) {
				system("cls");
				cout << "Enter State Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[0] = iIn;

					if (iIn < level[1]) {
						level[1] = iIn;

						if (iIn < level[2])
							level[2] = iIn;
					}
					if (iIn < level[3])
						level[3] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < 2; i++)
						workers[i] = 0;
					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;

						for (int j = 0; j < 2; j++) {
							accepted[i][j] = 0;
							citizen[i][j] = 0;
							prejudice[i][j] = 0;
							erasure[i][j] = 0;
							hostile[i][j] = 0;
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						for (int j = 0; j < 2; j++) {
							if (accepted[i][j] < 0)
								accepted[i][j] = 0;
							workers[j] += accepted[i][j];
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 2) {
				system("cls");
				cout << "Enter Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[1] = iIn;
					workers[0] = 0;

					if (iIn > level[0]) {
						level[0] = iIn;
						workers[1] = 0;

						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							baseAccepted[i] = 0;
							baseCitizen[i] = 0;
							basePrejudice[i] = 0;
							baseErasure[i] = 0;
							baseHostile[i] = 0;
							accepted[i][1] = 0;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;

							for (int j = 0; j < building[bIt].getSize(); j++) {
								baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
								accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							}
							if (baseAccepted[i] < 0)
								baseAccepted[i] = 0;
							if (accepted[i][1] < 0)
								accepted[i][1] = 0;
							workers[1] += accepted[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					else if (iIn < level[2])
						level[2] = iIn;
					else if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][0] = profession;
							citizen[i][0] = 0;
							prejudice[i][0] = 0;
							erasure[i][0] = 0;
							hostile[i][0] = 0;
						}
						else {
							accepted[i][0] = float(profession) / employees * baseAccepted[i];
							citizen[i][0] = float(profession) / employees * baseCitizen[i];
							prejudice[i][0] = float(profession) / employees * basePrejudice[i];
							erasure[i][0] = float(profession) / employees * baseErasure[i];
							hostile[i][0] = float(profession) / employees * baseHostile[i];
						}
						workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
					}
					wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (choice == 3) {
				system("cls");
				cout << "Enter Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[2] = iIn;

					if (iIn > level[1]) {
						level[1] = iIn;
						workers[0] = 0;

						if (iIn > level[0]) {
							level[0] = iIn;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								baseAccepted[i] = 0;
								baseCitizen[i] = 0;
								basePrejudice[i] = 0;
								baseErasure[i] = 0;
								baseHostile[i] = 0;
								accepted[i][1] = 0;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;

								for (int j = 0; j < building[bIt].getSize(); j++) {
									baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
									accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								}
								if (baseAccepted[i] < 0)
									baseAccepted[i] = 0;
								if (accepted[i][1] < 0)
									accepted[i][1] = 0;
								workers[1] += accepted[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][0] = profession;
								citizen[i][0] = 0;
								prejudice[i][0] = 0;
								erasure[i][0] = 0;
								hostile[i][0] = 0;
							}
							else {
								accepted[i][0] = float(profession) / employees * baseAccepted[i];
								citizen[i][0] = float(profession) / employees * baseCitizen[i];
								prejudice[i][0] = float(profession) / employees * basePrejudice[i];
								erasure[i][0] = float(profession) / employees * baseErasure[i];
								hostile[i][0] = float(profession) / employees * baseHostile[i];
							}
							workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
						}
						wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
						}
					}
					throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

					if (throughput[0] > eosCap)
						throughput[0] = eosCap;
					if (level[0] != 0)
						throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);
					else {
						throughput[0] += building[bIt].getThroughput(5);
					}
					for (i = 0; i < 2; i++) {
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
			else if (building[bIt].getThroughput(5) != 0) {
				if (choice == 4) {
					system("cls");
					cout << "Enter Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0])
							iIn = level[0];
						level[3] = iIn;

						if (level[0] != 0) {
							throughput[0] = (float(level[0]) * 2 - float(level[2])) / 200 + 1;

							if (throughput[0] > eosCap)
								throughput[0] = eosCap;
							throughput[0] += building[bIt].getThroughput(5) * float(level[3]) / float(level[0]);

							for (i = 0; i < 2; i++) {
								cost[i] = 0;
								income[i] = 0;
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(0);
								good[i].setOutput(0);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
									good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
								}
								good[i].setInputOutput(0);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);
							}
							for (i = 0; i < GSIZE; i++) {
								purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
								localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

								if (good[i].localGood()) {
									cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
									income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
									cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								}
								else {
									cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
									income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
									cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								}
							}
							for (i = 0; i < 2; i++) {
								profit[i][0] = income[i] - cost[i];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[i][1] = income[i] - cost[i] * 0.9;
									profit[i][2] = income[i] - cost[i] * 0.75;
									profit[i][3] = income[i] - cost[i] * 0.65;
									profit[i][4] = income[i] - cost[i] * 0.5;
									profit[i][5] = income[i] - cost[i] * 0.25;
								}
							}
						}
					}
				}
				else if (choice == 5) {
					system("cls");
					cout << "Enter New Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[4] = iIn;
						workers[1] = 0;

						if (iIn < level[5])
							level[5] = iIn;
						if (level[0] + level[4] - level[1] < level[6])
							level[6] = level[0] + level[4] - level[1];
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (choice == 6) {
					system("cls");
					cout << "Enter New Nationalized Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						level[5] = iIn;

						if (iIn > level[4]) {
							level[4] = iIn;
							workers[1] = 0;
							
							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						}
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
				else if (building[bIt].getThroughput(6) != 0) {
					if (choice == 7) {
						system("cls");
						cout << "Enter New Company Owned Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 0) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							if (iIn > level[0] + level[4] - level[1])
								iIn = level[0] + level[4] - level[1];
							level[6] = iIn;

							if (level[0] + level[4] != level[1]) {
								throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

								if (throughput[1] > eosCap)
									throughput[1] = eosCap;
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
								cost[1] = 0;
								income[1] = 0;

								for (i = 0; i < GSIZE; i++) {
									good[i].setInput(1);
									good[i].setOutput(1);

									for (int j = 0; j < building[bIt].getSize(); j++) {
										good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
										good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
									}
									good[i].setInputOutput(1);
									input[i] = good[i].getInput(1) - good[i].getInput(0);
									output[i] = good[i].getOutput(1) - good[i].getOutput(0);
								}
								for (i = 0; i < GSIZE; i++) {
									purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
									localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

									if (good[i].localGood()) {
										cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
										income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									}
									else {
										cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
										income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									}
								}
								profit[1][0] = income[1] - cost[1];

								if (building[bIt].getBuilding() == "Construction Sector") {
									profit[1][1] = income[1] - cost[1] * 0.9;
									profit[1][2] = income[1] - cost[1] * 0.75;
									profit[1][3] = income[1] - cost[1] * 0.65;
									profit[1][4] = income[1] - cost[1] * 0.5;
									profit[1][5] = income[1] - cost[1] * 0.25;
								}
							}
						}
					}
					else {
						system("cls");
						cout << "Enter " << method.getProductionMethod(pm[choice - 8] + building[bIt].getProductionMethod()) << " Level: ";
						cin >> iIn;

						if (!cin) {
							cin.clear();
							cin.ignore(numeric_limits<streamsize>::max(), '\n');
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else if (iIn < 1 || iIn > method.getSize(pm[choice - 8] + building[bIt].getProductionMethod())) {
							system("cls");
							cout << "Error invalid input\n\n";
							system("pause");
						}
						else {
							methodLevel[pm[choice - 8]] = iIn - 1;
							workers[1] = 0;

							for (i = 0; i < PSIZE; i++) {
								int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
								int profession = 0;

								for (int j = 0; j < building[bIt].getSize(); j++)
									profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
								if (profession < 0)
									profession = 0;
								if (employees == 0) {
									accepted[i][1] = profession;
									citizen[i][1] = 0;
									prejudice[i][1] = 0;
									erasure[i][1] = 0;
									hostile[i][1] = 0;
								}
								else {
									accepted[i][1] = float(profession) / employees * baseAccepted[i];
									citizen[i][1] = float(profession) / employees * baseCitizen[i];
									prejudice[i][1] = float(profession) / employees * basePrejudice[i];
									erasure[i][1] = float(profession) / employees * baseErasure[i];
									hostile[i][1] = float(profession) / employees * baseHostile[i];
								}
								workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
							}
							wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
							cost[1] = 0;
							income[1] = 0;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							if (level[0] + level[4] != level[1])
								throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							else {
								throughput[1] += building[bIt].getThroughput(6);
							}
							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);
							}
							for (i = 0; i < GSIZE; i++) {
								purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
								localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else if (choice == 4) {
				system("cls");
				cout << "Enter New Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[4] = iIn;
					workers[1] = 0;

					if (iIn < level[5])
						level[5] = iIn;
					if (level[0] + level[4] - level[1] < level[6])
						level[6] = level[0] + level[4] - level[1];
					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (choice == 5) {
				system("cls");
				cout << "Enter New Nationalized Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 0) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					level[5] = iIn;

					if (iIn > level[4]) {
						level[4] = iIn;
						workers[1] = 0;
						
						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					}
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
			else if (building[bIt].getThroughput(6) != 0) {
				if (choice == 6) {
					system("cls");
					cout << "Enter New Company Owned Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 0) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						if (iIn > level[0] + level[4] - level[1])
							iIn = level[0] + level[4] - level[1];
						level[6] = iIn;

						if (level[0] + level[4] != level[1]) {
							throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;

							if (throughput[1] > eosCap)
								throughput[1] = eosCap;
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
							cost[1] = 0;
							income[1] = 0;

							for (i = 0; i < GSIZE; i++) {
								good[i].setInput(1);
								good[i].setOutput(1);

								for (int j = 0; j < building[bIt].getSize(); j++) {
									good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
									good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
								}
								good[i].setInputOutput(1);
								input[i] = good[i].getInput(1) - good[i].getInput(0);
								output[i] = good[i].getOutput(1) - good[i].getOutput(0);
							}
							for (i = 0; i < GSIZE; i++) {
								purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
								localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

								if (good[i].localGood()) {
									cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								}
								else {
									cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
									income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								}
							}
							profit[1][0] = income[1] - cost[1];

							if (building[bIt].getBuilding() == "Construction Sector") {
								profit[1][1] = income[1] - cost[1] * 0.9;
								profit[1][2] = income[1] - cost[1] * 0.75;
								profit[1][3] = income[1] - cost[1] * 0.65;
								profit[1][4] = income[1] - cost[1] * 0.5;
								profit[1][5] = income[1] - cost[1] * 0.25;
							}
						}
					}
				}
				else {
					system("cls");
					cout << "Enter " << method.getProductionMethod(pm[choice - 7] + building[bIt].getProductionMethod()) << " Level: ";
					cin >> iIn;

					if (!cin) {
						cin.clear();
						cin.ignore(numeric_limits<streamsize>::max(), '\n');
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else if (iIn < 1 || iIn > method.getSize(pm[choice - 7] + building[bIt].getProductionMethod())) {
						system("cls");
						cout << "Error invalid input\n\n";
						system("pause");
					}
					else {
						methodLevel[pm[choice - 7]] = iIn - 1;
						workers[1] = 0;

						for (i = 0; i < PSIZE; i++) {
							int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
							int profession = 0;

							for (int j = 0; j < building[bIt].getSize(); j++)
								profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
							if (profession < 0)
								profession = 0;
							if (employees == 0) {
								accepted[i][1] = profession;
								citizen[i][1] = 0;
								prejudice[i][1] = 0;
								erasure[i][1] = 0;
								hostile[i][1] = 0;
							}
							else {
								accepted[i][1] = float(profession) / employees * baseAccepted[i];
								citizen[i][1] = float(profession) / employees * baseCitizen[i];
								prejudice[i][1] = float(profession) / employees * basePrejudice[i];
								erasure[i][1] = float(profession) / employees * baseErasure[i];
								hostile[i][1] = float(profession) / employees * baseHostile[i];
							}
							workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
						}
						wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
						throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
						cost[1] = 0;
						income[1] = 0;

						if (throughput[1] > eosCap)
							throughput[1] = eosCap;
						if (level[0] + level[4] != level[1])
							throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
						else {
							throughput[1] += building[bIt].getThroughput(6);
						}
						for (i = 0; i < GSIZE; i++) {
							good[i].setInput(1);
							good[i].setOutput(1);

							for (int j = 0; j < building[bIt].getSize(); j++) {
								good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
								good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
							}
							good[i].setInputOutput(1);
							input[i] = good[i].getInput(1) - good[i].getInput(0);
							output[i] = good[i].getOutput(1) - good[i].getOutput(0);
						}
						for (i = 0; i < GSIZE; i++) {
							purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
							localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

							if (good[i].localGood()) {
								cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							}
							else {
								cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
								income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							}
						}
						profit[1][0] = income[1] - cost[1];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[1][1] = income[1] - cost[1] * 0.9;
							profit[1][2] = income[1] - cost[1] * 0.75;
							profit[1][3] = income[1] - cost[1] * 0.65;
							profit[1][4] = income[1] - cost[1] * 0.5;
							profit[1][5] = income[1] - cost[1] * 0.25;
						}
					}
				}
			}
			else {
				system("cls");
				cout << "Enter " << method.getProductionMethod(pm[choice - 6] + building[bIt].getProductionMethod()) << " Level: ";
				cin >> iIn;

				if (!cin) {
					cin.clear();
					cin.ignore(numeric_limits<streamsize>::max(), '\n');
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else if (iIn < 1 || iIn > method.getSize(pm[choice - 6] + building[bIt].getProductionMethod())) {
					system("cls");
					cout << "Error invalid input\n\n";
					system("pause");
				}
				else {
					methodLevel[pm[choice - 6]] = iIn - 1;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
						int profession = 0;

						for (int j = 0; j < building[bIt].getSize(); j++)
							profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						if (profession < 0)
							profession = 0;
						if (employees == 0) {
							accepted[i][1] = profession;
							citizen[i][1] = 0;
							prejudice[i][1] = 0;
							erasure[i][1] = 0;
							hostile[i][1] = 0;
						}
						else {
							accepted[i][1] = float(profession) / employees * baseAccepted[i];
							citizen[i][1] = float(profession) / employees * baseCitizen[i];
							prejudice[i][1] = float(profession) / employees * basePrejudice[i];
							erasure[i][1] = float(profession) / employees * baseErasure[i];
							hostile[i][1] = float(profession) / employees * baseHostile[i];
						}
						workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
					throughput[1] = ((float(level[0]) + float(level[4]) - float(level[1])) * 2 - float(level[5])) / 200 + 1;
					cost[1] = 0;
					income[1] = 0;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					if (level[0] + level[4] != level[1])
						throughput[1] += building[bIt].getThroughput(6) * float(level[6]) / (float(level[0]) + float(level[4]) - float(level[1]));
					else {
						throughput[1] += building[bIt].getThroughput(6);
					}
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					profit[1][0] = income[1] - cost[1];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[1][1] = income[1] - cost[1] * 0.9;
						profit[1][2] = income[1] - cost[1] * 0.75;
						profit[1][3] = income[1] - cost[1] * 0.65;
						profit[1][4] = income[1] - cost[1] * 0.5;
						profit[1][5] = income[1] - cost[1] * 0.25;
					}
				}
			}
		}
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				if (iIn < level[1])
					level[1] = iIn;
				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
						cost[i] = 0;
						income[i] = 0;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
					for (i = 0; i < GSIZE; i++) {
						purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
						localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

						if (good[i].localGood()) {
							cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
							income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
							cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						}
						else {
							cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
							income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
							cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
							income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						}
					}
					for (i = 0; i < 2; i++) {
						profit[i][0] = income[i] - cost[i];

						if (building[bIt].getBuilding() == "Construction Sector") {
							profit[i][1] = income[i] - cost[i] * 0.9;
							profit[i][2] = income[i] - cost[i] * 0.75;
							profit[i][3] = income[i] - cost[i] * 0.65;
							profit[i][4] = income[i] - cost[i] * 0.5;
							profit[i][5] = income[i] - cost[i] * 0.25;
						}
					}
				}
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				if (iIn > level[0]) {
					level[0] = iIn;
					workers[1] = 0;

					for (i = 0; i < PSIZE; i++) {
						baseAccepted[i] = 0;
						baseCitizen[i] = 0;
						basePrejudice[i] = 0;
						baseErasure[i] = 0;
						baseHostile[i] = 0;
						accepted[i][1] = 0;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;

						for (int j = 0; j < building[bIt].getSize(); j++) {
							baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
							accepted[i][1] += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
						}
						if (baseAccepted[i] < 0)
							baseAccepted[i] = 0;
						if (accepted[i][1] < 0)
							accepted[i][1] = 0;
						workers[1] += accepted[i][1];
					}
					wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				}
				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				if (building[bIt].hasEOS()) {
					throughput[0] = float(level[0]) / 100 + 1;
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					for (i = 0; i < 2; i++) {
						if (throughput[i] > eosCap)
							throughput[i] = eosCap;
					}
					for (i = 0; i < GSIZE; i++) {
						for (int j = 0; j < 2; j++) {
							good[i].setInput(j);
							good[i].setOutput(j);
						}
						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (throughput[0] + building[bIt].getThroughput(3)), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (throughput[0] + building[bIt].getThroughput(3) + good[i].getThroughput()), 0);
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						for (int j = 0; j < 2; j++)
							good[i].setInputOutput(j);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(0);
						good[i].setOutput(0);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(3) + 1), 0);
							good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(3) + good[i].getThroughput() + 1), 0);
						}
						good[i].setInputOutput(0);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
						income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
						income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[4] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			if (building[bIt].hasEOS()) {
				throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

				if (throughput[1] > eosCap)
					throughput[1] = eosCap;
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
			}
			else {
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
						good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
			}
			for (i = 0; i < GSIZE; i++) {
				purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
				localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

				if (good[i].localGood()) {
					cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
				}
				else {
					cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[4] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				if (building[bIt].hasEOS()) {
					throughput[1] = (float(level[0]) + float(level[4]) - float(level[1])) / 100 + 1;

					if (throughput[1] > eosCap)
						throughput[1] = eosCap;
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (throughput[1] + building[bIt].getThroughput(4)), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (throughput[1] + building[bIt].getThroughput(4) + good[i].getThroughput()), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				else {
					for (i = 0; i < GSIZE; i++) {
						good[i].setInput(1);
						good[i].setOutput(1);

						for (int j = 0; j < building[bIt].getSize(); j++) {
							good[i].setInput(level[4] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(4) + 1), 1);
							good[i].setOutput(level[4] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(4) + good[i].getThroughput() + 1), 1);
						}
						good[i].setInputOutput(1);
						input[i] = good[i].getInput(1) - good[i].getInput(0);
						output[i] = good[i].getOutput(1) - good[i].getOutput(0);
					}
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void stateEoSOverride(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[3] = { location[lIt].getLevel(), 0, 1 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	for (int i = 0; i < GSIZE; i++) {
		for (int j = 0; j < 2; j++) {
			good[i].setInput(j);
			good[i].setOutput(j);
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
		}
		good[i].setInputOutput(1);
		input[i] = good[i].getInput(1);
		output[i] = good[i].getOutput(1);
		if (good[i].localGood()) {
			cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
			income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
		}
		else {
			cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
			income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[2] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[2] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[2] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[2] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[2] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 4;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n"
			 << "3. Set New Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(0);
					good[i].setOutput(0);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(1) + 1), 0);
						good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(1) + good[i].getThroughput() + 1), 0);
					}
					good[i].setInputOutput(0);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
						income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
						income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
						cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[2] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitability(good, method, building, location, profession, input, output, cost, income, profit, mapi, level[1], level[2], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			for (i = 0; i < GSIZE; i++) {
				good[i].setInput(1);
				good[i].setOutput(1);

				for (int j = 0; j < building[bIt].getSize(); j++) {
					good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
					good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
				}
				good[i].setInputOutput(1);
				input[i] = good[i].getInput(1) - good[i].getInput(0);
				output[i] = good[i].getOutput(1) - good[i].getOutput(0);

				if (good[i].localGood()) {
					cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
					income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
				}
				else {
					cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
					income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPrice(mapi, input[i], output[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void stateEoSOverride(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[3] = { location[lIt].getLevel(), 0, 1 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float purchaseWeight[GSIZE];
	float localPurchaseWeight[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	for (int i = 0; i < GSIZE; i++) {
		for (int j = 0; j < 2; j++) {
			good[i].setInput(j);
			good[i].setOutput(j);
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
		}
		good[i].setInputOutput(1);
		input[i] = good[i].getInput(1);
		output[i] = good[i].getOutput(1);
	}
	for (int i = 0; i < GSIZE; i++) {
		purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
		localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);
		if (good[i].localGood()) {
			cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
		}
		else {
			cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[2] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[2] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[2] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[2] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[2] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 4;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n"
			 << "3. Set New Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(0);
					good[i].setOutput(0);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(1) + 1), 0);
						good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(1) + good[i].getThroughput() + 1), 0);
					}
					good[i].setInputOutput(0);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
						income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
						income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[2] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitability(good, method, building, location, profession, input, output, purchaseWeight, localPurchaseWeight, cost, income, profit, mapi, level[1], level[2], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			for (i = 0; i < GSIZE; i++) {
				good[i].setInput(1);
				good[i].setOutput(1);

				for (int j = 0; j < building[bIt].getSize(); j++) {
					good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
					good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
				}
				good[i].setInputOutput(1);
				input[i] = good[i].getInput(1) - good[i].getInput(0);
				output[i] = good[i].getOutput(1) - good[i].getOutput(0);
			}
			for (i = 0; i < GSIZE; i++) {
				purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
				localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

				if (good[i].localGood()) {
					cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
				}
				else {
					cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeight(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeight(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void stateEoSOverrideImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[3] = { location[lIt].getLevel(), 0, 1 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	for (int i = 0; i < GSIZE; i++) {
		for (int j = 0; j < 2; j++) {
			good[i].setInput(j);
			good[i].setOutput(j);
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
		}
		good[i].setInputOutput(1);
		input[i] = good[i].getInput(1);
		output[i] = good[i].getOutput(1);
		if (good[i].localGood()) {
			cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
			income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
		}
		else {
			cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
			income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[2] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[2] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[2] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports())) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports())) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[2] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[2] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 4;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n"
			 << "3. Set New Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(0);
					good[i].setOutput(0);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(1) + 1), 0);
						good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(1) + good[i].getThroughput() + 1), 0);
					}
					good[i].setInputOutput(0);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
						income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
						income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
						cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[2] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitabilityImportsCanceled(good, method, building, location, profession, input, output, cost, income, profit, mapi, level[1], level[2], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			for (i = 0; i < GSIZE; i++) {
				good[i].setInput(1);
				good[i].setOutput(1);

				for (int j = 0; j < building[bIt].getSize(); j++) {
					good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
					good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
				}
				good[i].setInputOutput(1);
				input[i] = good[i].getInput(1) - good[i].getInput(0);
				output[i] = good[i].getOutput(1) - good[i].getOutput(0);

				if (good[i].localGood()) {
					cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
					income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
				}
				else {
					cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
					income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPrice(input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPrice(input[i], output[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

void stateEoSOverrideImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float mapi, float gdp, float averageGdp, float eosCap, int citizenship[2], bool mobilization[ASIZE][2], int bIt, int lIt)
{
	int level[3] = { location[lIt].getLevel(), 0, 1 };
	int methodLevel[LSIZE];
	for (int i = 0; i < building[bIt].getSize(); i++)
		methodLevel[i] = location[lIt].getProductionMethodLevel(i);
	int workers[2] = { 0 };
	int baseAccepted[PSIZE] = { 0 };
	int baseCitizen[PSIZE] = { 0 };
	int basePrejudice[PSIZE] = { 0 };
	int baseErasure[PSIZE] = { 0 };
	int baseHostile[PSIZE] = { 0 };
	int accepted[PSIZE][2] = { 0 };
	int citizen[PSIZE][2] = { 0 };
	int prejudice[PSIZE][2] = { 0 };
	int erasure[PSIZE][2] = { 0 };
	int hostile[PSIZE][2] = { 0 };
	for (int i = 0; i < PSIZE; i++) {
		for (int j = 0; j < building[bIt].getSize(); j++) {
			baseAccepted[i] += location[lIt].getLevel() * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
			accepted[i][1] += method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
		}
		if (baseAccepted[i] < 0)
			baseAccepted[i] = 0;
		if (accepted[i][1] < 0)
			accepted[i][1] = 0;
		workers[1] += accepted[i][1];
	}
	float wage[2] = { building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0), building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1) };
	float input[GSIZE];
	float output[GSIZE];
	float purchaseWeight[GSIZE];
	float localPurchaseWeight[GSIZE];
	float cost[2] = { 0 };
	float income[2] = { 0 };
	float profit[2][6] = { 0 };
	for (int i = 0; i < GSIZE; i++) {
		for (int j = 0; j < 2; j++) {
			good[i].setInput(j);
			good[i].setOutput(j);
		}
		for (int j = 0; j < building[bIt].getSize(); j++) {
			good[i].setInput(method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
			good[i].setOutput(method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
		}
		good[i].setInputOutput(1);
		input[i] = good[i].getInput(1);
		output[i] = good[i].getOutput(1);
	}
	for (int i = 0; i < GSIZE; i++) {
		purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
		localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);
		if (good[i].localGood()) {
			cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
		}
		else {
			cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
			income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
		}
	}
	profit[1][0] = income[1] - cost[1];
	if (building[bIt].getBuilding() == "Construction Sector") {
		profit[1][1] = income[1] - cost[1] * 0.9;
		profit[1][2] = income[1] - cost[1] * 0.75;
		profit[1][3] = income[1] - cost[1] * 0.65;
		profit[1][4] = income[1] - cost[1] * 0.5;
		profit[1][5] = income[1] - cost[1] * 0.25;
	}
	int choice;
	int iIn;
	bool exit = false;

	do {
		int pm[LSIZE] = { 0 };
		int it = 0;
		system("cls");

		cout << building[bIt].getBuilding() << endl
			 << "State Level: " << level[0] << endl
			 << "Level: " << level[1] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getArmyUnitType(i);
					else {
						cout << location[lIt].getNavyUnitType(i);
					}
				}
				else {
					cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
				}
				cout << endl;
			}
		}
		cout << endl
			 << "Level: " << level[2] << endl;
		for (int i = 0; i < building[bIt].getSize(); i++) {
			if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
				cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
				if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
					cout << ": ";
					if (building[bIt].getBuilding() == "Barracks")
						cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
					else {
						cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
					}
				}
				else {
					cout << " Level: " << methodLevel[i] + 1;
				}
				cout << endl;
			}
		}
		cout << endl;
		if (building[bIt].getInfrastructureUsage(level[2] - level[1]) > 0)
			cout << "Infrastructure Usage: +" << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		else if (building[bIt].getInfrastructureUsage(level[2] - level[1]) < 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level[2] - level[1]) << endl;
		for (int i = 0; i < PSIZE; i++) {
			int employees[2] = { accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0], accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] };
			if (employees[1] > employees[0])
				cout << profession[i] << ": +" << employees[1] - employees[0] << endl;
			else if (employees[1] < employees[0])
				cout << profession[i] << ": " << employees[1] - employees[0] << endl;
		}
		if (cost[0] + cost[1] > 0) {
			cout << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) + good[i].getInput(1) > 0) {
					if (input[i] > 0)
						cout << "+";
					cout << input[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (income[0] + income[1] > 0) {
			cout << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
					if (output[i] > 0)
						cout << "+";
					cout << output[i] << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (level[2] > 0) {
			if (wage[1] != 0) {
				cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
				}
				cout << "Production: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Production: $" << trunc2D(income[1]) << endl;
				}
			}
			else {
				cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
						 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
						 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
						 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
						 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl
						 << "No Construction Profit: $" << trunc2D(income[1]) << endl;
				}
			}
			if (profit[1][0] > 0) {
				cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
				if (building[bIt].buildable()) {
					cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
						 << "Profitability: $" << trunc2D(20 * profit[1][0] / level[2] / building[bIt].getConstructionCost()) << endl;
				}
			}
		}
		if (level[1] > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]) << endl;
				}
			}
		}
		int i = 4;
		cout << endl
			 << "1. Set State Level\n"
			 << "2. Set Level\n"
			 << "3. Set New Level\n";
		for (int j = 0; j < building[bIt].getSize(); j++) {
			if (method.getSize(j + building[bIt].getProductionMethod()) > 1) {
				pm[it++] = j;
				cout << i++ << ". Set " << method.getProductionMethod(j + building[bIt].getProductionMethod());
				if (method.getProductionMethod(j + building[bIt].getProductionMethod()) != "Military Unit Type")
					cout << " Level";
				cout << endl;
			}
		}
		cout << i++ << ". Set Discriminated Workers\n"
			 << i << ". Profitability\n"
			 << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice == 1) {
			system("cls");
			cout << "Enter State Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[0] = iIn;

				for (i = 0; i < 2; i++)
					workers[i] = 0;
				for (i = 0; i < PSIZE; i++) {
					baseAccepted[i] = 0;
					baseCitizen[i] = 0;
					basePrejudice[i] = 0;
					baseErasure[i] = 0;
					baseHostile[i] = 0;

					for (int j = 0; j < 2; j++) {
						accepted[i][j] = 0;
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					for (int j = 0; j < building[bIt].getSize(); j++) {
						baseAccepted[i] += level[0] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
						accepted[i][1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					}
					if (baseAccepted[i] < 0)
						baseAccepted[i] = 0;
					for (int j = 0; j < 2; j++) {
						if (accepted[i][j] < 0)
							accepted[i][j] = 0;
						workers[j] += accepted[i][j];
					}
				}
				for (i = 0; i < 2; i++)
					wage[i] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, i);
			}
		}
		else if (choice == 2) {
			system("cls");
			cout << "Enter Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[1] = iIn;
				workers[0] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][0] = profession;
						citizen[i][0] = 0;
						prejudice[i][0] = 0;
						erasure[i][0] = 0;
						hostile[i][0] = 0;
					}
					else {
						accepted[i][0] = float(profession) / employees * baseAccepted[i];
						citizen[i][0] = float(profession) / employees * baseCitizen[i];
						prejudice[i][0] = float(profession) / employees * basePrejudice[i];
						erasure[i][0] = float(profession) / employees * baseErasure[i];
						hostile[i][0] = float(profession) / employees * baseHostile[i];
					}
					workers[0] += accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0];
				}
				wage[0] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 0);

				for (i = 0; i < 2; i++) {
					cost[i] = 0;
					income[i] = 0;
				}
				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(0);
					good[i].setOutput(0);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[1] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i, 0) * (building[bIt].getThroughput(1) + 1), 0);
						good[i].setOutput(level[1] * method.getOutputGood(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i) * (building[bIt].getThroughput(1) + good[i].getThroughput() + 1), 0);
					}
					good[i].setInputOutput(0);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[0] += good[i].getInput(0) * good[i].getMarketPrice();
						income[0] += good[i].getOutput(0) * good[i].getMarketPrice();
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[0] += good[i].getInput(0) * good[i].getLocalPrice(mapi);
						income[0] += good[i].getOutput(0) * good[i].getLocalPrice(mapi);
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				for (i = 0; i < 2; i++) {
					profit[i][0] = income[i] - cost[i];

					if (building[bIt].getBuilding() == "Construction Sector") {
						profit[i][1] = income[i] - cost[i] * 0.9;
						profit[i][2] = income[i] - cost[i] * 0.75;
						profit[i][3] = income[i] - cost[i] * 0.65;
						profit[i][4] = income[i] - cost[i] * 0.5;
						profit[i][5] = income[i] - cost[i] * 0.25;
					}
				}
			}
		}
		else if (choice == 3) {
			system("cls");
			cout << "Enter New Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 0) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				level[2] = iIn;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
		else if (choice == i--) {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			profitabilityImportsCanceled(good, method, building, location, profession, input, output, purchaseWeight, localPurchaseWeight, cost, income, profit, mapi, level[1], level[2], methodLevel, workers, accepted, citizen, prejudice, erasure, hostile, wage, bIt, lIt);
		}
		else if (choice == i) {
			employment(profession, baseAccepted, baseCitizen, basePrejudice, baseErasure, baseHostile);

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];

				for (int j = 0; j < 2; j++)
					workers[j] = 0;
				for (int j = 0; j < building[bIt].getSize(); j++) {
					workers[0] += level[1] * method.getProfession(j + building[bIt].getProductionMethod(), location[lIt].getProductionMethodLevel(j), i);
					workers[1] += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				}
				for (int j = 0; j < 2; j++) {
					if (workers[j] < 0)
						workers[j] = 0;
					if (employees == 0) {
						accepted[i][j] = workers[j];
						citizen[i][j] = 0;
						prejudice[i][j] = 0;
						erasure[i][j] = 0;
						hostile[i][j] = 0;
					}
					else {
						accepted[i][j] = float(workers[j]) / employees * baseAccepted[i];
						citizen[i][j] = float(workers[j]) / employees * baseCitizen[i];
						prejudice[i][j] = float(workers[j]) / employees * basePrejudice[i];
						erasure[i][j] = float(workers[j]) / employees * baseErasure[i];
						hostile[i][j] = float(workers[j]) / employees * baseHostile[i];
					}
				}
			}
			for (int j = 0; j < 2; j++) {
				workers[j] = 0;

				for (i = 0; i < PSIZE; i++)
					workers[j] += accepted[i][j] + citizen[i][j] + prejudice[i][j] + erasure[i][j] + hostile[i][j];
				wage[j] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, j);
			}
		}
		else if (method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) == "Military Unit Type") {
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			if (building[bIt].getBuilding() == "Barracks")
				iIn = armyUnitType();
			else {
				iIn = navyUnitType();
			}
			methodLevel[pm[choice - 4]] = iIn;
			workers[1] = 0;

			for (i = 0; i < PSIZE; i++) {
				int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
				int profession = 0;

				for (int j = 0; j < building[bIt].getSize(); j++)
					profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
				if (profession < 0)
					profession = 0;
				if (employees == 0) {
					accepted[i][1] = profession;
					citizen[i][1] = 0;
					prejudice[i][1] = 0;
					erasure[i][1] = 0;
					hostile[i][1] = 0;
				}
				else {
					accepted[i][1] = float(profession) / employees * baseAccepted[i];
					citizen[i][1] = float(profession) / employees * baseCitizen[i];
					prejudice[i][1] = float(profession) / employees * basePrejudice[i];
					erasure[i][1] = float(profession) / employees * baseErasure[i];
					hostile[i][1] = float(profession) / employees * baseHostile[i];
				}
				workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
			}
			wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
			cost[1] = 0;
			income[1] = 0;

			for (i = 0; i < GSIZE; i++) {
				good[i].setInput(1);
				good[i].setOutput(1);

				for (int j = 0; j < building[bIt].getSize(); j++) {
					good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
					good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
				}
				good[i].setInputOutput(1);
				input[i] = good[i].getInput(1) - good[i].getInput(0);
				output[i] = good[i].getOutput(1) - good[i].getOutput(0);
			}
			for (i = 0; i < GSIZE; i++) {
				purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
				localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

				if (good[i].localGood()) {
					cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
				}
				else {
					cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
				}
			}
			profit[1][0] = income[1] - cost[1];

			if (building[bIt].getBuilding() == "Construction Sector") {
				profit[1][1] = income[1] - cost[1] * 0.9;
				profit[1][2] = income[1] - cost[1] * 0.75;
				profit[1][3] = income[1] - cost[1] * 0.65;
				profit[1][4] = income[1] - cost[1] * 0.5;
				profit[1][5] = income[1] - cost[1] * 0.25;
			}
		}
		else {
			system("cls");
			cout << "Enter " << method.getProductionMethod(pm[choice - 4] + building[bIt].getProductionMethod()) << " Level: ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else if (iIn < 1 || iIn > method.getSize(pm[choice - 4] + building[bIt].getProductionMethod())) {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				methodLevel[pm[choice - 4]] = iIn - 1;
				workers[1] = 0;

				for (i = 0; i < PSIZE; i++) {
					int employees = baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i];
					int profession = 0;

					for (int j = 0; j < building[bIt].getSize(); j++)
						profession += level[2] * method.getProfession(j + building[bIt].getProductionMethod(), methodLevel[j], i);
					if (profession < 0)
						profession = 0;
					if (employees == 0) {
						accepted[i][1] = profession;
						citizen[i][1] = 0;
						prejudice[i][1] = 0;
						erasure[i][1] = 0;
						hostile[i][1] = 0;
					}
					else {
						accepted[i][1] = float(profession) / employees * baseAccepted[i];
						citizen[i][1] = float(profession) / employees * baseCitizen[i];
						prejudice[i][1] = float(profession) / employees * basePrejudice[i];
						erasure[i][1] = float(profession) / employees * baseErasure[i];
						hostile[i][1] = float(profession) / employees * baseHostile[i];
					}
					workers[1] += accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1];
				}
				wage[1] = building[bIt].getWage(citizenship, accepted, citizen, prejudice, erasure, hostile, 1);
				cost[1] = 0;
				income[1] = 0;

				for (i = 0; i < GSIZE; i++) {
					good[i].setInput(1);
					good[i].setOutput(1);

					for (int j = 0; j < building[bIt].getSize(); j++) {
						good[i].setInput(level[2] * method.getInputGood(good[i], building[bIt].getBuilding(), mobilization, j + building[bIt].getProductionMethod(), methodLevel[j], i, 1) * (building[bIt].getThroughput(2) + 1), 1);
						good[i].setOutput(level[2] * method.getOutputGood(j + building[bIt].getProductionMethod(), methodLevel[j], i) * (building[bIt].getThroughput(2) + good[i].getThroughput() + 1), 1);
					}
					good[i].setInputOutput(1);
					input[i] = good[i].getInput(1) - good[i].getInput(0);
					output[i] = good[i].getOutput(1) - good[i].getOutput(0);
				}
				for (i = 0; i < GSIZE; i++) {
					purchaseWeight[i] = getPurchaseWeightImportsCanceled(good, input, output, averageGdp, i);
					localPurchaseWeight[i] = getLocalPurchaseWeightImportsCanceled(good, input, output, gdp, i);

					if (good[i].localGood()) {
						cost[1] += good[i].getInput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]);
					}
					else {
						cost[1] += good[i].getInput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
						income[1] += good[i].getOutput(1) * good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]);
					}
				}
				profit[1][0] = income[1] - cost[1];

				if (building[bIt].getBuilding() == "Construction Sector") {
					profit[1][1] = income[1] - cost[1] * 0.9;
					profit[1][2] = income[1] - cost[1] * 0.75;
					profit[1][3] = income[1] - cost[1] * 0.65;
					profit[1][4] = income[1] - cost[1] * 0.5;
					profit[1][5] = income[1] - cost[1] * 0.25;
				}
			}
		}
	} while (!exit);
}

int armyUnitType()
{
	string in;
	char choice;
	system("cls");

	cout << "1. Set Military Unit Type to Irregular Infantry\n"
		 << "2. Set Military Unit Type to Line Infantry\n"
		 << "3. Set Military Unit Type to Skirmish Infantry\n"
		 << "4. Set Military Unit Type to Trench Infantry\n"
		 << "5. Set Military Unit Type to Squad Infantry\n"
		 << "6. Set Military Unit Type to Mechanized Infantry\n"
		 << "7. Set Military Unit Type to Cannon Artillery\n"
		 << "8. Set Military Unit Type to Mobile Artillery\n"
		 << "9. Set Military Unit Type to Shrapnel Artillery\n"
		 << "10. Set Military Unit Type to Siege Artillery\n"
		 << "11. Set Military Unit Type to Heavy Tanks\n"
		 << "12. Set Military Unit Type to Hussars\n"
		 << "13. Set Military Unit Type to Dragoons\n"
		 << "14. Set Military Unit Type to Cuirassiers\n"
		 << "15. Set Military Unit Type to Lancers\n"
		 << "16. Set Military Unit Type to Light Tanks\n"
		 << "Enter your choice: ";
	getline(cin, in);
	if (in.length() == 1) {
		choice = in[0];
		switch (choice) {
		case '1':
			return 0;
		case '2':
			return 1;
		case '3':
			return 2;
		case '4':
			return 3;
		case '5':
			return 4;
		case '6':
			return 5;
		case '7':
			return 6;
		case '8':
			return 7;
		case '9':
			return 8;
		default:
			system("cls");
			cout << "Error choose 1-16\n\n";
			system("pause");
			return armyUnitType();
		}
	}
	else if (in.length() == 2) {
		choice = in[0];
		if (choice == '1') {
			choice = in[1];
			switch (choice) {
			case '0':
				return 9;
			case '1':
				return 10;
			case '2':
				return 11;
			case '3':
				return 12;
			case '4':
				return 13;
			case '5':
				return 14;
			case '6':
				return 15;
			default:
				system("cls");
				cout << "Error choose 1-16\n\n";
				system("pause");
				return armyUnitType();
			}
		}
		else {
			system("cls");
			cout << "Error choose 1-16\n\n";
			system("pause");
			return armyUnitType();
		}
	}
	else {
		system("cls");
		cout << "Error choose 1-16\n\n";
		system("pause");
		return armyUnitType();
	}
}

int navyUnitType()
{
	string in;
	char choice;
	system("cls");

	cout << "1. Set Military Unit Type to Frigates\n"
		 << "2. Set Military Unit Type to Monitors\n"
		 << "3. Set Military Unit Type to Destroyers\n"
		 << "4. Set Military Unit Type to Torpedo Boats\n"
		 << "5. Set Military Unit Type to Scout Cruisers\n"
		 << "6. Set Military Unit Type to Man-o-wars\n"
		 << "7. Set Military Unit Type to Ironclads\n"
		 << "8. Set Military Unit Type to Dreadnoughts\n"
		 << "9. Set Military Unit Type to Battleships\n"
		 << "10. Set Military Unit Type to Submarines\n"
		 << "11. Set Military Unit Type to Carriers\n"
		 << "Enter your choice: ";
	getline(cin, in);
	if (in.length() == 1) {
		choice = in[0];
		switch (choice) {
		case '1':
			return 0;
		case '2':
			return 1;
		case '3':
			return 2;
		case '4':
			return 3;
		case '5':
			return 4;
		case '6':
			return 5;
		case '7':
			return 6;
		case '8':
			return 7;
		case '9':
			return 8;
		default:
			system("cls");
			cout << "Error choose 1-11\n\n";
			system("pause");
			return navyUnitType();
		}
	}
	else if (in.length() == 2) {
		choice = in[0];
		if (choice == '1') {
			choice = in[1];
			switch (choice) {
			case '0':
				return 9;
			case '1':
				return 10;
			default:
				system("cls");
				cout << "Error choose 1-11\n\n";
				system("pause");
				return navyUnitType();
			}
		}
		else {
			system("cls");
			cout << "Error choose 1-11\n\n";
			system("pause");
			return navyUnitType();
		}
	}
	else {
		system("cls");
		cout << "Error choose 1-11\n\n";
		system("pause");
		return navyUnitType();
	}
}

void employment(string profession[PSIZE], int baseAccepted[PSIZE], int baseCitizen[PSIZE], int basePrejudice[PSIZE], int baseErasure[PSIZE], int baseHostile[PSIZE])
{
	int p[PSIZE];
	int choice;
	int iIn;
	bool exit = false;

	do {
		bool hasWorkers = false;
		int i = 0;
		int j = 0;
		system("cls");

		cout << "Employment\n\n";
		for (;i < PSIZE; i++) {
			if (baseAccepted[i] + baseCitizen[i] + basePrejudice[i] + baseErasure[i] + baseHostile[i] > 0) {
				hasWorkers = true;
				p[j++] = i;
				cout << "Fully Accepted " << profession[i] << ": " << baseAccepted[i] << endl
					 << "Second-class " << profession[i] << ": " << baseCitizen[i] << endl
					 << "Openly Prejudiced " << profession[i] << ": " << basePrejudice[i] << endl
					 << "Culturally Erased " << profession[i] << ": " << baseErasure[i] << endl
					 << "Violently Discriminated " << profession[i] << ": " << baseHostile[i] << endl;
			}
		}
		if (hasWorkers)
			cout << endl;
		i = 0;
		for (int k = 0; k < j; k++) {
			cout << ++i << ". Set Second-class " << profession[p[k]] << endl;
			cout << ++i << ". Set Openly Prejudiced " << profession[p[k]] << endl;
			cout << ++i << ". Set Culturally Erased " << profession[p[k]] << endl;
			cout << ++i << ". Set Violently Discriminated " << profession[p[k]] << endl;
		}
		cout << "0. Exit\n\n"
			 << "Enter your choice: ";
		cin >> choice;

		if (!cin) {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			if (i == 0) i = 1;
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice < 0 || choice > i) {
			system("cls");
			cout << "Error choose 0-" << i << endl << endl;
			system("pause");
		}
		else if (choice == 0)
			exit = true;
		else if (choice % 4 == 1) {
			choice = (choice - 1) / 4;
			system("cls");
			cout << "Enter Second-class " << profession[p[choice]] << ": ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				baseAccepted[p[choice]] += baseCitizen[p[choice]];
				if (iIn > baseAccepted[p[choice]])
					iIn = baseAccepted[p[choice]];
				baseAccepted[p[choice]] -= iIn;
				baseCitizen[p[choice]] = iIn;
			}
		}
		else if (choice % 4 == 2) {
			choice = (choice - 1) / 4;
			system("cls");
			cout << "Enter Openly Prejudiced " << profession[p[choice]] << ": ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				baseAccepted[p[choice]] += basePrejudice[p[choice]];
				if (iIn > baseAccepted[p[choice]])
					iIn = baseAccepted[p[choice]];
				baseAccepted[p[choice]] -= iIn;
				basePrejudice[p[choice]] = iIn;
			}
		}
		else if (choice % 4 == 3) {
			choice = (choice - 1) / 4;
			system("cls");
			cout << "Enter Culturally Erased " << profession[p[choice]] << ": ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				baseAccepted[p[choice]] += baseErasure[p[choice]];
				if (iIn > baseAccepted[p[choice]])
					iIn = baseAccepted[p[choice]];
				baseAccepted[p[choice]] -= iIn;
				baseErasure[p[choice]] = iIn;
			}
		}
		else {
			choice = (choice - 1) / 4;
			system("cls");
			cout << "Enter Violently Discriminated " << profession[p[choice]] << ": ";
			cin >> iIn;

			if (!cin) {
				cin.clear();
				cin.ignore(numeric_limits<streamsize>::max(), '\n');
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
			}
			else {
				baseAccepted[p[choice]] += baseHostile[p[choice]];
				if (iIn > baseAccepted[p[choice]])
					iIn = baseAccepted[p[choice]];
				baseAccepted[p[choice]] -= iIn;
				baseHostile[p[choice]] = iIn;
			}
		}
	} while (!exit);
}

void profitability(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float input[GSIZE], float output[GSIZE], float cost[2], float income[2], float profit[2][6], float mapi, int level, int newLevel, int methodLevel[LSIZE], int workers[2], int accepted[PSIZE][2], int citizen[PSIZE][2], int prejudice[PSIZE][2], int erasure[PSIZE][2], int hostile[PSIZE][2], float wage[2], int bIt, int lIt)
{
	string in;
	char answer = '\0';
	system("cls");

	cout << building[bIt].getBuilding() << endl
		 << "Level: " << level << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getArmyUnitType(i);
				else {
					cout << location[lIt].getNavyUnitType(i);
				}
			}
			else {
				cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
			}
			cout << endl;
		}
	}
	if (level > 0) {
		if (building[bIt].getInfrastructureUsage(level) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level) << endl;
		for (int i = 0; i < PSIZE; i++) {
			if (accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] > 0)
				cout << profession[i] << ": " << accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] << endl;
		}
		if (cost[0] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) != 0) {
					cout << good[i].getInput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			if (wage[0] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[0]) << endl
					 << "Total Cost: $" << trunc2D(cost[0] + wage[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9 + wage[0]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75 + wage[0]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65 + wage[0]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5 + wage[0]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25 + wage[0]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25) << endl;
				}
			}
		}
		else if (wage[0] != 0)
			cout << "Total Wages: $" << trunc2D(wage[0]) << endl;
		if (income[0] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) != 0) {
					cout << good[i].getOutput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[0]) << endl;
		}
		cout << endl;
		if (wage[0] != 0) {
			cout << "Profit: $" << trunc2D(profit[0][0] - wage[0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1] - wage[0]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2] - wage[0]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3] - wage[0]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4] - wage[0]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5] - wage[0]) << endl
					 << "No Construction Profit: $" << trunc2D(income[0] - wage[0]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		if (profit[0][0] > 0)
			cout << "Productivity: $" << trunc2D(52 * profit[0][0] / workers[0]) << endl;
	}
	cout << endl
		 << building[bIt].getBuilding() << endl
		 << "Level: " << newLevel << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
				else {
					cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
				}
			}
			else {
				cout << " Level: " << methodLevel[i] + 1;
			}
			cout << endl;
		}
	}
	if (newLevel > 0) {
		if (building[bIt].getInfrastructureUsage(newLevel) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(newLevel) << endl;
		for (int i = 0; i < PSIZE; i++) {
			if (accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] > 0)
				cout << profession[i] << ": " << accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] << endl;
		}
		if (cost[1] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(1) != 0) {
					cout << good[i].getInput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
			if (wage[1] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[1]) << endl
					 << "Total Cost: $" << trunc2D(cost[1] + wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9 + wage[1]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75 + wage[1]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65 + wage[1]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5 + wage[1]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25 + wage[1]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25) << endl;
				}
			}
		}
		else if (wage[1] != 0)
			cout << "Total Wages: $" << trunc2D(wage[1]) << endl;
		if (income[1] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(1) != 0) {
					cout << good[i].getOutput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[1]) << endl;
		}
		cout << endl;
		if (wage[1] != 0) {
			cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
					 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		if (profit[1][0] > 0) {
			cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
			if (building[bIt].buildable()) {
				cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
					 << "Profitability: $" << trunc2D(20 * profit[1][0] / newLevel / building[bIt].getConstructionCost()) << endl;
			}
		}
		if (level > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			if (building[bIt].getInfrastructureUsage(newLevel - level) > 0)
				cout << endl << "Infrastructure Usage Difference: +" << building[bIt].getInfrastructureUsage(newLevel - level);
			else if (building[bIt].getInfrastructureUsage(newLevel - level) < 0)
				cout << endl << "Infrastructure Usage Difference: " << building[bIt].getInfrastructureUsage(newLevel - level);
		}
	}
	cout << endl;
	if (cost[0] + cost[1] > 0) {
		cout << "Input Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getInput(0) + good[i].getInput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (input[i] > 0)
					cout << "+";
				cout << input[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercent(mapi, input[i], output[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercent(0, input[i], output[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercent(0, input[i], output[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
	}
	if (income[0] + income[1] > 0) {
		cout << "Output Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (output[i] > 0)
					cout << "+";
				cout << output[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPrice(mapi, input[i], output[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercent(mapi, input[i], output[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercent(mapi, input[i], output[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercent(0, input[i], output[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercent(0, input[i], output[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
		cout << endl;
	}
	else if (cost[0] + cost[1] > 0)
		cout << endl;
	do {
		cout << "Save Market Data (y/n): ";
		getline(cin, in);
		if (in.length() == 1) {
			answer = in[0];

			if (toupper(answer) == 'Y') {
				for (int i = 0; i < GSIZE; i++) {
					if (good[i].getSellOrders() + output[i] >= 100)
						good[i].setSellOrders(trunc(good[i].getSellOrders() + output[i]));
					else if (good[i].getSellOrders() + output[i] >= 10)
						good[i].setSellOrders(trunc1D(good[i].getSellOrders() + output[i]));
					else {
						good[i].setSellOrders(trunc2D(good[i].getSellOrders() + output[i]));
					}
					if (good[i].getBuyOrders() + input[i] >= 100)
						good[i].setBuyOrders(trunc(good[i].getBuyOrders() + input[i]));
					else if (good[i].getBuyOrders() + input[i] >= 10)
						good[i].setBuyOrders(trunc1D(good[i].getBuyOrders() + input[i]));
					else {
						good[i].setBuyOrders(trunc2D(good[i].getBuyOrders() + input[i]));
					}
					if (good[i].getProduction() + output[i] >= 100)
						good[i].setProduction(trunc(good[i].getProduction() + output[i]));
					else if (good[i].getProduction() + output[i] >= 10)
						good[i].setProduction(trunc1D(good[i].getProduction() + output[i]));
					else {
						good[i].setProduction(trunc2D(good[i].getProduction() + output[i]));
					}
					if (good[i].getConsumption() + input[i] >= 100)
						good[i].setConsumption(trunc(good[i].getConsumption() + input[i]));
					else if (good[i].getConsumption() + input[i] >= 10)
						good[i].setConsumption(trunc1D(good[i].getConsumption() + input[i]));
					else {
						good[i].setConsumption(trunc2D(good[i].getConsumption() + input[i]));
					}
				}
			}
			else if (toupper(answer) != 'N') {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
				system("cls");
			}
		}
		else {
			system("cls");
			cout << "Error invalid input\n\n";
			system("pause");
			system("cls");
		}
	} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
}

void profitability(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float input[GSIZE], float output[GSIZE], float purchaseWeight[GSIZE], float localPurchaseWeight[GSIZE], float cost[2], float income[2], float profit[2][6], float mapi, int level, int newLevel, int methodLevel[LSIZE], int workers[2], int accepted[PSIZE][2], int citizen[PSIZE][2], int prejudice[PSIZE][2], int erasure[PSIZE][2], int hostile[PSIZE][2], float wage[2], int bIt, int lIt)
{
	string in;
	char answer = '\0';
	bool hasPopConsumptionChange = false;
	system("cls");

	cout << building[bIt].getBuilding() << endl
		 << "Level: " << level << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getArmyUnitType(i);
				else {
					cout << location[lIt].getNavyUnitType(i);
				}
			}
			else {
				cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
			}
			cout << endl;
		}
	}
	if (level > 0) {
		if (building[bIt].getInfrastructureUsage(level) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level) << endl;
		for (int i = 0; i < PSIZE; i++) {
			if (accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] > 0)
				cout << profession[i] << ": " << accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] << endl;
		}
		if (cost[0] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) != 0) {
					cout << good[i].getInput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			if (wage[0] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[0]) << endl
					 << "Total Cost: $" << trunc2D(cost[0] + wage[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9 + wage[0]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75 + wage[0]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65 + wage[0]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5 + wage[0]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25 + wage[0]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25) << endl;
				}
			}
		}
		else if (wage[0] != 0)
			cout << "Total Wages: $" << trunc2D(wage[0]) << endl;
		if (income[0] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) != 0) {
					cout << good[i].getOutput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[0]) << endl;
		}
		cout << endl;
		if (wage[0] != 0) {
			cout << "Profit: $" << trunc2D(profit[0][0] - wage[0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1] - wage[0]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2] - wage[0]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3] - wage[0]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4] - wage[0]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5] - wage[0]) << endl
					 << "No Construction Profit: $" << trunc2D(income[0] - wage[0]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		if (profit[0][0] > 0)
			cout << "Productivity: $" << trunc2D(52 * profit[0][0] / workers[0]) << endl;
	}
	cout << endl
		 << building[bIt].getBuilding() << endl
		 << "Level: " << newLevel << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
				else {
					cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
				}
			}
			else {
				cout << " Level: " << methodLevel[i] + 1;
			}
			cout << endl;
		}
	}
	if (newLevel > 0) {
		int i = 0;

		if (building[bIt].getInfrastructureUsage(newLevel) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(newLevel) << endl;
		for (;i < PSIZE; i++) {
			if (accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] > 0)
				cout << profession[i] << ": " << accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] << endl;
		}
		for (i = 0; good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) == 0 && i < GSIZE; i++) {}
		if (i < GSIZE)
			hasPopConsumptionChange = true;
		if (hasPopConsumptionChange) {
			cout << endl
				 << "Pop Consumption Changes\n";
			for (i = 0; i < GSIZE; i++) {
				if (good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) != 0) {
					cout << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (cost[1] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (i = 0; i < GSIZE; i++) {
				if (good[i].getInput(1) != 0) {
					cout << good[i].getInput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
			if (wage[1] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[1]) << endl
					 << "Total Cost: $" << trunc2D(cost[1] + wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9 + wage[1]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75 + wage[1]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65 + wage[1]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5 + wage[1]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25 + wage[1]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25) << endl;
				}
			}
		}
		else if (wage[1] != 0)
			cout << "Total Wages: $" << trunc2D(wage[1]) << endl;
		if (income[1] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(1) != 0) {
					cout << good[i].getOutput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[1]) << endl;
		}
		cout << endl;
		if (wage[1] != 0) {
			cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
					 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		if (profit[1][0] > 0) {
			cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
			if (building[bIt].buildable()) {
				cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
					 << "Profitability: $" << trunc2D(20 * profit[1][0] / newLevel / building[bIt].getConstructionCost()) << endl;
			}
		}
		if (level > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			if (building[bIt].getInfrastructureUsage(newLevel - level) > 0)
				cout << endl << "Infrastructure Usage Difference: +" << building[bIt].getInfrastructureUsage(newLevel - level);
			else if (building[bIt].getInfrastructureUsage(newLevel - level) < 0)
				cout << endl << "Infrastructure Usage Difference: " << building[bIt].getInfrastructureUsage(newLevel - level);
		}
	}
	cout << endl;
	if (hasPopConsumptionChange) {
		cout << "Pop Consumption Changes\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) != 0) {
				cout << good[i].getGood() << " Difference: ";
				if (good[i].getPopConsumptionChange(purchaseWeight[i]) > 0)
					cout << "+";
				cout << good[i].getPopConsumptionChange(purchaseWeight[i]) << "/";
				if (good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) > 0)
					cout << "+";
				cout << good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
	}
	if (cost[0] + cost[1] > 0) {
		cout << "Input Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getInput(0) + good[i].getInput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (input[i] > 0)
					cout << "+";
				cout << input[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
	}
	if (income[0] + income[1] > 0) {
		cout << "Output Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (output[i] > 0)
					cout << "+";
				cout << output[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], purchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], purchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPricePrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPrediction(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPrediction(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
		cout << endl;
	}
	else if (hasPopConsumptionChange || cost[0] + cost[1] > 0)
		cout << endl;
	do {
		cout << "Save Market Data (y/n): ";
		getline(cin, in);
		if (in.length() == 1) {
			answer = in[0];

			if (toupper(answer) == 'Y') {
				for (int i = 0; i < GSIZE; i++) {
					if (good[i].getSellOrders() + output[i] >= 100)
						good[i].setSellOrders(trunc(good[i].getSellOrders() + output[i]));
					else if (good[i].getSellOrders() + output[i] >= 10)
						good[i].setSellOrders(trunc1D(good[i].getSellOrders() + output[i]));
					else {
						good[i].setSellOrders(trunc2D(good[i].getSellOrders() + output[i]));
					}
					if (good[i].getBuyOrders() + input[i] + good[i].getPopConsumptionChange(purchaseWeight[i]) >= 100)
						good[i].setBuyOrders(trunc(good[i].getBuyOrders() + input[i] + good[i].getPopConsumptionChange(purchaseWeight[i])));
					else if (good[i].getBuyOrders() + input[i] + good[i].getPopConsumptionChange(purchaseWeight[i]) >= 10)
						good[i].setBuyOrders(trunc1D(good[i].getBuyOrders() + input[i] + good[i].getPopConsumptionChange(purchaseWeight[i])));
					else {
						good[i].setBuyOrders(trunc2D(good[i].getBuyOrders() + input[i] + good[i].getPopConsumptionChange(purchaseWeight[i])));
					}
					if (good[i].getProduction() + output[i] >= 100)
						good[i].setProduction(trunc(good[i].getProduction() + output[i]));
					else if (good[i].getProduction() + output[i] >= 10)
						good[i].setProduction(trunc1D(good[i].getProduction() + output[i]));
					else {
						good[i].setProduction(trunc2D(good[i].getProduction() + output[i]));
					}
					if (good[i].getConsumption() + input[i] + good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) >= 100)
						good[i].setConsumption(trunc(good[i].getConsumption() + input[i] + good[i].getLocalPopConsumptionChange(localPurchaseWeight[i])));
					else if (good[i].getConsumption() + input[i] + good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) >= 10)
						good[i].setConsumption(trunc1D(good[i].getConsumption() + input[i] + good[i].getLocalPopConsumptionChange(localPurchaseWeight[i])));
					else {
						good[i].setConsumption(trunc2D(good[i].getConsumption() + input[i] + good[i].getLocalPopConsumptionChange(localPurchaseWeight[i])));
					}
					if (good[i].getPopConsumption() * purchaseWeight[i] >= 100)
						good[i].setPopConsumption(trunc(good[i].getPopConsumption() * purchaseWeight[i]));
					else if (good[i].getPopConsumption() * purchaseWeight[i] >= 10)
						good[i].setPopConsumption(trunc1D(good[i].getPopConsumption() * purchaseWeight[i]));
					else {
						good[i].setPopConsumption(trunc2D(good[i].getPopConsumption() * purchaseWeight[i]));
					}
					if (good[i].getLocalPopConsumption() * localPurchaseWeight[i] >= 100)
						good[i].setLocalPopConsumption(trunc(good[i].getLocalPopConsumption() * localPurchaseWeight[i]));
					else if (good[i].getLocalPopConsumption() * localPurchaseWeight[i] >= 10)
						good[i].setLocalPopConsumption(trunc1D(good[i].getLocalPopConsumption() * localPurchaseWeight[i]));
					else {
						good[i].setLocalPopConsumption(trunc2D(good[i].getLocalPopConsumption() * localPurchaseWeight[i]));
					}
				}
			}
			else if (toupper(answer) != 'N') {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
				system("cls");
			}
		}
		else {
			system("cls");
			cout << "Error invalid input\n\n";
			system("pause");
			system("cls");
		}
	} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
}

void profitabilityImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float input[GSIZE], float output[GSIZE], float cost[2], float income[2], float profit[2][6], float mapi, int level, int newLevel, int methodLevel[LSIZE], int workers[2], int accepted[PSIZE][2], int citizen[PSIZE][2], int prejudice[PSIZE][2], int erasure[PSIZE][2], int hostile[PSIZE][2], float wage[2], int bIt, int lIt)
{
	string in;
	char answer = '\0';
	system("cls");

	cout << building[bIt].getBuilding() << endl
		 << "Level: " << level << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getArmyUnitType(i);
				else {
					cout << location[lIt].getNavyUnitType(i);
				}
			}
			else {
				cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
			}
			cout << endl;
		}
	}
	if (level > 0) {
		if (building[bIt].getInfrastructureUsage(level) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level) << endl;
		for (int i = 0; i < PSIZE; i++) {
			if (accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] > 0)
				cout << profession[i] << ": " << accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] << endl;
		}
		if (cost[0] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) != 0) {
					cout << good[i].getInput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			if (wage[0] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[0]) << endl
					 << "Total Cost: $" << trunc2D(cost[0] + wage[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9 + wage[0]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75 + wage[0]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65 + wage[0]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5 + wage[0]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25 + wage[0]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25) << endl;
				}
			}
		}
		else if (wage[0] != 0)
			cout << "Total Wages: $" << trunc2D(wage[0]) << endl;
		if (income[0] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) != 0) {
					cout << good[i].getOutput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[0]) << endl;
		}
		cout << endl;
		if (wage[0] != 0) {
			cout << "Profit: $" << trunc2D(profit[0][0] - wage[0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1] - wage[0]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2] - wage[0]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3] - wage[0]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4] - wage[0]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5] - wage[0]) << endl
					 << "No Construction Profit: $" << trunc2D(income[0] - wage[0]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		if (profit[0][0] > 0)
			cout << "Productivity: $" << trunc2D(52 * profit[0][0] / workers[0]) << endl;
	}
	cout << endl
		 << building[bIt].getBuilding() << endl
		 << "Level: " << newLevel << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
				else {
					cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
				}
			}
			else {
				cout << " Level: " << methodLevel[i] + 1;
			}
			cout << endl;
		}
	}
	if (newLevel > 0) {
		if (building[bIt].getInfrastructureUsage(newLevel) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(newLevel) << endl;
		for (int i = 0; i < PSIZE; i++) {
			if (accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] > 0)
				cout << profession[i] << ": " << accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] << endl;
		}
		if (cost[1] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(1) != 0) {
					cout << good[i].getInput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports())) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
			if (wage[1] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[1]) << endl
					 << "Total Cost: $" << trunc2D(cost[1] + wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9 + wage[1]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75 + wage[1]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65 + wage[1]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5 + wage[1]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25 + wage[1]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25) << endl;
				}
			}
		}
		else if (wage[1] != 0)
			cout << "Total Wages: $" << trunc2D(wage[1]) << endl;
		if (income[1] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(1) != 0) {
					cout << good[i].getOutput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i])) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports())) << " ";
						if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i])) << " ";
						if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[1]) << endl;
		}
		cout << endl;
		if (wage[1] != 0) {
			cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
					 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		if (profit[1][0] > 0) {
			cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
			if (building[bIt].buildable()) {
				cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
					 << "Profitability: $" << trunc2D(20 * profit[1][0] / newLevel / building[bIt].getConstructionCost()) << endl;
			}
		}
		if (level > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			if (building[bIt].getInfrastructureUsage(newLevel - level) > 0)
				cout << endl << "Infrastructure Usage Difference: +" << building[bIt].getInfrastructureUsage(newLevel - level);
			else if (building[bIt].getInfrastructureUsage(newLevel - level) < 0)
				cout << endl << "Infrastructure Usage Difference: " << building[bIt].getInfrastructureUsage(newLevel - level);
		}
	}
	cout << endl;
	if (cost[0] + cost[1] > 0) {
		cout << "Input Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getInput(0) + good[i].getInput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (input[i] > 0)
					cout << "+";
				cout << input[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports()) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
	}
	if (income[0] + income[1] > 0) {
		cout << "Output Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (output[i] > 0)
					cout << "+";
				cout << output[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPrice(input[i], output[i] - good[i].getImports()) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercent(input[i], output[i] - good[i].getImports()) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPriceImportsCanceled(mapi, input[i], output[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentImportsCanceled(mapi, input[i], output[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentImportsCanceled(0, input[i], output[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
		cout << endl;
	}
	else if (cost[0] + cost[1] > 0)
		cout << endl;
	do {
		cout << "Save Market Data (y/n): ";
		getline(cin, in);
		if (in.length() == 1) {
			answer = in[0];

			if (toupper(answer) == 'Y') {
				for (int i = 0; i < GSIZE; i++) {
					if (good[i].getSellOrders() + output[i] >= 100)
						good[i].setSellOrders(trunc(good[i].getSellOrders() + output[i]));
					else if (good[i].getSellOrders() + output[i] >= 10)
						good[i].setSellOrders(trunc1D(good[i].getSellOrders() + output[i]));
					else {
						good[i].setSellOrders(trunc2D(good[i].getSellOrders() + output[i]));
					}
					if (good[i].getBuyOrders() + input[i] >= 100)
						good[i].setBuyOrders(trunc(good[i].getBuyOrders() + input[i]));
					else if (good[i].getBuyOrders() + input[i] >= 10)
						good[i].setBuyOrders(trunc1D(good[i].getBuyOrders() + input[i]));
					else {
						good[i].setBuyOrders(trunc2D(good[i].getBuyOrders() + input[i]));
					}
					if (good[i].getProduction() + output[i] >= 100)
						good[i].setProduction(trunc(good[i].getProduction() + output[i]));
					else if (good[i].getProduction() + output[i] >= 10)
						good[i].setProduction(trunc1D(good[i].getProduction() + output[i]));
					else {
						good[i].setProduction(trunc2D(good[i].getProduction() + output[i]));
					}
					if (good[i].getConsumption() + input[i] >= 100)
						good[i].setConsumption(trunc(good[i].getConsumption() + input[i]));
					else if (good[i].getConsumption() + input[i] >= 10)
						good[i].setConsumption(trunc1D(good[i].getConsumption() + input[i]));
					else {
						good[i].setConsumption(trunc2D(good[i].getConsumption() + input[i]));
					}
				}
			}
			else if (toupper(answer) != 'N') {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
				system("cls");
			}
		}
		else {
			system("cls");
			cout << "Error invalid input\n\n";
			system("pause");
			system("cls");
		}
	} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
}

void profitabilityImportsCanceled(goodsType good[GSIZE], productionMethodsType& method, buildingsType building[BSIZE], locationsType location[SSIZE], string profession[PSIZE], float input[GSIZE], float output[GSIZE], float purchaseWeight[GSIZE], float localPurchaseWeight[GSIZE], float cost[2], float income[2], float profit[2][6], float mapi, int level, int newLevel, int methodLevel[LSIZE], int workers[2], int accepted[PSIZE][2], int citizen[PSIZE][2], int prejudice[PSIZE][2], int erasure[PSIZE][2], int hostile[PSIZE][2], float wage[2], int bIt, int lIt)
{
	string in;
	char answer = '\0';
	bool hasPopConsumptionChange = false;
	system("cls");

	cout << building[bIt].getBuilding() << endl
		 << "Level: " << level << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getArmyUnitType(i);
				else {
					cout << location[lIt].getNavyUnitType(i);
				}
			}
			else {
				cout << " Level: " << location[lIt].getProductionMethodLevel(i) + 1;
			}
			cout << endl;
		}
	}
	if (level > 0) {
		if (building[bIt].getInfrastructureUsage(level) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(level) << endl;
		for (int i = 0; i < PSIZE; i++) {
			if (accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] > 0)
				cout << profession[i] << ": " << accepted[i][0] + citizen[i][0] + prejudice[i][0] + erasure[i][0] + hostile[i][0] << endl;
		}
		if (cost[0] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getInput(0) != 0) {
					cout << good[i].getInput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			if (wage[0] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[0]) << endl
					 << "Total Cost: $" << trunc2D(cost[0] + wage[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9 + wage[0]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75 + wage[0]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65 + wage[0]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5 + wage[0]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25 + wage[0]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[0]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[0] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[0] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[0] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[0] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[0] * 0.25) << endl;
				}
			}
		}
		else if (wage[0] != 0)
			cout << "Total Wages: $" << trunc2D(wage[0]) << endl;
		if (income[0] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (int i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(0) != 0) {
					cout << good[i].getOutput(0) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPrice()) << " ";
						if (good[i].getMarketPricePercent() > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercent() * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPrice(mapi)) << " ";
						if (good[i].getLocalPricePercent(mapi) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(mapi) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercent(0) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercent(0) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[0]) << endl;
		}
		cout << endl;
		if (wage[0] != 0) {
			cout << "Profit: $" << trunc2D(profit[0][0] - wage[0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1] - wage[0]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2] - wage[0]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3] - wage[0]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4] - wage[0]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5] - wage[0]) << endl
					 << "No Construction Profit: $" << trunc2D(income[0] - wage[0]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[0][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[0][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[0][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[0][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[0][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[0][5]) << endl;
			}
		}
		if (profit[0][0] > 0)
			cout << "Productivity: $" << trunc2D(52 * profit[0][0] / workers[0]) << endl;
	}
	cout << endl
		 << building[bIt].getBuilding() << endl
		 << "Level: " << newLevel << endl;
	for (int i = 0; i < building[bIt].getSize(); i++) {
		if (method.getSize(i + building[bIt].getProductionMethod()) > 1) {
			cout << method.getProductionMethod(i + building[bIt].getProductionMethod());
			if (method.getProductionMethod(i + building[bIt].getProductionMethod()) == "Military Unit Type") {
				cout << ": ";
				if (building[bIt].getBuilding() == "Barracks")
					cout << location[lIt].getNewArmyUnitType(methodLevel[i]);
				else {
					cout << location[lIt].getNewNavyUnitType(methodLevel[i]);
				}
			}
			else {
				cout << " Level: " << methodLevel[i] + 1;
			}
			cout << endl;
		}
	}
	if (newLevel > 0) {
		int i = 0;

		if (building[bIt].getInfrastructureUsage(newLevel) > 0)
			cout << "Infrastructure Usage: " << building[bIt].getInfrastructureUsage(newLevel) << endl;
		for (;i < PSIZE; i++) {
			if (accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] > 0)
				cout << profession[i] << ": " << accepted[i][1] + citizen[i][1] + prejudice[i][1] + erasure[i][1] + hostile[i][1] << endl;
		}
		for (i = 0; good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) == 0 && i < GSIZE; i++) {}
		if (i < GSIZE)
			hasPopConsumptionChange = true;
		if (hasPopConsumptionChange) {
			cout << endl
				 << "Pop Consumption Changes\n";
			for (i = 0; i < GSIZE; i++) {
				if (good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) != 0) {
					cout << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
		}
		if (cost[1] != 0) {
			cout << endl
				 << "Input Goods\n";
			for (i = 0; i < GSIZE; i++) {
				if (good[i].getInput(1) != 0) {
					cout << good[i].getInput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
			if (wage[1] != 0) {
				cout << "Total Wages: $" << trunc2D(wage[1]) << endl
					 << "Total Cost: $" << trunc2D(cost[1] + wage[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9 + wage[1]) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75 + wage[1]) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65 + wage[1]) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5 + wage[1]) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25 + wage[1]) << endl;
				}
			}
			else {
				cout << "Total Cost: $" << trunc2D(cost[1]) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Cost: $" << trunc2D(cost[1] * 0.9) << endl
						 << "25% Private Construction Cost: $" << trunc2D(cost[1] * 0.75) << endl
						 << "35% Private Construction Cost: $" << trunc2D(cost[1] * 0.65) << endl
						 << "50% Private Construction Cost: $" << trunc2D(cost[1] * 0.5) << endl
						 << "75% Private Construction Cost: $" << trunc2D(cost[1] * 0.25) << endl;
				}
			}
		}
		else if (wage[1] != 0)
			cout << "Total Wages: $" << trunc2D(wage[1]) << endl;
		if (income[1] != 0) {
			cout << endl
				 << "Output Goods\n";
			for (i = 0; i < GSIZE; i++) {
				if (good[i].getOutput(1) != 0) {
					cout << good[i].getOutput(1) << " " << good[i].getGood() << ": ";
					if (good[i].localGood()) {
						cout << "Local Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
					else {
						cout << "Market Price: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i])) << " ";
						if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) * 100) << "%, Local Price: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i])) << " ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%, Local Value: ";
						if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > 0)
							cout << "+";
						cout << trunc(good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) * 100) << "%\n";
					}
				}
			}
			cout << "Total Income: $" << trunc2D(income[1]) << endl;
		}
		cout << endl;
		if (wage[1] != 0) {
			cout << "Profit: $" << trunc2D(profit[1][0] - wage[1]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1] - wage[1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2] - wage[1]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3] - wage[1]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4] - wage[1]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5] - wage[1]) << endl
					 << "No Construction Profit: $" << trunc2D(income[1] - wage[1]) << endl;
			}
			cout << "Production: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Production: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Production: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Production: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Production: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Production: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		else {
			cout << "Profit: $" << trunc2D(profit[1][0]) << endl;
			if (building[bIt].getBuilding() == "Construction Sector") {
				cout << "10% Private Construction Profit: $" << trunc2D(profit[1][1]) << endl
					 << "25% Private Construction Profit: $" << trunc2D(profit[1][2]) << endl
					 << "35% Private Construction Profit: $" << trunc2D(profit[1][3]) << endl
					 << "50% Private Construction Profit: $" << trunc2D(profit[1][4]) << endl
					 << "75% Private Construction Profit: $" << trunc2D(profit[1][5]) << endl;
			}
		}
		if (profit[1][0] > 0) {
			cout << "Productivity: $" << trunc2D(52 * profit[1][0] / workers[1]) << endl;
			if (building[bIt].buildable()) {
				cout << "Productivity/Construction: $" << trunc2D(26000 * profit[1][0] / workers[1] / building[bIt].getConstructionCost()) << endl
					 << "Profitability: $" << trunc2D(20 * profit[1][0] / newLevel / building[bIt].getConstructionCost()) << endl;
			}
		}
		if (level > 0) {
			cout << endl;
			if (wage[0] + wage[1] > 0) {
				cout << "Profit Difference: $" << trunc2D((profit[1][0] - wage[1]) - (profit[0][0] - wage[0])) << endl;
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << "10% Private Construction Profit Difference: $" << trunc2D((profit[1][1] - wage[1]) - (profit[0][1] - wage[0])) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D((profit[1][2] - wage[1]) - (profit[0][2] - wage[0])) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D((profit[1][3] - wage[1]) - (profit[0][3] - wage[0])) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D((profit[1][4] - wage[1]) - (profit[0][4] - wage[0])) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D((profit[1][5] - wage[1]) - (profit[0][5] - wage[0])) << endl
						 << "No Construction Profit Difference: $" << trunc2D((income[1] - wage[1]) - (income[0] - wage[0])) << endl;
				}
				cout << "Production Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Production Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Production Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Production Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Production Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Production Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Production Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			else {
				cout << "Profit Difference: $" << trunc2D(profit[1][0] - profit[0][0]);
				if (building[bIt].getBuilding() == "Construction Sector") {
					cout << endl
						 << "10% Private Construction Profit Difference: $" << trunc2D(profit[1][1] - profit[0][1]) << endl
						 << "25% Private Construction Profit Difference: $" << trunc2D(profit[1][2] - profit[0][2]) << endl
						 << "35% Private Construction Profit Difference: $" << trunc2D(profit[1][3] - profit[0][3]) << endl
						 << "50% Private Construction Profit Difference: $" << trunc2D(profit[1][4] - profit[0][4]) << endl
						 << "75% Private Construction Profit Difference: $" << trunc2D(profit[1][5] - profit[0][5]) << endl
						 << "No Construction Profit Difference: $" << trunc2D(income[1] - income[0]);
				}
			}
			if (building[bIt].getInfrastructureUsage(newLevel - level) > 0)
				cout << endl << "Infrastructure Usage Difference: +" << building[bIt].getInfrastructureUsage(newLevel - level);
			else if (building[bIt].getInfrastructureUsage(newLevel - level) < 0)
				cout << endl << "Infrastructure Usage Difference: " << building[bIt].getInfrastructureUsage(newLevel - level);
		}
	}
	cout << endl;
	if (hasPopConsumptionChange) {
		cout << "Pop Consumption Changes\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) != 0) {
				cout << good[i].getGood() << " Difference: ";
				if (good[i].getPopConsumptionChange(purchaseWeight[i]) > 0)
					cout << "+";
				cout << good[i].getPopConsumptionChange(purchaseWeight[i]) << "/";
				if (good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) > 0)
					cout << "+";
				cout << good[i].getLocalPopConsumptionChange(localPurchaseWeight[i]) << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
	}
	if (cost[0] + cost[1] > 0) {
		cout << "Input Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getInput(0) + good[i].getInput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (input[i] > 0)
					cout << "+";
				cout << input[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
	}
	if (income[0] + income[1] > 0) {
		cout << "Output Goods\n";
		for (int i = 0; i < GSIZE; i++) {
			if (good[i].getOutput(0) + good[i].getOutput(1) > 0) {
				cout << good[i].getGood() << " Difference: ";
				if (output[i] > 0)
					cout << "+";
				cout << output[i] << ", ";
				if (good[i].localGood()) {
					cout << "Local Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i], localPurchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%\n";
				}
				else {
					cout << "Market Price Difference: $" << trunc1D(good[i].getMarketPricePrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) - good[i].getMarketPrice()) << " ";
					if (good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) > good[i].getMarketPricePercent())
						cout << "+";
					cout << trunc((good[i].getMarketPricePercentPrediction(input[i], output[i] - good[i].getImports(), purchaseWeight[i]) - good[i].getMarketPricePercent()) * 100) << "%, Local Price Difference: $" << trunc1D(good[i].getLocalPricePredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPrice(mapi)) << " ";
					if (good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(mapi))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPredictionImportsCanceled(mapi, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(mapi)) * 100) << "%, Local Value Difference: ";
					if (good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) > good[i].getLocalPricePercent(0))
						cout << "+";
					cout << trunc((good[i].getLocalPricePercentPredictionImportsCanceled(0, input[i], output[i], purchaseWeight[i], localPurchaseWeight[i]) - good[i].getLocalPricePercent(0)) * 100) << "%\n";
				}
			}
		}
		cout << endl;
	}
	else if (hasPopConsumptionChange || cost[0] + cost[1] > 0)
		cout << endl;
	do {
		cout << "Save Market Data (y/n): ";
		getline(cin, in);
		if (in.length() == 1) {
			answer = in[0];

			if (toupper(answer) == 'Y') {
				for (int i = 0; i < GSIZE; i++) {
					if (good[i].getSellOrders() + output[i] >= 100)
						good[i].setSellOrders(trunc(good[i].getSellOrders() + output[i]));
					else if (good[i].getSellOrders() + output[i] >= 10)
						good[i].setSellOrders(trunc1D(good[i].getSellOrders() + output[i]));
					else {
						good[i].setSellOrders(trunc2D(good[i].getSellOrders() + output[i]));
					}
					if (good[i].getBuyOrders() + input[i] >= 100)
						good[i].setBuyOrders(trunc(good[i].getBuyOrders() + input[i]));
					else if (good[i].getBuyOrders() + input[i] >= 10)
						good[i].setBuyOrders(trunc1D(good[i].getBuyOrders() + input[i]));
					else {
						good[i].setBuyOrders(trunc2D(good[i].getBuyOrders() + input[i]));
					}
					if (good[i].getProduction() + output[i] >= 100)
						good[i].setProduction(trunc(good[i].getProduction() + output[i]));
					else if (good[i].getProduction() + output[i] >= 10)
						good[i].setProduction(trunc1D(good[i].getProduction() + output[i]));
					else {
						good[i].setProduction(trunc2D(good[i].getProduction() + output[i]));
					}
					if (good[i].getConsumption() + input[i] >= 100)
						good[i].setConsumption(trunc(good[i].getConsumption() + input[i]));
					else if (good[i].getConsumption() + input[i] >= 10)
						good[i].setConsumption(trunc1D(good[i].getConsumption() + input[i]));
					else {
						good[i].setConsumption(trunc2D(good[i].getConsumption() + input[i]));
					}
				}
			}
			else if (toupper(answer) != 'N') {
				system("cls");
				cout << "Error invalid input\n\n";
				system("pause");
				system("cls");
			}
		}
		else {
			system("cls");
			cout << "Error invalid input\n\n";
			system("pause");
			system("cls");
		}
	} while (toupper(answer) != 'Y' && toupper(answer) != 'N');
}

float getPurchaseWeight(goodsType good[GSIZE], float gdp, int i)
{
	float purchaseWeight = 0;
	
	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++)
			marketShareSum += good[k].getMarketShare(j);
		for (int k = 0; k < GSIZE; k++)
			purchaseWeightSum += good[k].getPurchaseWeight(marketShareSum, gdp, j);
		purchaseWeight += good[i].getPurchaseWeight(marketShareSum, gdp, j) / purchaseWeightSum;
	}

	return purchaseWeight;
}

float getPurchaseWeight(goodsType good[GSIZE], float output, float gdp, int i, int it)
{
	float initialPurchaseWeight = getPurchaseWeight(good, gdp, it);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++) {
			if (i == k)
				marketShareSum += good[i].getMarketShare(output, j);
			else {
				marketShareSum += good[k].getMarketShare(j);
			}
		}
		for (int k = 0; k < GSIZE; k++) {
			if (i == k)
				purchaseWeightSum += good[i].getPurchaseWeight(output, marketShareSum, gdp, j);
			else {
				purchaseWeightSum += good[k].getPurchaseWeight(marketShareSum, gdp, j);
			}
		}
		if (i == it)
			purchaseWeight += good[i].getPurchaseWeight(output, marketShareSum, gdp, j) / purchaseWeightSum;
		else {
			purchaseWeight += good[it].getPurchaseWeight(marketShareSum, gdp, j) / purchaseWeightSum;
		}
	}

	return purchaseWeight / initialPurchaseWeight;
}

float getPurchaseWeightLocalOutput(goodsType good[GSIZE], float output, float gdp, int i, int it)
{
	float initialPurchaseWeight = getPurchaseWeight(good, gdp, it);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++) {
			if (i == k)
				marketShareSum += good[i].getLocalMarketShare(output, j);
			else {
				marketShareSum += good[k].getMarketShare(j);
			}
		}
		for (int k = 0; k < GSIZE; k++) {
			if (i == k)
				purchaseWeightSum += good[i].getPurchaseWeightLocalOutput(output, marketShareSum, gdp, j);
			else {
				purchaseWeightSum += good[k].getPurchaseWeight(marketShareSum, gdp, j);
			}
		}
		if (i == it)
			purchaseWeight += good[i].getPurchaseWeightLocalOutput(output, marketShareSum, gdp, j) / purchaseWeightSum;
		else {
			purchaseWeight += good[it].getPurchaseWeight(marketShareSum, gdp, j) / purchaseWeightSum;
		}
	}

	return purchaseWeight / initialPurchaseWeight;
}

float getPurchaseWeight(goodsType good[GSIZE], float input[GSIZE], float output[GSIZE], float gdp, int i)
{
	float initialPurchaseWeight = getPurchaseWeight(good, gdp, i);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++)
			marketShareSum += good[k].getMarketShare(input[k], output[k], j);
		for (int k = 0; k < GSIZE; k++)
			purchaseWeightSum += good[k].getPurchaseWeight(input[k], output[k], marketShareSum, gdp, j);
		purchaseWeight += good[i].getPurchaseWeight(input[i], output[i], marketShareSum, gdp, j) / purchaseWeightSum;
	}

	return purchaseWeight / initialPurchaseWeight;
}

float getPurchaseWeightImportsCanceled(goodsType good[GSIZE], float input[GSIZE], float output[GSIZE], float gdp, int i)
{
	float initialPurchaseWeight = getPurchaseWeight(good, gdp, i);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++)
			marketShareSum += good[k].getMarketShare(input[k], output[k] - good[k].getImports(), j);
		for (int k = 0; k < GSIZE; k++)
			purchaseWeightSum += good[k].getPurchaseWeight(input[k], output[k] - good[k].getImports(), marketShareSum, gdp, j);
		purchaseWeight += good[i].getPurchaseWeight(input[i], output[i] - good[i].getImports(), marketShareSum, gdp, j) / purchaseWeightSum;
	}

	return purchaseWeight / initialPurchaseWeight;
}

float getLocalPurchaseWeight(goodsType good[GSIZE], float gdp, int i)
{
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++)
			marketShareSum += good[k].getMarketShare(j);
		for (int k = 0; k < GSIZE; k++)
			purchaseWeightSum += good[k].getLocalPurchaseWeight(marketShareSum, gdp, j);
		purchaseWeight += good[i].getLocalPurchaseWeight(marketShareSum, gdp, j) / purchaseWeightSum;
	}

	return purchaseWeight;
}

float getLocalPurchaseWeight(goodsType good[GSIZE], float output, float gdp, int i, int it)
{
	float initialPurchaseWeight = getLocalPurchaseWeight(good, gdp, it);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++) {
			if (i == k)
				marketShareSum += good[i].getLocalMarketShare(output, j);
			else {
				marketShareSum += good[k].getMarketShare(j);
			}
		}
		for (int k = 0; k < GSIZE; k++) {
			if (i == k)
				purchaseWeightSum += good[i].getLocalPurchaseWeight(output, marketShareSum, gdp, j);
			else {
				purchaseWeightSum += good[k].getLocalPurchaseWeight(marketShareSum, gdp, j);
			}
		}
		if (i == it)
			purchaseWeight += good[i].getLocalPurchaseWeight(output, marketShareSum, gdp, j) / purchaseWeightSum;
		else {
			purchaseWeight += good[it].getLocalPurchaseWeight(marketShareSum, gdp, j) / purchaseWeightSum;
		}
	}

	return purchaseWeight / initialPurchaseWeight;
}

float getLocalPurchaseWeight(goodsType good[GSIZE], float input[GSIZE], float output[GSIZE], float gdp, int i)
{
	float initialPurchaseWeight = getLocalPurchaseWeight(good, gdp, i);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++)
			marketShareSum += good[k].getMarketShare(input[k], output[k], j);
		for (int k = 0; k < GSIZE; k++)
			purchaseWeightSum += good[k].getLocalPurchaseWeight(input[k], output[k], marketShareSum, gdp, j);
		purchaseWeight += good[i].getLocalPurchaseWeight(input[i], output[i], marketShareSum, gdp, j) / purchaseWeightSum;
	}

	return purchaseWeight / initialPurchaseWeight;
}

float getLocalPurchaseWeightImportsCanceled(goodsType good[GSIZE], float input[GSIZE], float output[GSIZE], float gdp, int i)
{
	float initialPurchaseWeight = getLocalPurchaseWeight(good, gdp, i);
	if (initialPurchaseWeight == 0)
		return 1;
	float purchaseWeight = 0;

	for (int j = 0; j < NSIZE; j++) {
		float marketShareSum = 0;
		float purchaseWeightSum = 0;

		for (int k = 0; k < GSIZE; k++)
			marketShareSum += good[k].getMarketShare(input[k], output[k] - good[k].getImports(), j);
		for (int k = 0; k < GSIZE; k++)
			purchaseWeightSum += good[k].getLocalPurchaseWeight(input[k], output[k] - good[k].getImports(), marketShareSum, gdp, j);
		purchaseWeight += good[i].getLocalPurchaseWeight(input[i], output[i] - good[i].getImports(), marketShareSum, gdp, j) / purchaseWeightSum;
	}

	return purchaseWeight / initialPurchaseWeight;
}

void save(goodsType good[GSIZE], buildingsType building[BSIZE], locationsType location[SSIZE], float inf, float mapi, float gdp, int states, float eosCap, int citizenship[2], bool mobilization[ASIZE][2])
{
	ofstream outFile;

	outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Infamy.txt");
	outFile << inf;
	outFile.close();
	outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Goods.txt");
	for (int i = 0; i < GSIZE; i++) {
		outFile << good[i].getSellOrders() << endl
				<< good[i].getBuyOrders() << endl
				<< good[i].getProduction() << endl
				<< good[i].getConsumption() << endl
				<< good[i].getPopConsumption() << endl
				<< good[i].getLocalPopConsumption() << endl
				<< good[i].getImports() << endl
				<< good[i].getThroughput() << endl
				<< good[i].getObsession() << endl
				<< good[i].getTaboo() << endl
				<< good[i].getLocalObsession() << endl
				<< good[i].getLocalTaboo() << endl;
	}
	outFile << mapi << endl
			<< gdp << endl
			<< states;
	outFile.close();
	outFile.open("C:\\Users\\RyanJ\\OneDrive\\Desktop\\Vicky3\\Vicky3 Programs\\Buildings.txt");
	for (int i = 1; i < BSIZE; i++) {
		for (int j = building[i - 1].getBuildingLocation(); j < building[i].getBuildingLocation(); j++) {
			outFile << location[j].getLevel() << endl
					<< location[j].getSubsidized() << endl;
			for (int k = 0; k < building[i - 1].getSize(); k++)
				outFile << location[j].getProductionMethodLevel(k) << endl;
			outFile << location[j].getBuildingThroughput() << endl;
		}
		for (int j = 0; j < 7; j++)
			outFile << building[i - 1].getThroughput(j) << endl;
		outFile << building[i - 1].getBaseWage() << endl;
	}
	for (int i = 0; i < ASIZE; i++) {
		for (int j = 0; j < 2; j++)
			outFile << mobilization[i][j] << endl;
	}
	for (int i = 0; i < 2; i++)
		outFile << citizenship[i] << endl;
	outFile << eosCap;
	outFile.close();
}
